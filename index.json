[{"categories":null,"content":"问题描述 IE 浏览器请求数据不会更新。 ","date":"2021-07-03","objectID":"/2021/07/ie-e1/:1:0","tags":["问题"],"title":"IE GET 方式请求数据缓存问题","uri":"/2021/07/ie-e1/"},{"categories":null,"content":"产生原因 IE会缓存GET方式的URL访问返回的数据，如果下一次访问的URL相同的话，IE不会访问服务器而是直接从缓存取数据返回。 ","date":"2021-07-03","objectID":"/2021/07/ie-e1/:2:0","tags":["问题"],"title":"IE GET 方式请求数据缓存问题","uri":"/2021/07/ie-e1/"},{"categories":null,"content":"解决方式 使用 POST 请求(查询的话使用 GET 请求的效率是要比 POST 强上一点的), 或给 GET 请求加上时间戳。 ","date":"2021-07-03","objectID":"/2021/07/ie-e1/:3:0","tags":["问题"],"title":"IE GET 方式请求数据缓存问题","uri":"/2021/07/ie-e1/"},{"categories":null,"content":"简介 Druid 是一个数据库连接池。在功能、性能、扩展性方面，都超过其他数据库连接池，包括 DBCP、C3P0、BoneCP、Proxool、JBoss DataSource。除了在速度上稍慢于 HikariCP 外其他方面都比较全能。Druid 是阿里巴巴开发的号称为监控而生的数据库连接池！如果对监控、功能、扩展性有要求推荐使用 Druid，如果没有太多的额外需求或是单纯需要更好的性能和效率可以选择使用 HikariCP。 ","date":"2021-05-23","objectID":"/2021/05/druid/:1:0","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"基础 ","date":"2021-05-23","objectID":"/2021/05/druid/:2:0","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"Spring Boot 使用 Druid 连接池 参考 如何在Spring Boot中集成Druid连接池和监控？ ","date":"2021-05-23","objectID":"/2021/05/druid/:2:1","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"Druid Monitor 访问 http://localhost:8080/druid/index.html 查看相关监控信息。 ","date":"2021-05-23","objectID":"/2021/05/druid/:2:2","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"配置 spring:datasource:url:jdbc:mysql://localhost:3306/testusername:rootpassword:123456druid:initial-size:5# 初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时min-idle:5# 最小连接池数量max-active:30# 最大连接池数量max-wait:60000# 获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置time-between-eviction-runs-millis:60000# 关闭空闲连接的检测时间间隔.Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。min-evictable-idle-time-millis:300000# 连接的最小生存时间.连接保持空闲而不被驱逐的最小时间validation-query:SELECT1# 验证数据库服务可用性的sql.用来检测连接是否有效的sql 因数据库方言而差, 例如 oracle 应该写成 SELECT 1 FROM DUALtest-while-idle:true# 申请连接时检测空闲时间，根据空闲时间再检测连接是否有效.建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRuntest-on-borrow:false# 申请连接时直接检测连接是否有效.申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。test-on-return:false# 归还连接时检测连接是否有效.归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。pool-prepared-statements:true# 开启PSCachemax-pool-prepared-statement-per-connection-size=:20#设置PSCache值connection-error-retry-attempts:3# 连接出错后再尝试连接三次break-after-acquire-failure:true# 数据库服务宕机自动重连机制time-between-connect-error-millis:300000# 连接出错后重试时间间隔async-init:true# 异步初始化策略remove-abandoned:true# 是否自动回收超时连接remove-abandoned-timeout:1800# 超时时间(以秒数为单位)transaction-query-timeout:6000# 事务超时时间filters:stat,wall,slf4jfilter:stat:enabled:truelog-slow-sql:trueslow-sql-millis:3000wall:enabled:trueconfig:delete-allow:false# 不允许执行 DELETEdrop-table-allow:false# 不允许执行 DROP TABLEslf4j:enabled:truestatement-log-enabled:false# 关闭大量无用 SQL LOG 输出statement-executable-sql-log-enable:true# 可执行 SQL 输出web-stat-filter:enabled:trueurl-pattern:\"/*\"exclusions:\"*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*\"stat-view-servlet:url-pattern:\"/druid/*\"allow:deny:reset-enable:falselogin-username:adminlogin-password:adminlogging:level:druid:sql:Statement:DEBUG ","date":"2021-05-23","objectID":"/2021/05/druid/:2:3","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"扩展 ","date":"2021-05-23","objectID":"/2021/05/druid/:3:0","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"应用场景 Druid Wiki 非常清晰，Druid 的应用场景可以参考其解决。包含监控、SQL 注入、数据库迁移、慢 SQL 记录、数据库密码加密、测试连接池是否有效等。 ","date":"2021-05-23","objectID":"/2021/05/druid/:3:1","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"参考 Druid Wiki ","date":"2021-05-23","objectID":"/2021/05/druid/:4:0","tags":["框架"],"title":"唯二好用的连接池之 Druid 的使用","uri":"/2021/05/druid/"},{"categories":null,"content":"语言 HTML 知识总结 CSS 知识总结 JavaScript 知识总结 Java 知识总结 TypeScript 知识总结 ","date":"2021-05-14","objectID":"/mind-map/:1:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"框架 Jquery 的使用 React 的使用 Redux 的使用 React Router 的使用 Taro 的使用 微信小程序开发 Node.js 知识总结 Nest 的使用 Spring Boot 的使用 唯二好用的连接池之 Druid 的使用 Flutter 的使用 Mybatis 的使用 Angular 的使用 唯二好用的连接池之 Druid 的使用 ","date":"2021-05-14","objectID":"/mind-map/:2:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"工具 如何使用 Hugo 进行个人博客搭建 Windows 下的软件包管理工具 Scoop Tomcat 的使用 Git 的使用 SSH 命令的使用 curl 的使用 Ranger 命令行下的文件管理器 Hammerspoon 的使用 neovim 的使用 MySQL 的使用 ","date":"2021-05-14","objectID":"/mind-map/:3:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"问题 POI 单元格数据过长问题 IE GET 方式请求数据缓存问题 sup 标签导致行距变大的问题 Hibernate 多线程下 No Session 问题 JAX 中 HTML 代码段被识别为字符串的问题 React 和直接修改 DOM 的前端框架的兼容性问题 Idea 意外终止，Web 服务未停止，导致的端口被占用问题解决 Spring 整合 Mybatis 时，Mybatis 的一级缓存为何“失效”? ","date":"2021-05-14","objectID":"/mind-map/:4:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"读书 《SQL 必知必会》 ","date":"2021-05-14","objectID":"/mind-map/:5:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"方法 如何学习使用新工具 如何记录一个问题 如何学习一门编程语言 如何学习一个框架 如何读一本书 如何科学上网 MySQL UPDATE 误操作后如何恢复数据 ","date":"2021-05-14","objectID":"/mind-map/:6:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"杂谈 WIN10 下终端解决方案 Mini Progarm 技术选型 什么是TCP/IP MacOS 下的终端 + Shell 选择 了解 HTTP 协议 了解 Restful 设计模式 ","date":"2021-05-14","objectID":"/mind-map/:7:0","tags":null,"title":"思维导图","uri":"/mind-map/"},{"categories":null,"content":"简介 Angular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用。 ","date":"2020-04-12","objectID":"/2020/04/angular/:1:0","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"基础 ","date":"2020-04-12","objectID":"/2020/04/angular/:2:0","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"模版语法 Angular 模板语法的五个常用特性： *ngFor *ngIf 插值 {{}} 属性绑定 [] 事件绑定 () \u003ch2\u003eProducts\u003c/h2\u003e \u003cdiv *ngFor=\"let product of products\"\u003e \u003ch3\u003e \u003ca [title]=\"product.name + ' details'\"\u003e {{ product.name }} \u003c/a\u003e \u003c/h3\u003e \u003cp *ngIf=\"product.description\"\u003e Description: {{ product.description }} \u003c/p\u003e \u003cbutton (click)=\"share()\"\u003e Share \u003c/button\u003e \u003c/div\u003e ","date":"2020-04-12","objectID":"/2020/04/angular/:2:1","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"组件 组件在用户界面（也就是 UI）中定义了一些责任区，让你能重用这些 UI 功能集。Angular 应用程序由一棵组件树组成，每个 Angular 组件都有一个明确的用途和责任。 组件包含三部分： 一个组件类，它用来处理数据和功能。上一节，我们在组件类中定义了商品数据和 share() 方法，它们分别用来处理数据和功能。 一个 HTML 模板，它决定了 UI。在上一节中，商品列表的 HTML 模板用来显示每个商品的名称、描述和 “Share” 按钮。 组件专属的样式定义了外观和感觉。商品列表中还没有定义任何样式，那属于组件 CSS 负责。 ","date":"2020-04-12","objectID":"/2020/04/angular/:2:2","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"输入和输出 import { Component, OnInit, Input, Output, EventEmitter } from \"@angular/core\"; @Component({ selector: \"app-product-alerts\", templateUrl: \"./product-alerts.component.html\", styleUrls: [\"./product-alerts.component.css\"] }) export class ProductAlertsComponent implements OnInit { // @Input() 装饰器指出其属性值是从该组件的父组件商品列表组件中传入的。 @Input() product; // 在组件类中，用 @Output() 装饰器和一个事件发射器 EventEmitter() 实例定义一个名为 notify 的属性。这可以让组件在 notify 属性发生变化时发出事件。 @Output() notify = new EventEmitter(); constructor() {} ngOnInit() {} } \u003cp *ngIf=\"product.price \u003e 700\"\u003e \u003c!-- 点击时触发自定义 notify 事件 --\u003e \u003cbutton (click)=\"notify.emit()\"\u003eNotify Me\u003c/button\u003e \u003c/p\u003e import { Component } from \"@angular/core\"; import { products } from \"../products\"; @Component({ selector: \"app-product-list\", templateUrl: \"./product-list.component.html\", styleUrls: [\"./product-list.component.css\"] }) export class ProductListComponent { products = products; share() { window.alert(\"The product has been shared!\"); } // 定义 onNotify 方法 onNotify() { window.alert(\"You will be notified when the product goes on sale\"); } } \u003ch2\u003eProducts\u003c/h2\u003e \u003cdiv *ngFor=\"let product of products\"\u003e \u003ch3\u003e \u003ca [title]=\"product.name + ' details'\"\u003e {{ product.name }} \u003c/a\u003e \u003c/h3\u003e \u003cp *ngIf=\"product.description\"\u003e Description: {{ product.description }} \u003c/p\u003e \u003cbutton (click)=\"share()\"\u003e Share \u003c/button\u003e \u003c!-- 只要像使用 HTML 元素一样使用它的选择器（ app-product-alert ）就可以了。 --\u003e \u003c!-- 通过属性绑定把当前商品作为输入传给组件。 --\u003e \u003c!-- 为 notify 事件绑定触发方法 --\u003e \u003capp-product-alerts [product]=\"product\" (notify)=\"onNotify()\"\u003e \u003c/app-product-alerts\u003e \u003c/div\u003e ","date":"2020-04-12","objectID":"/2020/04/angular/:2:3","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"注册路由 @NgModule({ imports: [ BrowserModule, ReactiveFormsModule, RouterModule.forRoot([ { path: '', component: ProductListComponent }, // 在 app.module.ts 中，添加一个商品详情路由，该路由的 path 是 products/:productId，component 是 ProductDetailsComponent。 { path: 'products/:productId', component: ProductDetailsComponent }, ]) ], \u003c!-- 修改 *ngFor 指令，在遍历列表的过程中把 products 数组中的每个索引赋值给 productId 变量 --\u003e \u003cdiv *ngFor=\"let product of products; index as productId\"\u003e \u003ch3\u003e \u003c!-- RouterLink 指令让路由器控制了一个链接元素。在这种情况下，路由或 URL 包含一个固定的区段（ /products ），但其最后一个区段是变量，要插入当前商品的 id 属性。 --\u003e \u003ca [title]=\"product.name + ' details'\" [routerLink]=\"['/products', productId]\"\u003e {{ product.name }} \u003c/a\u003e \u003c/h3\u003e \u003c!-- . . . --\u003e \u003c/div\u003e ","date":"2020-04-12","objectID":"/2020/04/angular/:2:4","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"使用路由信息 import { Component, OnInit } from \"@angular/core\"; // 包含与当前组件相关的路由信息。ActivatedRoute 也可用于遍历路由器的状态树。 import { ActivatedRoute } from \"@angular/router\"; import { products } from \"../products\"; @Component({ selector: \"app-product-details\", templateUrl: \"./product-details.component.html\", styleUrls: [\"./product-details.component.css\"] }) export class ProductDetailsComponent implements OnInit { product; // 将 ActivatedRoute 作为参数添加到构造函数的括号中，以便在上下文中使用 this.route。 constructor(private route: ActivatedRoute) {} ngOnInit() { // 订阅了路由参数，并且根据 productId 获取了该产品，在模版里使用 product 即可 this.route.paramMap.subscribe(params =\u003e { this.product = products[+params.get(\"productId\")]; }); } } ","date":"2020-04-12","objectID":"/2020/04/angular/:2:5","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"使用服务 服务是 Angular 应用的重要组成部分。在 Angular 中，服务是一个类的实例，它可以借助 Angular 的依赖注入系统来让应用中的任何一个部件都能使用它。服务可以让你在应用的各个部件之间共享数据。 import { Injectable } from '@angular/core'; // 定义购物车服务 export class CartService { items = []; addToCart(product) { this.items.push(product); } getItems() { return this.items; } clearCart() { this.items = []; return this.items; } } import { Component, OnInit } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; import { products } from '../products'; // 引入服务 import { CartService } from '../cart.service'; export class ProductDetailsComponent implements OnInit { // 通过构造方法注入服务 constructor( private route: ActivatedRoute, private cartService: CartService ) { } } ","date":"2020-04-12","objectID":"/2020/04/angular/:2:6","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"在 AppModule 中为应用启用 HttpClient 在使用 Angular 的 HTTP 客户端之前，你必须先配置你的应用来使用 HttpClientModule。Angular 的 HttpClientModule 中注册了在整个应用中使用 HttpClient 服务的单个实例所需的服务提供商。 打开 app.module.ts。 在该文件的顶部从 @angular/common/http 包中导入 HttpClientModule 以及其它导入项。 把 HttpClientModule 添加到 AppModule @NgModule() 的 imports 数组中，以便全局注册 Angular 的 HttpClient。 AppModule 已经导入了 HttpClientModule，接下来就是将 HttpClient 服务注入到你的服务中，以便此应用可以获取数据并与外部 API 和资源进行交互。 import { Injectable } from '@angular/core'; // 导入 HttpClient import { HttpClient } from '@angular/common/http'; export class CartService { items = []; // 注入 HttpClient constructor( private http: HttpClient ) {} getShippingPrices() { // 请求资源 return this.http.get('/assets/shipping.json'); } } export class ShippingComponent implements OnInit { shippingCosts; constructor( private cartService: CartService ) { } ngOnInit() { this.shippingCosts = this.cartService.getShippingPrices(); } } async 管道从数据流中返回最新值，并在所属组件的生命期内持续返回。当 Angular 销毁该组件时，async 管道会自动停止。有关 async 管道的详细信息，请参见 AsyncPipe API 文档。 \u003ch3\u003eShipping Prices\u003c/h3\u003e \u003cdiv class=\"shipping-item\" *ngFor=\"let shipping of shippingCosts | async\"\u003e \u003cspan\u003e{{ shipping.type }}\u003c/span\u003e \u003cspan\u003e{{ shipping.price | currency }}\u003c/span\u003e \u003c/div\u003e ","date":"2020-04-12","objectID":"/2020/04/angular/:2:7","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"表单 import { Component, OnInit } from '@angular/core'; // Angular 的 FormBuilder 服务为生成控件提供了方便的方法。 import { FormBuilder } from '@angular/forms'; import { CartService } from '../cart.service'; @Component({ selector: 'app-cart', templateUrl: './cart.component.html', styleUrls: ['./cart.component.css'] }) export class CartComponent implements OnInit { items; checkoutForm; // 注入服务 constructor( private cartService: CartService, private formBuilder: FormBuilder, ) { // 把 checkoutForm 属性设置为一个包含 name 和 address 字段的表单模型。使用 FormBuilder 的 group() 方法来创建它，把该语句加入构造函数的花括号 {} 中间。 this.checkoutForm = this.formBuilder.group({ name: '', address: '' }); } ngOnInit() { this.items = this.cartService.getItems(); } onSubmit(customerData) { // Process checkout data here console.warn('Your order has been submitted', customerData); this.items = this.cartService.clearCart(); // 清空表单 this.checkoutForm.reset(); } } 为 name 和 address 添加输入字段。使用 formControlName 属性绑定来把 checkoutForm 表单控件中的 name 和 address 绑定到它们的输入字段。 \u003ch3\u003eCart\u003c/h3\u003e \u003cp\u003e \u003ca routerLink=\"/shipping\"\u003eShipping Prices\u003c/a\u003e \u003c/p\u003e \u003cdiv class=\"cart-item\" *ngFor=\"let item of items\"\u003e \u003cspan\u003e{{ item.name }} \u003c/span\u003e \u003cspan\u003e{{ item.price | currency }}\u003c/span\u003e \u003c/div\u003e \u003cform [formGroup]=\"checkoutForm\" (ngSubmit)=\"onSubmit(checkoutForm.value)\"\u003e \u003cdiv\u003e \u003clabel for=\"name\"\u003e Name \u003c/label\u003e \u003cinput id=\"name\" type=\"text\" formControlName=\"name\"\u003e \u003c/div\u003e \u003cdiv\u003e \u003clabel for=\"address\"\u003e Address \u003c/label\u003e \u003cinput id=\"address\" type=\"text\" formControlName=\"address\"\u003e \u003c/div\u003e \u003cbutton class=\"button\" type=\"submit\"\u003ePurchase\u003c/button\u003e \u003c/form\u003e ","date":"2020-04-12","objectID":"/2020/04/angular/:2:8","tags":["框架"],"title":"Angular 的使用","uri":"/2020/04/angular/"},{"categories":null,"content":"简介 Mybatis 是一个数据持久层(ORM)框架。但是只完成了结果集到对象的映射，而 Hibernate 是数据表到对象的映射。 优点： 简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个 jar 文件+配置几个 sql 映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。 灵活：mybatis 不会对应用程序或者数据库的现有设计强加任何影响。 sql 写在 xml 里，便于统一管理和优化。通过 sql 基本上可以实现我们不使用数据访问框架可以实现的所有功能，或许更多。 解除 sql 与程序代码的耦合：通过提供 DAL 层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql 和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的 orm 字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供 xml 标签，支持编写动态 sql。 缺点： 编写 SQL 语句时工作量很大，尤其是字段多、关联表多时，更是如此。 SQL 语句依赖于数据库，导致数据库移植性差，不能更换数据库。 框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。 二级缓存机制不佳 ","date":"2020-04-04","objectID":"/2020/04/mybatis/:1:0","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"问题 ","date":"2020-04-04","objectID":"/2020/04/mybatis/:2:0","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"Spring 整合 Mybatis 时，Mybatis 的一级缓存为何“失效”? Spring 整合 Mybatis 时，只有在事务内部 Mybatis 的一级缓存才会生效这是为什么呢？首先我们要知道 Mybatis 的一级缓存生效的范围是 SqlSession。那么从结果来看应该是只有在事务的内部，查询方法才会使用同一 SqlSession，而没有事务的时候应该是创建了新的 SqlSssion，让我们看源码确认下。 // Spring 在使用 SqlSession 对其进行了动态代理，其方法调用的拦截器就是 SqlSessionTemplate 的内部类 SqlSessionInterceptor private class SqlSessionInterceptor implements InvocationHandler { private SqlSessionInterceptor() { } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 在执行方法时获取到 SqlSession SqlSession sqlSession = SqlSessionUtils.getSqlSession(SqlSessionTemplate.this.sqlSessionFactory, SqlSessionTemplate.this.executorType, SqlSessionTemplate.this.exceptionTranslator); Object unwrapped; try { Object result = method.invoke(sqlSession, args); if (!SqlSessionUtils.isSqlSessionTransactional(sqlSession, SqlSessionTemplate.this.sqlSessionFactory)) { sqlSession.commit(true); } unwrapped = result; } catch (Throwable var11) { unwrapped = ExceptionUtil.unwrapThrowable(var11); if (SqlSessionTemplate.this.exceptionTranslator != null \u0026\u0026 unwrapped instanceof PersistenceException) { SqlSessionUtils.closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); sqlSession = null; Throwable translated = SqlSessionTemplate.this.exceptionTranslator.translateExceptionIfPossible((PersistenceException)unwrapped); if (translated != null) { unwrapped = translated; } } throw (Throwable)unwrapped; } finally { if (sqlSession != null) { SqlSessionUtils.closeSqlSession(sqlSession, SqlSessionTemplate.this.sqlSessionFactory); } } return unwrapped; } } // 让我们再来看下 getSqlSession 方法 public static SqlSession getSqlSession(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator) { Assert.notNull(sessionFactory, \"No SqlSessionFactory specified\"); Assert.notNull(executorType, \"No ExecutorType specified\"); // 维护了一个 SqlSessionHolder 用来关联事务和 SqlSession SqlSessionHolder holder = (SqlSessionHolder)TransactionSynchronizationManager.getResource(sessionFactory); // 首先从 SqlSessionHolder 里取 SqlSession SqlSession session = sessionHolder(executorType, holder); if (session != null) { return session; } else { // 没有当前事务关联的 SqlSession 就直接创建一个新的返回 LOGGER.debug(() -\u003e { return \"Creating a new SqlSession\"; }); session = sessionFactory.openSession(executorType); registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session); return session; } } ","date":"2020-04-04","objectID":"/2020/04/mybatis/:2:1","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"应用场景 ","date":"2020-04-04","objectID":"/2020/04/mybatis/:3:0","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"Spring Boot 如何整合 Mybatis? # application.yml # 配置数据源 spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/learn_mybatis?characterEncoding=utf-8 driver-class-name: com.mysql.jdbc.Driver # 配置Mybatis mybatis: # 配置实体包的位置 type-aliases-package: com.orionpax.learn.mybatis.entity # Mapper 接口和 Mapper.xml 不在同一包下时，配置 Mapper.xml 的位置 mybatis.mapper-locations=classpath:mapper/*Mapper.xml configuration: # 配置开启懒加载 lazy-loading-enabled: true \u003c!-- Mapper 接口和 Mapper.xml 在同一包下时配置 --\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003efalse\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e @SpringBootApplication // 配置 Mapper 包的位置，如果不设置的话需要在每个 Mapper 接口上配置 @Mapper 注解。 @MapperScan(\"com.orionpax.learn.mybatis.mapper\") public class MybatisApplication { public static void main(String[] args) { SpringApplication.run(MybatisApplication.class, args); } } ","date":"2020-04-04","objectID":"/2020/04/mybatis/:3:1","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"通过 xml 文件使用 Mybatis 框架 简单的增删改查 package com.orionpax.learn.entity; import lombok.Data; import java.util.Date; import java.util.List; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class Bar { private Long id; private String name; private Date createTime; private List\u003cFar\u003e fars; } package com.orionpax.learn.entity; import lombok.Data; import java.util.Date; @Data @Builder @NoArgsConstructor @AllArgsConstructor public class Far { private Long id; private String name; private Date createTime; private Bar bar; } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" \u003e \u003cmapper namespace=\"com.orionpax.learn.mybatis.mapper.BarMapper\"\u003e # 定义一个代码片段，可以在其他地方使用 include 标签引用 \u003csql id=\"Bar_Column_List\"\u003e id, name, create_time \u003c/sql\u003e # 插入 # id 为 sql 语句取个名称，需要和对应的 Mapper接口里的方法名保持一致 # parameterType 指定参数类型，如果是类就写全类名，并使用 #{} 来取值，如果是简单对象的话，#{中间的参数名可以随便写} \u003cinsert id=\"insert\" parameterType=\"com.orionpax.learn.mybatis.entity.Bar\"\u003e insert into bar (name, create_time) values (#{name}, #{createTime}) \u003c/insert\u003e # 删除 \u003cdelete id=\"deleteById\" parameterType=\"java.lang.Long\"\u003e delete from bar where id = #{id} \u003c/delete\u003e # 修改 \u003cupdate id=\"updateById\" parameterType=\"com.orionpax.learn.mybatis.entity.Bar\"\u003e update bar set name = #{name}, create_time = #{createTime} where id = #{id} \u003c/update\u003e # 查询 # resultType 指定返回类型，如果是类同样是全类名 \u003cselect id=\"selectById\" resultType=\"com.orionpax.learn.mybatis.entity.Bar\" parameterType=\"java.lang.Long\"\u003e select \u003cinclude refid=\"Bar_Column_List\"/\u003e from bar where id = #{id} \u003c/select\u003e # 查询列表，当查询返回多行时，返回类型是 List\u003cT\u003e 中的 T \u003cselect id=\"selectAll\" resultType=\"com.orionpax.learn.mybatis.entity.Bar\"\u003e select \u003cinclude refid=\"Bar_Column_List\"/\u003e from bar \u003c/select\u003e \u003c/mapper\u003e 集联查询 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" \u003e \u003cmapper namespace=\"com.orionpax.learn.mybatis.mapper.BarMapper\"\u003e # 使用resultMap 映射返回结果 \u003cresultMap id=\"BaseResultMap\" type=\"com.orionpax.learn.mybatis.entity.Bar\"\u003e # 主键映射 # column 指定返回字段名 # property 执行实体属性名 \u003cid column=\"id\" property=\"id\"/\u003e # 其他参数映射 \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"create_time\" property=\"createTime\"/\u003e \u003c/resultMap\u003e # 可以使用 extends 继承其他 resultMap 配置的映射 \u003cresultMap id=\"BarResultMap\" type=\"com.orionpax.learn.mybatis.entity.Bar\" extends=\"BaseResultMap\"\u003e # collection 将结果映射为集合 # property 指定要映射到的实体属性名 # ofType 指定 List\u003cT\u003e 的 T \u003ccollection property=\"fars\" ofType=\"com.orionpax.learn.mybatis.entity.Far\"\u003e \u003cid column=\"far_id\" property=\"id\"/\u003e \u003cresult column=\"far_name\" property=\"name\"/\u003e \u003cresult column=\"far_create_time\" property=\"createTime\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e # 复杂的返回值使用 resultMap 代替 resultType \u003cselect id=\"selectById\" parameterType=\"java.lang.Long\" resultMap=\"BarResultMap\"\u003e select b.id, b.name, b.create_time, f.id as far_id, f.name as far_name, f.create_time as far_create_time from bar b, far f where b.id = f.bar_id and b.id = #{id} \u003c/select\u003e \u003cselect id=\"selectAll\" resultMap=\"BarResultMap\"\u003e select b.id, b.name, b.create_time, f.id as far_id, f.name as far_name, f.create_time as far_create_time from bar b left join far f on b.id = f.bar_id \u003c/select\u003e \u003c/mapper\u003e \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.orionpax.learn.mybatis.mapper.FarMapper\"\u003e \u003cresultMap id=\"BaseResultMap\" type=\"com.orionpax.learn.mybatis.entity.Far\"\u003e \u003cid column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"create_time\" property=\"createTime\"/\u003e \u003c/resultMap\u003e \u003cresultMap id=\"FarResultMap\" type=\"com.orionpax.learn.mybatis.entity.Far\" extends=\"BaseResultMap\"\u003e # 使用 association 映射非集合的复杂属性 # javaType 指定属性类型，可以省略 \u003cassociation property=\"bar\" javaType=\"com.orionpax.learn.mybatis.entity.Bar\"\u003e \u003cid column=\"bar_id\" property=\"id\"/\u003e \u003cresult column=\"bar_name\" property=\"name\"/\u003e \u003cresult column=\"bar_create_ti","date":"2020-04-04","objectID":"/2020/04/mybatis/:3:2","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"如何使用逆向工程？ 使用 Mybatis Generator 配置如下，实际更复杂的逆向工程的需求可以自己实现。 pom.xml 添加插件 \u003cplugin\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003cconfiguration\u003e \u003c!--允许移动生成的文件 --\u003e \u003cverbose\u003etrue\u003c/verbose\u003e \u003c!-- 是否覆盖 --\u003e \u003coverwrite\u003etrue\u003c/overwrite\u003e \u003cconfigurationFile\u003e${project.basedir}/generatorConfig.xml\u003c/configurationFile\u003e \u003c/configuration\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e8.0.19\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.generator\u003c/groupId\u003e \u003cartifactId\u003emybatis-generator-core\u003c/artifactId\u003e \u003cversion\u003e1.3.2\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/plugin\u003e 设置插件配置文件 generatorConfig.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"\u003e \u003cgeneratorConfiguration\u003e \u003ccontext id=\"testTables\" targetRuntime=\"MyBatis3\"\u003e \u003ccommentGenerator\u003e \u003c!-- 是否去除自动生成的注释 true：是 ： false:否 --\u003e \u003cproperty name=\"suppressAllComments\" value=\"true\"/\u003e \u003c/commentGenerator\u003e \u003c!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\u003e \u003cjdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/learn_mybatis?characterEncoding=utf-8\" userId=\"root\" password=\"root\"\u003e \u003c/jdbcConnection\u003e \u003c!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 NUMERIC 类型解析为java.math.BigDecimal --\u003e \u003cjavaTypeResolver\u003e \u003cproperty name=\"forceBigDecimals\" value=\"false\"/\u003e \u003c/javaTypeResolver\u003e \u003c!-- targetProject:生成POJO类的位置 --\u003e \u003cjavaModelGenerator targetPackage=\"com.orionpax.learn.entity\" targetProject=\"src/main/java\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e \u003c!-- 从数据库返回的值被清理前后的空格 --\u003e \u003cproperty name=\"trimStrings\" value=\"true\"/\u003e \u003c/javaModelGenerator\u003e \u003c!-- targetProject:mapper映射文件生成的位置 如果maven工程只是单独的一个工程，targetProject=\"src/main/java\" 若果maven工程是分模块的工程，targetProject=\"所属模块的名称\"，例如： targetProject=\"ecps-manager-mapper\"，下同--\u003e \u003csqlMapGenerator targetPackage=\"com.orionpax.learn.mapper\" targetProject=\"src/main/java\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e \u003c/sqlMapGenerator\u003e \u003c!-- targetPackage：mapper接口生成的位置 --\u003e \u003cjavaClientGenerator type=\"XMLMAPPER\" targetPackage=\"com.orionpax.learn.mapper\" targetProject=\"src/main/java\"\u003e \u003c!-- enableSubPackages:是否让schema作为包的后缀 --\u003e \u003cproperty name=\"enableSubPackages\" value=\"false\"/\u003e \u003c/javaClientGenerator\u003e \u003c!-- 指定数据库表 多个表示,可用多个table标签--\u003e \u003ctable tableName=\"far\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"\u003e \u003c/table\u003e \u003ctable tableName=\"bar\" enableCountByExample=\"false\" enableUpdateByExample=\"false\" enableDeleteByExample=\"false\" enableSelectByExample=\"false\" selectByExampleQueryId=\"false\"\u003e \u003c/table\u003e \u003c/context\u003e \u003c/generatorConfiguration\u003e 运行插件 ","date":"2020-04-04","objectID":"/2020/04/mybatis/:3:3","tags":null,"title":"Mybatis 的使用","uri":"/2020/04/mybatis/"},{"categories":null,"content":"基础 ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:0","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"Dart 什么是 Dart ? 因为 JavaScript 的种种问题，Dart 最初是 Google 设计用来代替 JavaScript 的语言。但是 JavaScript 因为 Node.js 成为了前后端同吃的全栈语言，前端的开发模式也因此改变，Dart 取代 JavaScript 也成为了泡影。出现转机的地方是 Google 内部孵化了跨平台移动端开发框架 Flutter，Dart 成为了其开发语言，与其进行了捆绑。目前来看 Dart 语言的生命力主要依靠于 Flutter 的生命力。而因为 React Native 的种种问题，Flutter 有了后来居上的趋势，如果你是一名移动端开发者，Dart 语言和 Flutter 框架确实值得一学。 变量类型定义 在 Dart 中，我们可以用 var 或者具体的类型来声明一个变量。当使用 var 定义变量时，表示类型是交由编译器推断决定的，当然你也可以用静态类型去定义变量，更清楚地跟编译器表达你的意图，这样编辑器和编译器就能使用这些静态类型，向你提供代码补全或编译警告的提示了。 在默认情况下，未初始化的变量的值都是 null，因此我们不用担心无法判定一个传递过来的、未定义变量到底是 undefined，还是烫烫烫而写一堆冗长的判断语句了。 Dart 是类型安全的语言，并且所有类型都是对象类型，都继承自顶层类型 Object，因此一切变量的值都是类的实例（即对象），甚至数字、布尔值、函数和 null 也都是继承自 Object 的对象。 Dart 内置了一些基本类型，如 num、bool、String、List 和 Map，在不引入其他库的情况下可以使用它们去声明变量。 num、bool 与 String Dart 的数值类型 num，只有两种子类：即 64 位 int 和符合 IEEE 754 标准的 64 位 double。除了常见的基本运算符，比如 +、-、*、/，以及位运算符外，你还能使用继承自 num 的 abs()、round() 等方法，来实现求绝对值、取整的功能。 为了表示布尔值，Dart 使用了一种名为 bool 的类型。在 Dart 里，只有两个对象具有 bool 类型：true 和 false，它们都是编译时常量。Dart 是类型安全的，因此我们不能使用 if(nonbooleanValue) 或 assert(nonbooleanValue) 之类的在 JavaScript 可以正常工作的代码，而应该显式地检查值。 Dart 的 String 由 UTF-16 的字符串组成。和 JavaScript 一样，构造字符串字面量时既能使用单引号也能使用双引号，还能在字符串中嵌入变量或表达式：你可以使用 ${express} 把一个表达式的值放进字符串。而如果是一个标识符，你可以省略{}。对于多行字符串的构建，你可以通过三个单引号或三个双引号的方式声明。 List 与 Map 其他编程语言中常见的数组和字典类型，在 Dart 中的对应实现是 List 和 Map，统称为集合类型。和 Java 语言类似，在初始化集合实例对象时，你可以为它的类型添加约束，也可以用于后续判断集合类型。 List arr1 = \u003cString\u003e['Tom', 'Andy', 'Jack']; List arr2 = new List\u003cint\u003e.of([1,2,3]); arr2.add(499); arr2.forEach((v) =\u003e print('${v}')); print(arr2 is List\u003cint\u003e); // true Map map1 = \u003cString, String\u003e{'name': 'Tom','sex': 'male',}; Map map2 = new Map\u003cString, String\u003e(); map2['name'] = 'Tom'; map2['sex'] = 'male'; map2.forEach((k,v) =\u003e print('${k}: ${v}')); print(map2 is Map\u003cString, String\u003e); // true 常量定义 如果你想定义不可变的变量，则需要在定义变量前加上 final 或 const 关键字。 const，表示变量在编译期间即能确定的值。 final 定义的变量可以在运行时确定值，而一旦确定后就不可再变。 函数 在 Dart 中，所有类型都是对象类型，函数也是对象，它的类型叫作 Function。这意味着函数也可以被定义为变量，甚至可以被定义为参数传递给另一个函数。 如果函数体只有一行表达式，我们还可以像 JavaScript 语言那样用箭头函数来简化这个函数。 bool isZero(int number) { //判断整数是否为0 return number == 0; } bool isZero(int number) =\u003e number == 0; 有时，一个函数中可能需要传递多个参数。那么，如何让这类函数的参数声明变得更加优雅、可维护，同时降低调用者的使用成本呢？C++ 与 Java 的做法是，提供函数的重载，即提供同名但参数不同的函数。但 Dart 认为重载会导致混乱，因此从设计之初就不支持重载，而是提供了可选命名参数和可选参数。在使用这两种方式定义函数时，我们还可以在参数未传递时设置默认值。具体方式是，在声明函数时： //要达到可选命名参数的用法，那就在定义函数的时候给参数加上 {} void enable1Flags({bool bold, bool hidden}) =\u003e print(\"$bold , $hidden\"); //定义可选命名参数时增加默认值 void enable2Flags({bool bold = true, bool hidden = false}) =\u003e print(\"$bold ,$hidden\"); //可忽略的参数在函数定义时用[]符号指定 void enable3Flags(bool bold, [bool hidden]) =\u003e print(\"$bold ,$hidden\"); //定义可忽略参数时增加默认值 void enable4Flags(bool bold, [bool hidden = false]) =\u003e print(\"$bold ,$hidden\"); //可选命名参数函数调用 enable1Flags(bold: true, hidden: false); //true, false enable1Flags(bold: true); //true, null enable2Flags(bold: false); //false, false //可忽略参数函数调用 enable3Flags(true, false); //true, false enable3Flags(true); //true, null enable4Flags(true); //true, false enable4Flags(true,true); // true, true 类 类的定义及初始化 Dart 是面向对象的语言，每个对象都是一个类的实例，都继承自顶层类型 Object。在 Dart 中，实例变量与实例方法、类变量与类方法的声明与 Java 类似。 值得一提的是，Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上_即可作为 private 方法使用。如果不加_，则默认为 public。不过，的限制范围并不是类访问级别的，而是库访问级别。 有时候类的实例化需要根据参数提供多种初始化方式。除了可选命名参数和可选参数之外，Dart 还提供了命名构造函数的方式，使得类的实例化过程语义更清晰。 此外，与 C++ 类似，Dart 支持初始化列表。在构造函数的函数体真正执行之前，你还有机会给实例变量赋值，甚至重定向至另一个构造函数。 class Point { num x, y, z; //语法糖，等同于在函数体内：this.x = x;this.y = y; Point(this.x, this.y) : z = 0; // 初始化变量z Point.bottom(num x) : this(x, 0); // 重定向构造函数 void printInfo() =\u003e print('($x,$y,$z)'); } var p = Point.bottom(100); p.printInfo(); // 输出(100,0,0) 复用 在面向对象的编程语言中，将其他类的变量与方法纳入本类中进行复用的方式一般有两种：继承父类和接口实现。在 Dart 中： 继承父类意味着，子类由父类派生，会自动获取父类的成员变量和方法实现，子类可以根据需要覆写构造函数及父类方法。 接口实现则意味着，子类获取到的仅仅是接口的成员变量符号和方法符号，需要重新实现成员变量，以及方法的声明和初始化，否则编译器会报错。 class Point { num x = 0, y = 0; void printInfo() =\u003e print('($x,$y)'); } //Vector继承自Point class Vector extends Point{ num z = 0; @override void printInfo() =\u003e print('($x,$y,$z)'); //覆写了printInfo实现 } //Coordinate是对Poi","date":"2020-03-21","objectID":"/2020/03/flutter/:1:1","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"State 的生命周期 initState : 在 State 被插入视图树时被调用，用来进行渲染相关的初始化工作 didChangeDependencies : initState 后及 State 对象依赖关系变化时被调用，用来处理 State 对象的依赖关系变化 build : State 准备好数据需要进行渲染时被调用，用来进行视图的构建 didUpdateWidget : 父 Widget setState 触发子 Widget 重建时被调用 deactivate : 组件不可视时被调用 dispose : 组件被销毁时调用 ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:2","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"常用基础控件 Text Text 支持两种类型的文本展示，一个是默认的展示单一样式的文本 Text，另一个是支持多种混合样式的富文本 Text.rich。 Text( 'Hello, $_name! How are you?', textAlign: TextAlign.center, overflow: TextOverflow.ellipsis, style: TextStyle(fontWeight: FontWeight.bold), ) const Text.rich( TextSpan( text: 'Hello', // default text style children: \u003cTextSpan\u003e[ TextSpan(text: ' beautiful ', style: TextStyle(fontStyle: FontStyle.italic)), TextSpan(text: 'world', style: TextStyle(fontWeight: FontWeight.bold)), ], ), ) Image 加载本地资源图片，如 Image.asset(‘images/logo.png’); 加载本地（File 文件）图片，如 Image.file(new File(’/storage/xxx/xxx/test.jpg’)); 加载网络图片，如 Image.network('http://xxx/xxx/test.gif'); FadeInImage 在加载网络图片的时候，为了提升用户的等待体验，我们往往会加入占位图、加载动画等元素，但是默认的 Image.network 构造方法并不支持这些高级功能，这时候 FadeInImage 控件就派上用场了。 FadeInImage.assetNetwork( placeholder: 'assets/loading.gif', //gif占位 image: 'https://xxx/xxx/xxx.jpg', fit: BoxFit.cover, //图片拉伸模式 width: 200, height: 200, ) FloatingActionButton 一个圆形的按钮，一般出现在屏幕内容的前面，用来处理界面中最常用、最基础的用户动作。 RaisedButton 凸起的按钮，默认带有灰色背景，被点击后灰色背景会加深。 FlatButton 扁平化的按钮，默认透明背景，被点击后会呈现灰色背景。 ListView ListView 可以沿一个方向（垂直或水平方向）来排列其所有子 Widget，因此常被用于需要展示一组连续视图元素的场景，比如通信录、优惠券、商家列表等。 // 默认构造函数，适用于列表中含有少量不变元素时使用 ListView( children: \u003cWidget\u003e[ //设置ListTile组件的标题与图标 ListTile(leading: Icon(Icons.map), title: Text('Map')), ListTile(leading: Icon(Icons.mail), title: Text('Mail')), ListTile(leading: Icon(Icons.message), title: Text('Message')), ]); // 构造函数 ListView.builder，则适用于子 Widget 比较多的场景 // itemBuilder，是列表项的创建方法。当列表滚动到相应位置时，ListView 会调用该方法创建对应的子 Widget。 // itemCount，表示列表项的数量，如果为空，则表示 ListView 为无限列表。 // itemExtent 并不是一个必填参数。但，对于定高的列表项元素，我强烈建议你提前设置好这个参数的值。但如果提前设置好 itemExtent，ListView 则可以提前计算好每一个列表项元素的相对位置，以及自身的视图高度，省去了无谓的计算。 ListView.builder( itemCount: 100, //元素个数 itemExtent: 50.0, //列表项高度 itemBuilder: (BuildContext context, int index) =\u003e ListTile(title: Text(\"title $index\"), subtitle: Text(\"body $index\")) ); // ListView.separated 抽离出了分割线的创建方法 separatorBuilder，以便根据 index 设置不同样式的分割线。 ListView.separated( itemCount: 100, //index为偶数，创建绿色分割线；index为奇数，则创建红色分割线 separatorBuilder: (BuildContext context, int index) =\u003e index %2 ==0? Divider(color: Colors.green) : Divider(color: Colors.red), //创建子Widget itemBuilder: (BuildContext context, int index) =\u003e ListTile(title: Text(\"title $index\"), subtitle: Text(\"body $index\")) ) ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:3","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"布局 Flutter 提供了 31 种布局 Widget，对布局控件的划分非常详细，一些相同（或相似）的视觉效果可以通过多种布局控件实现，因此布局类型相比原生 Android、iOS 平台多了不少。 单子 Widget 布局：Container、Padding 与 Center Container 内部提供了间距、背景样式等基础属性，为子 Widget 的摆放方式，及展现样式都提供了定制能力。而 Padding 与 Center 提供的功能，则正如其名一样简洁，就是对齐与居中。 Container( child: Text('Container（容器）在UI框架中是一个很常见的概念，Flutter也不例外。'), padding: EdgeInsets.all(18.0), // 内边距 margin: EdgeInsets.all(44.0), // 外边距 width: 180.0, height:240, alignment: Alignment.center, // 子Widget居中对齐 decoration: BoxDecoration( //Container样式 color: Colors.red, // 背景色 borderRadius: BorderRadius.circular(10.0), // 圆角边框 ), ) Padding( padding: EdgeInsets.all(44.0), child: Text('Container（容器）在UI框架中是一个很常见的概念，Flutter也不例外。'), ); Scaffold( body: Center(child: Text(\"Hello\")) // This trailing comma makes auto-formatting nicer for build methods. ); 多子 Widget 布局：Row、Column 与 Expanded Row 和 Column，提供了各子 Widget 间对齐的规则，以及容器自身扩充的规则，Expanded 控件可以使用容器内部的剩余空间。 //Row的用法示范 Row( children: \u003cWidget\u003e[ Container(color: Colors.yellow, width: 60, height: 80,), Container(color: Colors.red, width: 100, height: 180,), Container(color: Colors.black, width: 60, height: 80,), Container(color: Colors.green, width: 60, height: 80,), ], ); //Column的用法示范 Column( children: \u003cWidget\u003e[ Container(color: Colors.yellow, width: 60, height: 80,), Container(color: Colors.red, width: 100, height: 180,), Container(color: Colors.black, width: 60, height: 80,), Container(color: Colors.green, width: 60, height: 80,), ], ); // 使用 Expanded 填充剩余空间 Row( children: \u003cWidget\u003e[ Expanded(flex: 1, child: Container(color: Colors.yellow, height: 60)), //设置了flex=1，因此宽度由Expanded来分配 Container(color: Colors.red, width: 100, height: 180,), Container(color: Colors.black, width: 60, height: 80,), Expanded(flex: 1, child: Container(color: Colors.green,height: 60),)/设置了flex=1，因此宽度由Expanded来分配 ], ); 我们可以根据主轴与纵轴，设置子 Widget 在这两个方向上的对齐规则 mainAxisAlignment 与 crossAxisAlignment。比如，主轴方向 start 表示靠左对齐、center 表示横向居中对齐、end 表示靠右对齐、spaceEvenly 表示按固定间距对齐；而纵轴方向 start 则表示靠上对齐、center 表示纵向居中对齐、end 表示靠下对齐。 下图展示了在 Row 中设置不同方向的对齐规则后的呈现效果： 层叠 Widget 布局：Stack 与 Positioned Stack 提供了层叠布局的容器，而 Positioned 则提供了设置子 Widget 位置的能力。 Stack( children: \u003cWidget\u003e[ Container(color: Colors.yellow, width: 300, height: 300),//黄色容器 Positioned( left: 18.0, top: 18.0, child: Container(color: Colors.green, width: 50, height: 50),//叠加在黄色容器之上的绿色控件 ), Positioned( left: 18.0, top:70.0, child: Text(\"Stack提供了层叠布局的容器\"),//叠加在黄色容器之上的文本 ) ], ) ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:4","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"资源引用 在移动开发中，常见的资源类型包括 JSON 文件、配置文件、图标、图片以及字体文件等。它们都会被打包到 App 安装包中，而 App 中的代码可以在运行时访问这些资源。 关于资源的存放位置，Flutter 并没有像 Android 那样预先定义资源的目录结构，所以我们可以把资源存放在项目中的任意目录下，只需要使用根目录下的 pubspec.yaml 文件，对这些资源的所在位置进行显式声明就可以了，以帮助 Flutter 识别出这些资源。 而在指定路径名的过程中，我们既可以对每一个文件进行挨个指定，也可以采用子目录批量指定的方式。需要注意的是，目录批量指定并不递归，只有在该目录下的文件才可以被包括，如果下面还有子目录的话，需要单独声明子目录下的文件。 assets ├── background.jpg ├── icons │ └── food_icon.jpg ├── loading.gif └── result.json # pubspec.yaml flutter: assets: - assets/background.jpg #挨个指定资源路径 - assets/loading.gif #挨个指定资源路径 - assets/result.json #挨个指定资源路径 - assets/icons/ #子目录批量指定 - assets/ #根目录也是可以批量指定的 对于图片类资源的访问，我们可以使用 Image.asset 构造方法完成图片资源的加载及显示。 Image.asset('assets/background.jpg'); 而对于其他资源文件的加载，我们可以通过 Flutter 应用的主资源 Bundle 对象 rootBundle，来直接访问。对于字符串文件资源，我们使用 loadString 方法；而对于二进制文件资源，则通过 load 方法。 rootBundle.loadString('assets/result.json').then((msg)=\u003eprint(msg)); ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:5","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"第三方包依赖 引用第三方包，需要在其 Pub 上进行公开发布，我们可以访问 https://pub.dev/ 来获取可用的第三方包。Pub 就类似于 Node.js 的 NPM。 ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:6","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"用户交互事件 指针事件 指针事件表示用户交互的原始触摸数据，如手指接触屏幕 PointerDownEvent、手指在屏幕上移动 PointerMoveEvent、手指抬起 PointerUpEvent，以及触摸取消 PointerCancelEvent，这与原生系统的底层触摸事件抽象是一致的。 关于组件层面的原始指针事件的监听，Flutter 提供了 Listener Widget，可以监听其子 Widget 的原始指针事件。 Listener( child: Container( color: Colors.red,//背景色红色 width: 300, height: 300, ), onPointerDown: (event) =\u003e print(\"down $event\"),//手势按下回调 onPointerMove: (event) =\u003e print(\"move $event\"),//手势移动回调 onPointerUp: (event) =\u003e print(\"up $event\"),//手势抬起回调 ); 手势识别 使用 Listener 可以直接监听指针事件。不过指针事件毕竟太原始了，如果我们想要获取更多的触摸事件细节，比如判断用户是否正在拖拽控件，直接使用指针事件的话就会非常复杂。 通常情况下，响应用户交互行为的话，我们会使用封装了手势语义操作的 Gesture，如点击 onTap、双击 onDoubleTap、长按 onLongPress、拖拽 onPanUpdate、缩放 onScaleUpdate 等。另外，Gesture 可以支持同时分发多个手势交互行为，意味着我们可以通过 Gesture 同时监听多个事件。 Gesture 是手势语义的抽象，而如果我们想从组件层监听手势，则需要使用 GestureDetector。GestureDetector 是一个处理各种高级用户触摸行为的 Widget，与 Listener 一样，也是一个功能性组件。 //红色container坐标 double _top = 0.0; double _left = 0.0; Stack(//使用Stack组件去叠加视图，便于直接控制视图坐标 children: \u003cWidget\u003e[ Positioned( top: _top, left: _left, child: GestureDetector(//手势识别 child: Container(color: Colors.red,width: 50,height: 50),//红色子视图 onTap: ()=\u003eprint(\"Tap\"),//点击回调 onDoubleTap: ()=\u003eprint(\"Double Tap\"),//双击回调 onLongPress: ()=\u003eprint(\"Long Press\"),//长按回调 onPanUpdate: (e) {//拖动回调 setState(() { //更新位置 _left += e.delta.dx; _top += e.delta.dy; }); }, ), ) ], ); ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:7","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"组件间数据传递 在 Flutter 中实现跨组件数据传递的标准方式是通过属性传值。但是，对于稍微复杂一点的、尤其视图层级比较深的 UI 样式，一个属性可能需要跨越很多层才能传递给子组件，这种传递方式就会导致中间很多并不需要这个属性的组件也需要接收其子 Widget 的数据，不仅繁琐而且冗余。 所以，对于数据的跨层传递，Flutter 还提供了三种方案：InheritedWidget、Notification 和 EventBus。 InheritedWidget InheritedWidget 是 Flutter 中的一个功能型 Widget，适用于在 Widget 树中共享数据的场景。通过它，我们可以高效地将数据在 Widget 树中进行跨层传递。 class CountContainer extends InheritedWidget { //方便其子Widget在Widget树中找到它 static CountContainer of(BuildContext context) =\u003e context.inheritFromWidgetOfExactType(CountContainer) as CountContainer; final _MyHomePageState model;//直接使用MyHomePage中的State获取数据 final Function() increment; CountContainer({ Key key, @required this.model, @required this.increment, @required Widget child, }): super(key: key, child: child); } class _MyHomePageState extends State\u003cMyHomePage\u003e { int count = 0; void _incrementCounter() =\u003e setState(() {count++;});//修改计数器 @override Widget build(BuildContext context) { return CountContainer( model: this,//将自身作为model交给CountContainer increment: _incrementCounter,//提供修改数据的方法 child:Counter() ); } } class Counter extends StatelessWidget { @override Widget build(BuildContext context) { //获取InheritedWidget节点 CountContainer state = CountContainer.of(context); return Scaffold( ... body: Text( 'You have pushed the button this many times: ${state.model.count}', //关联数据读方法 ), floatingActionButton: FloatingActionButton(onPressed: state.increment), //关联数据修改方法 ); } } Notification Notification 是 Flutter 中进行跨层数据共享的另一个重要的机制。如果说 InheritedWidget 的数据流动方式是从父 Widget 到子 Widget 逐层传递，那 Notificaiton 则恰恰相反，数据流动方式是从子 Widget 向上传递至父 Widget。这样的数据传递机制适用于子 Widget 状态变更，发送通知上报的场景。 自定义通知的监听与 ScrollNotification 并无不同，而如果想要实现自定义通知，我们首先需要继承 Notification 类。Notification 类提供了 dispatch 方法，可以让我们沿着 context 对应的 Element 节点树向上逐层发送通知。 class CustomNotification extends Notification { CustomNotification(this.msg); final String msg; } //抽离出一个子Widget用来发通知 class CustomChild extends StatelessWidget { @override Widget build(BuildContext context) { return RaisedButton( //按钮点击时分发通知 onPressed: () =\u003e CustomNotification(\"Hi\").dispatch(context), child: Text(\"Fire Notification\"), ); } } class _MyHomePageState extends State\u003cMyHomePage\u003e { String _msg = \"通知：\"; @override Widget build(BuildContext context) { //监听通知 return NotificationListener\u003cCustomNotification\u003e( onNotification: (notification) { setState(() {_msg += notification.msg+\" \";});//收到子Widget通知，更新msg }, child:Column( mainAxisAlignment: MainAxisAlignment.center, children: \u003cWidget\u003e[Text(_msg),CustomChild()],//将子Widget加入到视图树中 ) ); } } EventBus 无论是 InheritedWidget 还是 Notificaiton，它们的使用场景都需要依靠 Widget 树，也就意味着只能在有父子关系的 Widget 之间进行数据共享。但是，组件间数据传递还有一种常见场景：这些组件间不存在父子关系。这时，EventBus 就登场了。 事件总线是在 Flutter 中实现跨组件通信的机制。它遵循发布 / 订阅模式，允许订阅者订阅事件，当发布者触发事件时，订阅者和发布者之间可以通过事件进行交互。发布者和订阅者之间无需有父子关系，甚至非 Widget 对象也可以发布 / 订阅。这些特点与其他平台的事件总线机制是类似的。 需要注意的是，EventBus 是一个第三方插件，因此我们需要在 pubspec.yaml 文件中声明它： dependencies: event_bus: 1.1.0 // EventBus 的使用方式灵活，可以支持任意对象的传递。定义一个有字符串属性的自定义事件类 CustomEvent class CustomEvent { String msg; CustomEvent(this.msg); } //建立公共的event bus EventBus eventBus = new EventBus(); //第一个页面 class _FirstScreenState extends State\u003cFirstScreen\u003e { String msg = \"通知：\"; StreamSubscription subscription; @override initState() { //监听CustomEvent事件，刷新UI subscription = eventBus.on\u003cCustomEvent\u003e().listen((event) { setState(() {msg+= event.msg;});//更新msg }); super.initState(); } dispose() { subscription.cancel();//State销毁时，清理注册 super.dispose(); } @override Widget build(BuildContext context) { return new Scaffold( body:Text(msg), ... ); } } class SecondScreen extends StatelessWidget { @override Widget build(BuildContext context) { return new Scaffold( ... body: RaisedButton( child: Text('Fire Event'), // 触发CustomEvent事件 onPressed: ()=\u003e eventBus.fire(CustomEvent(\"hello\")) ), ); } } ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:8","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"路由 在 Flutter 中，页面之间的跳转是通过 Route 和 Navigator 来管理的： Route 是页面的抽象，主要负责创建对应的界面，接收参数，响应 Navigator 打开和关闭 而 Navigator 则会维护一个路由栈管理 Route，Route 打开即入栈，Route 关闭即出栈，还可以直接替换栈内的某一个 Route 而根据是否需要提前注册页面标识符，Flutter 中的路由管理可以分为两种方式： 基本路由。无需提前注册，在页面切换时需要自己构造页面实例 命名路由。需要提前注册页面标识符，在页面切换时通过标识符直接打开新的路由 基本路由 在 Flutter 中，基本路由的使用方法和 Android/iOS 打开新页面的方式非常相似。要导航到一个新的页面，我们需要创建一个 MaterialPageRoute 的实例，调用 Navigator.push 方法将新页面压到堆栈的顶部。 其中，MaterialPageRoute 是一种路由模板，定义了路由创建及切换过渡动画的相关配置，可以针对不同平台，实现与平台页面切换动画风格一致的路由切换动画。 而如果我们想返回上一个页面，则需要调用 Navigator.pop 方法从堆栈中删除这个页面。 class FirstScreen extends StatelessWidget { @override Widget build(BuildContext context) { return RaisedButton( //打开页面 onPressed: ()=\u003e Navigator.push(context, MaterialPageRoute(builder: (context) =\u003e SecondScreen())); ); } } class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { return RaisedButton( // 回退页面 onPressed: ()=\u003e Navigator.pop(context) ); } } 命名路由 要想通过名字来指定页面切换，我们必须先给应用程序 MaterialApp 提供一个页面名称映射规则，即路由表 routes，这样 Flutter 才知道名字与页面 Widget 的对应关系。 路由表实际上是一个 Map，其中 key 值对应页面名字，而 value 值则是一个 WidgetBuilder 回调函数，我们需要在这个函数中创建对应的页面。而一旦在路由表中定义好了页面名字，我们就可以使用 Navigator.pushNamed 来打开页面了。 MaterialApp( ... //注册路由 routes:{ \"second_page\":(context)=\u003eSecondPage(), }, ); //使用名字打开页面 Navigator.pushNamed(context,\"second_page\"); 不过由于路由的注册和使用都采用字符串来标识，这就会带来一个隐患：如果我们打开了一个不存在的路由会怎么办？在注册路由表时，Flutter 提供了 UnknownRoute 属性，我们可以对未知的路由标识符进行统一的页面跳转处理。 MaterialApp( ... //注册路由 routes:{ \"second_page\":(context)=\u003eSecondPage(), }, //错误路由处理，统一返回UnknownPage onUnknownRoute: (RouteSettings setting) =\u003e MaterialPageRoute(builder: (context) =\u003e UnknownPage()), ); //使用错误名字打开页面 Navigator.pushNamed(context,\"unknown_page\"); 页面参数 与基本路由能够精确地控制目标页面初始化方式不同，命名路由只能通过字符串名字来初始化固定目标页面。为了解决不同场景下目标页面的初始化需求，Flutter 提供了路由参数的机制，可以在打开路由时传递相关参数，在目标页面通过 RouteSettings 来获取页面参数。 //打开页面时传递字符串参数 Navigator.of(context).pushNamed(\"second_page\", arguments: \"Hey\"); class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { //取出路由参数 String msg = ModalRoute.of(context).settings.arguments as String; return Text(msg); } } 与 Android 提供的 startActivityForResult 方法可以监听目标页面的处理结果类似，Flutter 也提供了返回参数的机制。在 push 目标页面时，可以设置目标页面关闭时监听函数，以获取返回参数；而目标页面可以在关闭路由时传递相关参数。 class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( body: Column( children: \u003cWidget\u003e[ Text('Message from first screen: $msg'), RaisedButton( child: Text('back'), //页面关闭时传递参数 onPressed: ()=\u003e Navigator.pop(context,\"Hi\") ) ] )); } } class _FirstPageState extends State\u003cFirstPage\u003e { String _msg=''; @override Widget build(BuildContext context) { return new Scaffold( body: Column(children: \u003cWidget\u003e[ RaisedButton( child: Text('命名路由（参数\u0026回调）'), //打开页面，并监听页面关闭时传递的参数 onPressed: ()=\u003e Navigator.pushNamed(context, \"third_page\",arguments: \"Hey\").then((msg)=\u003esetState(()=\u003e_msg=msg)), ), Text('Message from Second screen: $_msg'), ],), ); } } ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:9","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"APP 的事件监听 在原生 Android、iOS 开发中，有时我们需要在对应的 App 生命周期事件中做相应处理，比如 App 从后台进入前台、从前台退到后台，或是在 UI 绘制完成后做一些处理。 这样的需求，在原生开发中，我们可以通过重写 Activity、ViewController 生命周期回调方法，或是注册应用程序的相关通知，来监听 App 的生命周期并做相应的处理。而在 Flutter 中，我们可以利用 WidgetsBindingObserver 类，来实现同样的需求。 abstract class WidgetsBindingObserver { //页面pop Future\u003cbool\u003e didPopRoute() =\u003e Future\u003cbool\u003e.value(false); //页面push Future\u003cbool\u003e didPushRoute(String route) =\u003e Future\u003cbool\u003e.value(false); //系统窗口相关改变回调，如旋转 void didChangeMetrics() { } //文本缩放系数变化 void didChangeTextScaleFactor() { } //系统亮度变化 void didChangePlatformBrightness() { } //本地化语言变化 void didChangeLocales(List\u003cLocale\u003e locale) { } //App生命周期变化 //resumed: 可见并能相应用户的输入 //inactive: 处在并不活动状态，无法处理用户相应 //paused: 不可见并不能相应用户的输入，但是在后台继续活动中 void didChangeAppLifecycleState(AppLifecycleState state) { } //内存警告回调 void didHaveMemoryPressure() { } //Accessibility相关特性回调 void didChangeAccessibilityFeatures() {} } 可以看到，WidgetsBindingObserver 这个类提供的回调函数非常丰富，常见的屏幕旋转、屏幕亮度、语言变化、内存警告都可以通过这个实现进行回调。我们通过给 WidgetsBinding 的单例对象设置监听器，就可以监听对应的回调方法。 class AppLifecycleReactor extends StatefulWidget { const AppLifecycleReactor({ Key key }) : super(key: key); @override _AppLifecycleReactorState createState() =\u003e _AppLifecycleReactorState(); } class _AppLifecycleReactorState extends State\u003cAppLifecycleReactor\u003e with WidgetsBindingObserver { @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); } @override void dispose() { WidgetsBinding.instance.removeObserver(this); super.dispose(); } AppLifecycleState _notification; @override void didChangeAppLifecycleState(AppLifecycleState state) { setState(() { _notification = state; }); } @override Widget build(BuildContext context) { return Text('Last notification: $_notification'); } } ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:10","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"本地存储 数据持久化的应用场景有很多。比如，用户的账号登录信息需要保存，用于每次与 Web 服务验证身份；又比如，下载后的图片需要缓存，避免每次都要重新加载，浪费用户流量。 文件 文件是存储在某种介质（比如磁盘）上指定路径的、具有文件名的一组有序信息的集合。从其定义看，要想以文件的方式实现数据持久化，我们首先需要确定一件事儿：数据放在哪儿？这，就意味着要定义文件的存储路径。 Flutter 提供了两种文件存储的目录，即临时（Temporary）目录与文档（Documents）目录： 临时目录是操作系统可以随时清除的目录，通常被用来存放一些不重要的临时缓存数据。这个目录在 iOS 上对应着 NSTemporaryDirectory 返回的值，而在 Android 上则对应着 getCacheDir 返回的值。 文档目录则是只有在删除应用程序时才会被清除的目录，通常被用来存放应用产生的重要数据文件。在 iOS 上，这个目录对应着 NSDocumentDirectory，而在 Android 上则对应着 AppData 目录。 //创建文件目录 Future\u003cFile\u003e get _localFile async { final directory = await getApplicationDocumentsDirectory(); final path = directory.path; return File('$path/content.txt'); } //将字符串写入文件 Future\u003cFile\u003e writeContent(String content) async { final file = await _localFile; return file.writeAsString(content); } //从文件读出字符串 Future\u003cString\u003e readContent() async { try { final file = await _localFile; String contents = await file.readAsString(); return contents; } catch (e) { return \"\"; } } 有了文件读写函数，我们就可以在代码中对 content.txt 这个文件进行读写操作了。 SharedPreferences 文件比较适合大量的、有序的数据持久化，如果我们只是需要缓存少量的键值对信息（比如记录用户是否阅读了公告，或是简单的计数），则可以使用 SharedPreferences。 SharedPreferences 会以原生平台相关的机制，为简单的键值对数据提供持久化存储，即在 iOS 上使用 NSUserDefaults，在 Android 使用 SharedPreferences。 //读取SharedPreferences中key为counter的值 Future\u003cint\u003e_loadCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int counter = (prefs.getInt('counter') ?? 0); return counter; } //递增写入SharedPreferences中key为counter的值 Future\u003cvoid\u003e_incrementCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int counter = (prefs.getInt('counter') ?? 0) + 1; prefs.setInt('counter', counter); } 在完成了计数器存取方法的封装后，我们就可以在代码中随时更新并持久化计数器数据了。可以看到，SharedPreferences 的使用方式非常简单方便。不过需要注意的是，以键值对的方式只能存储基本类型的数据，比如 int、double、bool 和 string。 ","date":"2020-03-21","objectID":"/2020/03/flutter/:1:11","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"扩展 ","date":"2020-03-21","objectID":"/2020/03/flutter/:2:0","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"为什么需要做状态管理，怎么做？ 如果我们的应用足够简单，数据流动的方向和顺序是清晰的，我们只需要将数据映射成视图就可以了。作为声明式的框架，Flutter 可以自动处理数据到渲染的全过程，通常并不需要状态管理。 但，随着产品需求迭代节奏加快，项目逐渐变得庞大时，我们往往就需要管理不同组件、不同页面之间共享的数据关系。当需要共享的数据关系达到几十上百个的时候，我们就很难保持清晰的数据流动方向和顺序了，导致应用内各种数据传递嵌套和回调满天飞。在这个时候，我们迫切需要一个解决方案，来帮助我们理清楚这些共享数据的关系，于是状态管理框架便应运而生。 Flutter 在设计声明式 UI 上借鉴了不少 React 的设计思想，因此涌现了诸如 flutter_redux、flutter_mobx 、fish_redux 等基于前端设计理念的状态管理框架。但这些框架大都比较复杂，且需要对框架设计概念有一定理解，学习门槛相对较高。 而源自 Flutter 官方的状态管理框架 Provider 则相对简单得多，不仅容易理解，而且框架的入侵性小，还可以方便地组合和控制 UI 刷新粒度。因此，在 Google I/O 2019 大会一经面世，Provider 就成为了官方推荐的状态管理方式之一。 从名字就可以看出，Provider 是一个用来提供数据的框架。它是 InheritedWidget 的语法糖，提供了依赖注入的功能，允许在 Widget 树中更加灵活地处理和传递数据。 那么，什么是依赖注入呢？通俗地说，依赖注入是一种可以让我们在需要时提取到所需资源的机制，即：预先将某种“资源”放到程序中某个我们都可以访问的位置，当需要使用这种“资源”时，直接去这个位置拿即可，而无需关心“资源”是谁放进去的。 为了使用 Provider，我们需要解决以下 3 个问题： 资源（即数据状态）如何封装？ 资源放在哪儿，才都能访问得到？ 具体使用时，如何取出资源？ 首先需要在 pubspec.yaml 文件中添加 Provider 的依赖 dependencies: provider: 3.0.0+1 #provider依赖 //定义需要共享的数据模型，通过混入ChangeNotifier管理听众 class CounterModel with ChangeNotifier { int _count = 0; //读方法 int get counter =\u003e _count; //写方法 void increment() { _count++; notifyListeners();//通知听众刷新 } } 资源已经封装完毕，接下来我们就需要考虑把它放到哪儿了。 class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { //通过Provider组件封装数据资源 return ChangeNotifierProvider.value( value: CounterModel(),//需要共享的数据资源 child: MaterialApp( home: FirstPage(), ) ); } } 最后，在注入数据资源完成之后，我们就可以在 FirstPage 和 SecondPage 这两个子 Widget 完成数据的读写操作了。 关于读数据，与 InheritedWidget 一样，我们可以通过 Provider.of 方法来获取资源数据。而如果我们想写数据，则需要通过获取到的资源数据，调用其暴露的更新数据方法 //第一个页面，负责读数据 class FirstPage extends StatelessWidget { @override Widget build(BuildContext context) { //取出资源 final _counter = Provider.of\u003cCounterModel\u003e(context); return Scaffold( //展示资源中的数据 body: Text('Counter: ${_counter.counter}'), //跳转到SecondPage floatingActionButton: FloatingActionButton( onPressed: () =\u003e Navigator.of(context).push(MaterialPageRoute(builder: (context) =\u003e SecondPage())) )); } } //第二个页面，负责读写数据 class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { //取出资源 final _counter = Provider.of\u003cCounterModel\u003e(context); return Scaffold( //展示资源中的数据 body: Text('Counter: ${_counter.counter}'), //用资源更新方法来设置按钮点击回调 floatingActionButton:FloatingActionButton( onPressed: _counter.increment, child: Icon(Icons.add), )); } } Consumer 通过上面的示例可以看到，使用 Provider.of 获取资源，可以得到资源暴露的数据的读写接口，在实现数据的共享和同步上还是比较简单的。但是，滥用 Provider.of 方法也有副作用，那就是当数据更新时，页面中其他的子 Widget 也会跟着一起刷新。 那么，有没有办法能够在数据资源发生变化时，只刷新对资源存在依赖关系的 Widget，而其他 Widget 保持不变呢？ Consumer 使用了 Builder 模式创建 UI，收到更新通知就会通过 builder 重新构建 Widget。 class SecondPage extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( //使用Consumer来封装counter的读取 body: Consumer\u003cCounterModel\u003e( //builder函数可以直接获取到counter参数 builder: (context, CounterModel counter, _) =\u003e Text('Value: ${counter.counter}')), //使用Consumer来封装increment的读取 floatingActionButton: Consumer\u003cCounterModel\u003e( //builder函数可以直接获取到increment参数 builder: (context, CounterModel counter, child) =\u003e FloatingActionButton( onPressed: counter.increment, child: child, ), child: TestIcon(), ), ); } } 可以看到，Consumer 中的 builder 实际上就是真正刷新 UI 的函数，它接收 3 个参数，即 context、model 和 child。其中：context 是 Widget 的 build 方法传进来的 BuildContext，model 是我们需要的数据资源，而 child 则用来构建那些与数据资源无关的部分。在数据资源发生变更时，builder 会多次执行，但 child 不会重建。 多状态的资源封装 多个数据状态与单个数据的封装并无不同，如果需要支持数据的读写，我们需要一个接一个地为每一个数据状态都封装一个单独的资源封装类；而如果数据是只读的，则可以直接传入原始的数据对象，从而省去资源封装的过程。 在单状态的案例中，我们通过 Provider 的升级版 ChangeNotifierProvider 实现了可读写资源的注入，而如果我们想注入多个资源，则可以使用 Provider 的另一个升级版 MultiProvider，来实现多个 Provider 的组合注入。 在下面的例子中，我们通过 MultiProvider 往 App 实例内注入了 double 和 CounterModel 这两个资源 Provider： class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MultiProvider(providers: [ Provider.value(value: 30.0),//注入字体大小 ChangeNotifierProvider.value(value: CounterModel())//注入计数器实例 ], child: MaterialApp( home: FirstPage(), )); } } 使用 Provider.of 方式来获取资源。相较于单状态资源的获取来说，获取多个资源时，我们只需要依次读取每一个资源即可： final _counter = Provider.of\u003cCounterModel\u003e(context);//获取计时器实例 final textSi","date":"2020-03-21","objectID":"/2020/03/flutter/:2:1","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"应用场景 ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:0","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何进行开发环境搭建 安装 Flutter 去 Flutter 官网下载其最新可用的安装包，转到下载页。 进入到想安装的目录，执行解压命令。 根据你的 shell 设置添加 Flutter 相关工具到 path 中。 运行 flutter doctor 检查并解决问题。 安装 Android Studio 执行 brew cask install android-studio 进行安装。 没有 android-sdk 有个提示，可以取消让 Android Studio 自己去下载 sdk。 打开 AVD Manager ，点击 Create Virtual Device 按钮选择并创建一个 Android 模拟器。 打开 Plugins 搜索安装 Flutter 插件。 打开 SDK Manager ，点击 SDK Tools ，取消勾选 Hide Obsolete Packages ，选中 Android SDK Tools (Obsolete)，点击 Apply。这样就下载了等下要用到的 sdkmanager 。 执行 flutter doctor --android-licenses 添加 Android license 。 执行 flutter doctor 检查 Android 工具链。 安装 XCode 访问 App Store 安装 Xcode。 命令行执行 open -a Simulator 打开 IOS 模拟器，通过 Hardware 里的 Device 来设置不同的模拟器。 执行 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer 和 sudo xcodebuild -runFirstLaunch 将 Xcode 安装完整。 执行 brew install cocoapods 安装 cocoapods。 执行 flutter doctor 检查 IOS 工具链。 通过 Flutter 运行模拟器 # 查看当前可用的模拟器 flutter emulators # 关联并启动一个模拟器 flutter emulators --launch \u003cemulator id\u003e # 运行一个 flutter 项目，可以到安装的 flutter 的 hello_world 目录去执行下。 flutter run ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:1","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何实现视差滚动 通过 CustomScrollView 可以实现方便的实现视差滚动。 CustomScrollView( slivers: \u003cWidget\u003e[ const SliverAppBar( pinned: true, expandedHeight: 250.0, flexibleSpace: FlexibleSpaceBar( title: Text('Demo'), ), ), SliverGrid( gridDelegate: SliverGridDelegateWithMaxCrossAxisExtent( maxCrossAxisExtent: 200.0, mainAxisSpacing: 10.0, crossAxisSpacing: 10.0, childAspectRatio: 4.0, ), delegate: SliverChildBuilderDelegate( (BuildContext context, int index) { return Container( alignment: Alignment.center, color: Colors.teal[100 * (index % 9)], child: Text('Grid Item $index'), ); }, childCount: 20, ), ), SliverFixedExtentList( itemExtent: 50.0, delegate: SliverChildBuilderDelegate( (BuildContext context, int index) { return Container( alignment: Alignment.center, color: Colors.lightBlue[100 * (index % 9)], child: Text('List Item $index'), ); }, ), ), ], ) ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:2","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何实现下拉刷新、触底刷新、回到顶部等功能 我们可以通过 ScrollControler 对 ListView 的滚动信息进行监听以实现相应功能。如果需要获取更复杂的滚动信息可以通过 ScrollNotification 和 NotificationListener 来进行实现。 以下是关键代码： ScrollController _controller; // 创建控制器并注册滚动监听 @override void initState() { _controller = ScrollController(); _controller.addListener(() { print(_controller.offset); if(_controller.offset == _controller.position.maxScrollExtent){ print(\"滚动到底部\"); }else if(_controller.offset == _controller.position.minScrollExtent){ print(\"滚动到顶部\"); } }); } // 将控制器绑定到相应的 ListView ListView.builder( controller: _controller,//初始化传入控制器 itemCount: 100,//列表元素总数 itemBuilder: (context, index) =\u003e ListTile(title: Text(\"Index : $index\")),//列表项构造方法 ) // 回到顶部 _controller.animateTo(.0, duration: Duration(milliseconds: 200), curve: Curves.ease ); ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:3","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何实现视图的自绘 Flutter 提供了非常丰富的控件和布局方式，使得我们可以通过组合去构建一个新的视图。但对于一些不规则的视图，用 SDK 提供的现有 Widget 组合可能无法实现，比如饼图，k 线图等，这个时候我们就需要自己用画笔去绘制了。 在原生 iOS 和 Android 开发中，我们可以继承 UIView/View，在 drawRect/onDraw 方法里进行绘制操作。其实，在 Flutter 中也有类似的方案，那就是 CustomPaint。 CustomPaint 是用以承接自绘控件的容器，并不负责真正的绘制。既然是绘制，那就需要用到画布与画笔。在 Flutter 中，画布是 Canvas，画笔则是 Paint，而画成什么样子，则由定义了绘制逻辑的 CustomPainter 来控制。将 CustomPainter 设置给容器 CustomPaint 的 painter 属性，我们就完成了一个自绘控件的封装。 对于画笔 Paint，我们可以配置它的各种属性，比如颜色、样式、粗细等；而画布 Canvas，则提供了各种常见的绘制方法，比如画线 drawLine、画矩形 drawRect、画点 DrawPoint、画路径 drawPath、画圆 drawCircle、画圆弧 drawArc 等。 这样，我们就可以在 CustomPainter 的 paint 方法里，通过 Canvas 与 Paint 的配合，实现定制化的绘制逻辑。 class WheelPainter extends CustomPainter { // 设置画笔颜色 Paint getColoredPaint(Color color) {//根据颜色返回不同的画笔 Paint paint = Paint();//生成画笔 paint.color = color;//设置画笔颜色 return paint; } @override void paint(Canvas canvas, Size size) {//绘制逻辑 double wheelSize = min(size.width,size.height)/2;//饼图的尺寸 double nbElem = 6;//分成6份 double radius = (2 * pi) / nbElem;//1/6圆 //包裹饼图这个圆形的矩形框 Rect boundingRect = Rect.fromCircle(center: Offset(wheelSize, wheelSize), radius: wheelSize); // 每次画1/6个圆弧 canvas.drawArc(boundingRect, 0, radius, true, getColoredPaint(Colors.orange)); canvas.drawArc(boundingRect, radius, radius, true, getColoredPaint(Colors.black38)); canvas.drawArc(boundingRect, radius * 2, radius, true, getColoredPaint(Colors.green)); canvas.drawArc(boundingRect, radius * 3, radius, true, getColoredPaint(Colors.red)); canvas.drawArc(boundingRect, radius * 4, radius, true, getColoredPaint(Colors.blue)); canvas.drawArc(boundingRect, radius * 5, radius, true, getColoredPaint(Colors.pink)); } // 判断是否需要重绘，这里我们简单的做下比较即可 @override bool shouldRepaint(CustomPainter oldDelegate) =\u003e oldDelegate != this; } //将饼图包装成一个新的控件 class Cake extends StatelessWidget { @override Widget build(BuildContext context) { return CustomPaint( size: Size(200, 200), painter: WheelPainter(), ); } } ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:4","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何定制不同风格的 App 主题 主题，又叫皮肤、配色，一般由颜色、图片、字号、字体等组成，我们可以把它看做是视觉效果在不同场景下的可视资源，以及相应的配置集合。比如，App 的按钮，无论在什么场景下都需要背景图片资源、字体颜色、字号大小等，而所谓的主题切换只是在不同主题之间更新这些资源及配置集合而已。 Flutter 也提供了类似的能力，由 ThemeData 来统一管理主题的配置信息。ThemeData 涵盖了 Material Design 规范的可自定义部分样式，比如应用明暗模式 brightness、应用主色调 primaryColor、应用次级色调 accentColor、文本字体 fontFamily、输入框光标颜色 cursorColor 等。 MaterialApp( title: 'Flutter Demo',//标题 theme: ThemeData(//设置主题 brightness: Brightness.dark,//设置明暗模式为暗色 accentColor: Colors.black,//(按钮）Widget前景色为黑色 primaryColor: Colors.cyan,//主色调为青色 iconTheme:IconThemeData(color: Colors.yellow),//设置icon主题色为黄色 textTheme: TextTheme(body1: TextStyle(color: Colors.red))//设置文本颜色为红色 ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); 除了定义 Material Design 规范中那些可自定义部分样式外，主题的另一个重要用途是样式复用。 Container( color: Theme.of(context).primaryColor,//容器背景色复用应用主题色 child: Text( 'Text with a background color', style: Theme.of(context).textTheme.title,//Text组件文本样式复用应用文本样式) ); ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:5","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"如何作出动画效果 动画就是提升用户体验的一个重要方式，一个恰当的组件动画或者页面切换动画，不仅能够缓解用户因为等待而带来的情绪问题，还会增加好感。Flutter 既然完全接管了渲染层，除了静态的页面布局之外，对组件动画的支持自然也不在话下。 Animation、AnimationController 与 Listener 动画就是动起来的画面，是静态的画面根据事先定义好的规律，在一定时间内不断微调，产生变化效果。而动画实现由静止到动态，主要是靠人眼的视觉残留效应。所以，对动画系统而言，为了实现动画，它需要做三件事儿： 确定画面变化的规律 根据这个规律，设定动画周期，启动动画 定期获取当前动画的值，不断地微调、重绘画面 这三件事情对应到 Flutter 中，就是 Animation、AnimationController 与 Listener： Animation 是 Flutter 动画库中的核心类，会根据预定规则，在单位时间内持续输出动画的当前状态。Animation 知道当前动画的状态（比如，动画是否开始、停止、前进或者后退，以及动画的当前值），但却不知道这些状态究竟应用在哪个组件对象上。换句话说，Animation 仅仅是用来提供动画数据，而不负责动画的渲染。 AnimationController 用于管理 Animation，可以用来设置动画的时长、启动动画、暂停动画、反转动画等。 Listener 是 Animation 的回调函数，用来监听动画的进度变化，我们需要在这个回调函数中，根据动画的当前值重新渲染组件，实现动画的渲染。 class _NormalAnimateState extends State\u003cNormalAnimateWidget\u003e with SingleTickerProviderStateMixin { AnimationController controller; Animation\u003cdouble\u003e animation; void initState() { super.initState(); // 创建动画周期为1秒的AnimationController对象 controller = AnimationController( vsync: this, duration: const Duration(milliseconds: 1000)); final CurvedAnimation curve = CurvedAnimation(parent: controller, curve: Curves.elasticOut); // 创建从50到200线性变化的Animation对象 // 普通动画需要手动监听动画状态，刷新UI animation = Tween(begin: 50.0, end: 200.0).animate(curve) ..addListener(() =\u003e setState(() {})); // 启动动画 controller.repeat(reverse: true); } @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( body: Center( child: Container( width: animation.value, height: animation.value, child: FlutterLogo(), )))); } @override void dispose() { // 释放资源 controller.dispose(); super.dispose(); } } 我们在上面用到的 Tween 默认是线性变化的，但可以创建 CurvedAnimation 来实现非线性曲线动画。CurvedAnimation 提供了很多常用的曲线，比如震荡曲线 elasticOut。 //创建动画周期为1秒的AnimationController对象 controller = AnimationController( vsync: this, duration: const Duration(milliseconds: 1000)); //创建一条震荡曲线 final CurvedAnimation curve = CurvedAnimation( parent: controller, curve: Curves.elasticOut); // 创建从50到200跟随振荡曲线变化的Animation对象 animation = Tween(begin: 50.0, end: 200.0).animate(curve) AnimatedWidget 与 AnimatedBuilder 在为 Widget 添加动画效果的过程中我们不难发现，Animation 仅提供动画的数据，因此我们还需要监听动画执行进度，并在回调中使用 setState 强制刷新界面才能看到动画效果。考虑到这些步骤都是固定的，Flutter 提供了两个类来帮我们简化这一步骤，即 AnimatedWidget 与 AnimatedBuilder。 在构建 Widget 时，AnimatedWidget 会将 Animation 的状态与其子 Widget 的视觉样式绑定。要使用 AnimatedWidget，我们需要一个继承自它的新类，并接收 Animation 对象作为其初始化参数。然后，在 build 方法中，读取出 Animation 对象的当前值，用作初始化 Widget 的样式。 class AnimatedLogo extends AnimatedWidget { //AnimatedWidget需要在初始化时传入animation对象 AnimatedLogo({Key key, Animation\u003cdouble\u003e animation}) : super(key: key, listenable: animation); Widget build(BuildContext context) { //取出动画对象 final Animation\u003cdouble\u003e animation = listenable; return Center( child: Container( height: animation.value,//根据动画对象的当前状态更新宽高 width: animation.value, child: FlutterLogo(), )); } } 在使用时，我们只需把 Animation 对象传入 AnimatedLogo 即可，再也不用使用 addListener(() =\u003e setState(() {})) 监听动画的执行进度刷新 UI 了： MaterialApp( home: Scaffold( body: AnimatedLogo(animation: animation)//初始化AnimatedWidget时传入animation对象 )); 在 AnimatedLogo 的 build 方法中，我们使用 Animation 的 value 作为 logo 的宽和高。这样做对于简单组件的动画没有任何问题，但如果动画的组件比较复杂，一个更好的解决方案是，将动画和渲染职责分离：logo 作为外部参数传入，只做显示；而尺寸的变化动画则由另一个类去管理。这个分离工作，我们可以借助 AnimatedBuilder 来完成。 与 AnimatedWidget 类似，AnimatedBuilder 也会自动监听 Animation 对象的变化，并根据需要将该控件树标记为 dirty 以自动刷新 UI。事实上，如果你翻看源码，就会发现 AnimatedBuilder 其实也是继承自 AnimatedWidget。 MaterialApp( home: Scaffold( body: Center( child: AnimatedBuilder( animation: animation,//传入动画对象 child:FlutterLogo(), //动画构建回调 builder: (context, child) =\u003e Container( width: animation.value,//使用动画的当前状态更新UI height: animation.value, child: child, //child参数即FlutterLogo() ) ) ) )); 可以看到，通过使用 AnimatedWidget 和 AnimatedBuilder，动画的生成和最终的渲染被分离开了，构建动画的工作也被大大简化了。 hero 动画 现在我们已经知道了如何在一个页面上实现动画效果，那么如何实现在两个页面之间切换的过渡动画呢？比如在社交类 App，在 Feed 流中点击小图进入查看大图页面的场景中，我们希望能够实现小图到大图页面逐步放大的动画切换效果，而当用户关闭大图时，也实现原路返回的动画。 Flutter 也有类似的概念，即 Hero 控件。通过 Hero，我们可以在两个页面的共享元素之间，做出流畅的页面切换效果。 class Page1 extends StatelessWidget { Widget build(BuildContext context) { return Scaffold( body: GestureDetector(//手势监听点击 child: ","date":"2020-03-21","objectID":"/2020/03/flutter/:3:6","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"参考 Dart API docs Flutter API docs Flutter 核心技术与实战 Repl.it 在 macOS 上搭建 Flutter 开发环境 通过 Android studio 下载的 sdk 中没有 tools 文件夹的解决办法 ","date":"2020-03-21","objectID":"/2020/03/flutter/:4:0","tags":["框架"],"title":"Flutter 的使用","uri":"/2020/03/flutter/"},{"categories":null,"content":"简介 MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。 ","date":"2020-03-15","objectID":"/2020/03/mysql/:1:0","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"基础 ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:0","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"基础命令 # 启动命令和启动服务命令根据操作系统不同有所差别 # 连接 mysql 服务 mysql [-h 地址] [-P 端口] [-u 用户名] [-p 密码] # 备份数据库 # mysqldump -uroot -p \u003e ~/db/dump1.sql mysqldump -u \u003cuser\u003e -p \u003cdatabase\u003e \u003e \u003cpath\u003e # copy 数据库或者恢复数据库 mysql -u \u003cuser\u003e -p \u003cdatabase\u003e \u003c \u003cpath\u003e ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:1","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"基础 SQL 语句 库相关 -- 添加数据库 create database \u003cdatabase\u003e -- 删除数据库 drop database \u003cdatabase\u003e -- 修改数据库的默认字符集 alert database \u003cdatabase\u003e default character set \u003ccharacter\u003e; -- 查看所有数据库 show databases; 表相关 -- 选择数据库 use \u003cdatabase\u003e; -- 创建表 create table \u003ctable\u003e(\u003ccolumn\u003e \u003ctype\u003e,...); -- 删除表 drop table \u003ctable\u003e; -- 修改表名 alter table \u003cold_name\u003e rename to \u003cnew_name\u003e; -- 添加字段 alter table \u003ctable\u003e add column \u003ccolumn\u003e \u003ctype\u003e; -- 删除字段 alter table \u003ctable\u003e drop column \u003ccolumn\u003e; -- 修改字段类型 alter table \u003ctable\u003e modify column \u003ccolumn\u003e \u003ctype\u003e; -- 修改字段名称 alter table \u003ctable\u003e change column \u003cold_name\u003e \u003cnew_name\u003e \u003ctype\u003e; -- 查看所有表 show tables; -- 查看表结构 desc \u003ctable\u003e; 数据相关 -- 插入一行数据，指定所有字段的值，不能多或少 insert into \u003ctable\u003e values(\u003cvalue1\u003e,\u003cvalue2\u003e, ...); -- 插入一行数据，指定字段和值 insert into \u003ctable\u003e(\u003ccolumn1\u003e, \u003ccolumn2\u003e) values(\u003cvalue1\u003e, \u003cvalue2\u003e); -- 删除所有行，直接释放数据页，效率高不可恢复，清空主键标识，不激发触发器 truncate table \u003ctable\u003e; -- 删除行，不加 where 清空数据表时，也是一行一行删，有记录可恢复，不清空主键标识，会激发触发器 delete from \u003ctable\u003e [where 条件列表]; -- 修改行字段值 update \u003ctable\u003e set \u003ccolumn\u003e=\u003cvalue\u003e,... [where 条件列表]; -- 查询 select [distinct] \u003c字段列表\u003e from \u003c表名列表\u003e [where 条件列表] [union [all] where...] [inner join \u003c表名\u003e on \u003c连接条件\u003e] [left [outer] join \u003c表名\u003e on \u003c连接条件\u003e] [group by \u003c列名列表\u003e [having 条件列表][with rollup]] [order by \u003c排序字段\u003e [asc/desc]] [limit [起始行下标],\u003c查询行数\u003e]; ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:2","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"列类型 -- 整型 类型 字节 范围（有符号位） tinyint 1字节 -128 ~ 127 无符号位：0 ~ 255 smallint 2字节 -32768 ~ 32767 mediumint 3字节 -8388608 ~ 8388607 int 4字节 -- 浮点型 类型 字节 float(单精度) 4字节 double(双精度) 8字节 -- 字符串 char 定长字符串，速度快，但浪费空间 varchar 变长字符串，速度慢，但节省空间 -- 时间日期类型 datetime 8字节 日期及时间 1000-01-01 00:00:00 到 9999-12-31 23:59:59 date 3字节 日期 1000-01-01 到 9999-12-31 timestamp 4字节 时间戳 19700101000000 到 2038-01-19 03:14:07 time 3字节 时间 -838:59:59 到 838:59:59 year 1字节 年份 1901 - 2155 ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:3","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"列约束 default not null unique primary key auto_increment zerofill foreign key ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:4","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"内置函数 -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分 time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分 date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 流程函数 case when [condition] then result [when [condition] then result ...] [else result] end 多分支 if(expr1,expr2,expr3) 双分支。 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); ","date":"2020-03-15","objectID":"/2020/03/mysql/:2:5","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"扩展 ","date":"2020-03-15","objectID":"/2020/03/mysql/:3:0","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"如何进行 SQL 优化？ 其实需要优化的主要是慢 sql 和热点 sql 两部分，其他的只要不是写的太难看，基本根据常用的条件字段加个索引就足以解决问题了。 慢 sql 的话，可以开启 MySQL 的慢查询日志，就可以找到对应的 sql 进行相应的调整了。而热点 sql，其实和业务相关，比如说某个查询就是会调用的比较频繁，这个 MySQL 就帮不了我们了，可以自己在 DAO 层打印日志，再通过 sed 根据日志统计热点 sql，当然也可以有其他方案。我记得 Spring Boot 好像就有类似的支持。 找到需要进行优化的 sql 后可以通过 explain 对其执行计划进行分析，找到低效原因，针对性的进行优化。 优化 sql 语句的一般步骤 一张图彻底搞懂 MySQL 的 explain ","date":"2020-03-15","objectID":"/2020/03/mysql/:3:1","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"应用场景 ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:0","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"分页查询 -- 使用 limit 子句进行分页查询, limit \u003c(page-1)*pageSize\u003e,\u003cpageSize\u003e -- 只写一个参数的情况下，是查询前多少条，也就是 limit n; 等于 limit 0,n; select \u003ccolumns\u003e from \u003ctable\u003e limit 0,15; ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:1","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"多表查询 -- 内连接查询 select \u003ccolumns\u003e from \u003ctable1\u003e,\u003ctable2\u003e where \u003ctable1_id\u003e=\u003ctable2_id\u003e; select \u003ccolumns\u003e from \u003ctable1\u003e inner join \u003ctable2\u003e on \u003ctable1_id\u003e=\u003ctable2_id\u003e; -- 左外连接查询 -- 使用左边表的数据去匹配右边表的数据，如果符合连接条件的结果就显示，如果不符合连接条件的则显示 null select \u003ccolumns\u003e from \u003ctable1\u003e left outer join \u003ctable2\u003e on \u003ctable1_id\u003e=\u003ctable2_id\u003e; -- 自连接查询 -- 就是虚拟出一张表，通过别名的方式，进行内连接或者外连接查询 select \u003ccolumns\u003e from \u003ctable\u003e as a inner join \u003ctable\u003e as b on \u003ca_id\u003e=\u003cb_xxx\u003e; ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:2","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"子查询 -- 查询条件未知的问题时，可以分解成多个条件已知的问题 -- 在使用索引的情况下，多表查询要比子查询效率高，因此能用多表查询的就不要用子查询 -- 子查询只会返回一个结果的，父查询用=、!=、\u003e=、\u003c=、\u003e、\u003c，这些符号来比较 select * from \u003ctable1\u003e where \u003ccolumn1\u003e = (select \u003ccolumn1\u003e from \u003ctable2\u003e where ...); -- 子查询会返回多个结果的，父查询用in、any、all，这些符号来比较 select * from \u003ctable1\u003e where \u003ccolumn1\u003e in (select \u003ccolumn1\u003e from \u003ctable2\u003e where ...); ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:3","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"分组统计查询 -- 分组查询 column 列并统计数目 select \u003ccolumn\u003e,count(*) from \u003ctable\u003e group by \u003ccolumn\u003e; -- 分组查询后筛选符合条件的行 select \u003ccolumn\u003e,count(*) from \u003ctable\u003e group by \u003ccolumn\u003e having count(*) \u003e 100; ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:4","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"MySQL UPDATE 误操作后恢复数据 使用 sed 命令恢复。参考 mysqlbinlog 结合 sed 命令恢复 update 时未加 where 条件之前的数据 ","date":"2020-03-15","objectID":"/2020/03/mysql/:4:5","tags":["工具"],"title":"MySQL 的使用","uri":"/2020/03/mysql/"},{"categories":null,"content":"什么是 RESTful? RESTful 就是一种当前互联网软件的 api 设计模式。最早是由 Fielding 在他的博士论文里提出，定名为 REST，即 Representational State Transfer 的缩写。要理解 RESTful 架构，最好的方法就是去理解 Representational State Transfer 这个词组到底是什么意思。REST 的核心在于，当你设计一个系统的时候，资源是第一位的考虑，你首先从资源的角度进行系统的拆分、设计，而不是像以往一样以操作为角度来进行设计。 资源（Resources） REST 的名称\"表现层状态转化\"中，省略了主语。“表现层\"其实指的是\"资源”（Resources）的\"表现层”。所谓\"资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI。要获取这个资源，访问它的 URI 就可以，因此 URI 就成了每一个资源的地址或独一无二的识别符。 表现层（Representation） “资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式，叫做它的\"表现层”（Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、XML 格式、JSON 格式表现，甚至可以采用二进制格式；图片可以用 JPG 格式表现，也可以用 PNG 格式表现。 状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。如果客户端想要操作服务器，必须通过某种手段，让服务器端发生\"状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是\"表现层状态转化”。 ","date":"2020-03-14","objectID":"/2020/03/restful/:1:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"REST 的原则 使用 HTTP 动词：GET POST PUT DELETE； 无状态连接，服务器端不应保存过多上下文状态，即每个请求都是独立的； 为每个资源设置 URI； 通过 XML JSON 进行数据传递； ","date":"2020-03-14","objectID":"/2020/03/restful/:2:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"HTTP 动词 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 ","date":"2020-03-14","objectID":"/2020/03/restful/:3:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"为什么要使用 RESTful? 网络应用程序，分为前端和后端两个部分。当前的发展趋势，就是前端设备层出不穷，因此，必须有一种统一的机制，方便不同的前端设备与后端进行通信。这导致 API 构架的流行，甚至出现\"API First\"的设计思想。RESTful API 是目前比较成熟的一套互联网应用程序的 API 设计理论。 ","date":"2020-03-14","objectID":"/2020/03/restful/:4:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"RESTful 的好处？ 互联网环境下，任何应用的架构和 API 可以被快速理解； 分布式环境下，任何请求都可以被发送到任意服务器； 异构环境下，任何资源的访问和使用方式都统一； ","date":"2020-03-14","objectID":"/2020/03/restful/:5:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"参考 RESTful API 设计指南 ","date":"2020-03-14","objectID":"/2020/03/restful/:6:0","tags":["杂谈"],"title":"RESTful 知识总结","uri":"/2020/03/restful/"},{"categories":null,"content":"HTTP 协议是什么？ HTTP 协议是超文本传输协议的缩写，英文是 Hyper Text Transfer Protocol。它是从 WEB 服务器传输超文本标记语言 (HTML) 到本地浏览器的传送协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。 ","date":"2020-03-14","objectID":"/2020/03/http/:1:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"HTTP 特点 HTTP 协议支持客户端 / 服务端模式，也是一种请求 / 响应模式的协议。 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。 灵活：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 HTTP 状态的技术，一个叫做 Cookie, 一个叫做 Session。 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。 ","date":"2020-03-14","objectID":"/2020/03/http/:2:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"HTTP 报文组成 ","date":"2020-03-14","objectID":"/2020/03/http/:3:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"请求报文 请求行：包括请求方法、URL、协议 / 版本 请求头 (Request Header) 请求正文 ","date":"2020-03-14","objectID":"/2020/03/http/:3:1","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"响应报文 状态行 响应头 响应正文 ","date":"2020-03-14","objectID":"/2020/03/http/:3:2","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"常见的请求方法 GET: 请求指定的页面信息，并返回实体主体。 POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。 HEAD: 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT: 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE: 请求服务器删除指定的页面。 ","date":"2020-03-14","objectID":"/2020/03/http/:4:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"常见状态码 200 OK - 客户端请求成功 301 - 资源（网页等）被永久转移到其它 URL 302 - 临时跳转 400 Bad Request - 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized - 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用 404 - 请求资源不存在，可能是输入了错误的 URL 500 - 服务器内部发生了不可预期的错误 503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 ","date":"2020-03-14","objectID":"/2020/03/http/:5:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"URI 和 URL 的区别？ URI：Uniform Resource Identifier 统一资源标识符 URL：Uniform Resource Location 统一资源定位符 HTTP 使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URI 是用来标示 一个具体的资源的，我们可以通过 URI 知道一个资源是什么。URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的 URL。 ","date":"2020-03-14","objectID":"/2020/03/http/:6:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"POST 和 GET 的区别？ 都包含请求头请求行，POST 多了请求 BODY。 GET 多用来查询，请求参数放在 URL 中，不会对服务器上的内容产生作用。POST 用来提交，如把账号密码放入 BODY 中。 GET 是直接添加到 URL 后面的，直接就可以在 URL 中看到内容，而 POST 是放在报文内部的，用户无法直接看到。 GET 提交的数据长度是有限制的，因为 URL 长度有限制，具体的长度限制视浏览器而定。而 POST 没有。 ","date":"2020-03-14","objectID":"/2020/03/http/:7:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"HTTPS 和 HTTP 的区别？ HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理。 HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443。 HTTPS 进行了多次握手、安全算法等，传输速度上要比 HTTP 慢。 ","date":"2020-03-14","objectID":"/2020/03/http/:8:0","tags":["杂谈"],"title":"HTTP 知识总结","uri":"/2020/03/http/"},{"categories":null,"content":"前言 为了更快的速度和很多 neovim 才支持的插件，从 vim 迁移过来了。 ","date":"2020-03-12","objectID":"/2020/03/nvim/:1:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"基础 ","date":"2020-03-12","objectID":"/2020/03/nvim/:2:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Normal j : 下移一字符 k : 上移一字符 h : 左移一字符 l : 右移一字符 w(word)/W : 移动到下一个单词开头（WORD 将空白符分割的识别为单词） b(backword)/B : 回到上一个单词开头 gg : 移动到文件开头 G : 移动到文件结尾 zz : 把光标行置为屏幕中间 * : 当前单词向前匹配 # : 当前单词向后匹配 :/ : 向后搜索(n/N : 跳转到下一个/上一个匹配) :? : 向前搜索 x : 删除一个字符 daw : 删除一个单词 [num]dd : 删除 num 行 r : 修改一个字符 ~ : 修改大小写 v : 字符选择 V : 行选择 ","date":"2020-03-12","objectID":"/2020/03/nvim/:2:1","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Insert ctrl + n : 单词补全 ctrl + h : 删除上一个字符 ctrl + w : 删除上一个单词 ctrl + u : 删除当前行插入位置之前的内容 ","date":"2020-03-12","objectID":"/2020/03/nvim/:2:2","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Vim 的四种模式 ","date":"2020-03-12","objectID":"/2020/03/nvim/:3:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Normal 模式 Normal 模式可以进行各种命令操作和移动 大部分情况下你是浏览而不是编辑，所以 Vim 默认是 Normal 模式 ","date":"2020-03-12","objectID":"/2020/03/nvim/:3:1","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Insert 模式 Insert 模式和普通编辑器差不多用来做文本输入 使用 i(insert)、a(append)、o(open a line below)、I、A、O、gi(回到最后一次编辑的位置) 进入 Insert 模式 Esc 从 Insert 模式退回到 Normal 模式 ","date":"2020-03-12","objectID":"/2020/03/nvim/:3:2","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Command 模式 Command 模式用来执行 Vim 命令 ","date":"2020-03-12","objectID":"/2020/03/nvim/:3:3","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Visual 模式 Visual 模式用来选择 要进行操作的内容 ","date":"2020-03-12","objectID":"/2020/03/nvim/:3:4","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Vim 多文件操作 ","date":"2020-03-12","objectID":"/2020/03/nvim/:4:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"概念 Buffer 指打开的一个文件的内存缓冲区 Window 是 Buffer 的可视化分割区域 Tab 可以组织窗口作为一个工作区 ","date":"2020-03-12","objectID":"/2020/03/nvim/:4:1","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"相关命令 Buffer :ls : 列举当前缓冲区 :b\u003cn\u003e : 跳转到第 n 个缓冲区 :bpre、bnext、bfirst、blast :b \u003cbuffer_name\u003e Window \u003cCtrl + w\u003es : 水平分割 \u003cCtrl + w\u003ev : 垂直分割 \u003cCtrl + w\u003ew : 窗口切换 \u003cCtrl + w\u003e[h,j,k,l] : 窗口切换 \u003cCtrl + w\u003e[H,J,K,L] : 窗口移动 Tab :tabe \u003cfilename\u003e 在新标签页中打开文件 \u003cCtrl + w\u003eT : 把当前窗口移动到新标签页 :tabc[lose] : 关闭当前页及其中所有窗口 :tabo[nly] : 自保留活动标签页，关闭其它 :tabn[ext] : 切换标签页 gt : 切换标签页 ","date":"2020-03-12","objectID":"/2020/03/nvim/:4:2","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"操作系统剪切板 Vim 中使用 delete yank put 操作时会使用寄存器保存内容，不指定的话就是无名寄存器和寄存器 0。其它还有 a-z 寄存器。+寄存器代表系统剪切板。复制到系统剪切板可以\"+y,从系统剪切板粘贴为\"+p。 ","date":"2020-03-12","objectID":"/2020/03/nvim/:5:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"Vim 的自动补全 Ctrl + n/Ctrl + p : 补全单词 Ctrl + x/Ctrl + f : 补全文件名 Ctrl + x/Ctrl + o : 补全代码(需要插件) ","date":"2020-03-12","objectID":"/2020/03/nvim/:6:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"VIM 的配置持久化 Linux/Unix 下新建一个隐藏文件 vim ~/.vimrc Windows 下使用$MYVIMRC来定位配置文件位置 NeoVIM 的配置文件的位置应为~/AppData/Local/nvim/init.vim 或 ~/.config/nvim/init.vim; ","date":"2020-03-12","objectID":"/2020/03/nvim/:7:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"快捷键映射 [n(normal生效)/v(visual生效)/i(insert生效)][nore(非递归映射)]map \u003ctarget_key_sequence\u003e \u003csource_key_sequence\u003e : 创建源操作映射为目标操作，比如map - x，然后按-就会删除字符 ","date":"2020-03-12","objectID":"/2020/03/nvim/:8:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"宏 使用q\u003cregister\u003e开始录制，可以进行 insert 和 normal 模式下的正常操作，q结束录制。使用@\u003cregister\u003e在当前行执行宏命令。使用 V 选中多行:进入命令模式输入normal @\u003cregister\u003e在选中行执行宏命令。 ","date":"2020-03-12","objectID":"/2020/03/nvim/:9:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"配置 Show You Code \" ================================================================ \" Created by OrionPax on 2019/08/26 \" Last Modified: 2020/03/12 \" \" 1. 基础设置 \" - Editor behavior \" - Terminal Behaviors \" 2. 插件设置 \" - 移动 \" - 编辑 \" - Markdown \" - 版本控制 \" - 增强 \" - 配置 \" 3. 按键映射 \" - 移动 \" - 编辑 \" - Tab \" - Screen \" - Markdown \" ================================================================ \" ================================================================ \" 1. 基础设置 \" ================================================================ \" ------------------------ Editor behavior ------------------------ \" 设置显示行号 set number \" 设置相对行号 set relativenumber \" 设置光标下划线 set cursorline \" 一个tab等于多少个空格，当 expandtab的情况下，会影响在插入模式下按下\u003ctab\u003e键输入的空格，以及真正的 \\t 用多少个空格显示 set tabstop=2 \" 将 tab 转层空格 set expandtab \" noexpandtab 的情况下，tabstop 只会影响 \\t 显示多少个空格（因为插入模式下按 \u003ctab\u003e 将会输入一个字符 \\t \" set noexpandtab \" 使用 \u003e\u003e \u003c\u003c 或 == 来缩进代码的时候补出的空格数。这个值也会影响 autoindent 自动缩进的值。 set shiftwidth=2 \" insert 模式下，一个 tab 键按下后，展示成几个空格 set softtabstop=2 \" 设置自动缩进 set autoindent \" 显示不可见字符 set list \" 设置 tab 和 空白符的显示方式 set listchars=tab:\\|\\ ,trail:▫ \" 开启真彩色支持 set termguicolors \" 保持光标上下的最小行数 set scrolloff=4 \" 在按下Esc后等待多长时间来决定是否还有输入.默认值为 1000 毫秒 set ttimeoutlen=0 \" 设置键盘映射没有超时 set notimeout \" 设置需要折行 set wrap \" 设置 textwidth = 0 的话，就不会自动换行了，默认是\" 78，超过这个数量的话按空格会自动换行 set tw=0 \" 设置缩进方式 set indentexpr= \" 启用折叠 zc/zo 折叠和取消折叠 set foldenable \" 缩进折叠，相同的缩进中代码会被折叠 set foldmethod=indent \" 设置折叠级别 set foldlevel=99 \" 设置格式化选项 set formatoptions-=tc \" 设置新分割窗口在右边 set splitright \" 设置新分割窗口在下边 set splitbelow \" 不在底部显示当前模式 set noshowmode \" 命令模式下，在底部显示，当前键入的指令 set showcmd \" 命令模式下，底部操作指令按下 Tab 键自动补全。第一次按下 Tab，会显示所有匹配的操作指令的清单；第二次按下 Tab，会依次选择各个指令。 set wildmenu \" 搜索时忽略大小写 set ignorecase \" 输入大写字符时大小写敏感 set smartcase \" 执行替换命令时将修改结果放到一个单独的窗口，执行 Esc 取消 set inccommand=split \" 设置 ctrl + n 自动补全的配置 set completeopt=longest,noinsert,menuone,noselect,preview \" 设置滚动屏幕更快 set ttyfast \" 设置滚动屏幕更快 set lazyredraw \" 出错时发出视觉提醒，通常是屏幕闪烁 set visualbell \" 设置文件备份 silent !mkdir -p ~/.config/nvim/tmp/backup silent !mkdir -p ~/.config/nvim/tmp/undo set backupdir=~/.config/nvim/tmp/backup,. set directory=~/.config/nvim/tmp/backup,. if has('persistent_undo') set undofile set undodir=~/.config/nvim/tmp/undo,. endif \" 隐藏标尺 \" set colorcolumn=80 \" 根据光标位置自动更新高亮 tag 的间隔时间，单位为毫秒 set updatetime=1000 \" 普通模式光标的可移动位置，设置 onemore 可以移动到最后一个字符后 set virtualedit=block \" 打开文件跳转到最后编辑时的光标位置 au BufReadPost * if line(\"'\\\"\") \u003e 1 \u0026\u0026 line(\"'\\\"\") \u003c= line(\"$\") | exe \"normal! g'\\\"\" | endif \" ------------------------ Terminal Behaviors ------------------------ let g:neoterm_autoscroll = 1 autocmd TermOpen term://* startinsert tnoremap \u003cC-N\u003e \u003cC-\\\u003e\u003cC-N\u003e tnoremap \u003cC-O\u003e \u003cC-\\\u003e\u003cC-N\u003e\u003cC-O\u003e let g:terminal_color_0 = '#000000' let g:terminal_color_1 = '#FF5555' let g:terminal_color_2 = '#50FA7B' let g:terminal_color_3 = '#F1FA8C' let g:terminal_color_4 = '#BD93F9' let g:terminal_color_5 = '#FF79C6' let g:terminal_color_6 = '#8BE9FD' let g:terminal_color_7 = '#BFBFBF' let g:terminal_color_8 = '#4D4D4D' let g:terminal_color_9 = '#FF6E67' let g:terminal_color_10 = '#5AF78E' let g:terminal_color_11 = '#F4F99D' let g:terminal_color_12 = '#CAA9FA' let g:terminal_color_13 = '#FF92D0' let g:terminal_color_14 = '#9AEDFE' augroup TermHandling autocmd! \" Turn off line numbers, listchars, auto enter insert mode and map esc to \" exit insert mode autocmd TermOpen * setlocal listchars= nonumber norelativenumber \\ | startinsert autocmd FileType fzf call LayoutTerm(0.6, 'horizontal') augroup END function! LayoutTerm(size, orientation) abort let timeout = 16.0 let animation_total = 120.0 let timer = { \\ 'size': a:size, \\ 'step': 1, \\ 'steps': animation_total / timeout \\} if a:orientation == 'horizontal' resize 1 function! timer.f(timer) execute 'resize ' . string(\u0026lines * self.size * (self.step / self.steps)) let self.step += 1 endfunction else vertical resize 1 function! timer.f(timer) execute 'vertical resize ' . string(\u0026columns * self.size * (self.step / self.steps)) let self.step += 1 endfunction endif call timer_sta","date":"2020-03-12","objectID":"/2020/03/nvim/:10:0","tags":["工具"],"title":"neovim 的使用","uri":"/2020/03/nvim/"},{"categories":null,"content":"简介 Hammerspoon 是一个 MacOS 下的开源的自动化工具。在操作系统和 Lua 脚本之间构建了桥梁。Hammerspoon 除了本身提供的操作系统的 api 外，同时提供了一批特定系统功能扩建的封装工具集，让编写 Lua 脚本来操作系统更为简单。 ","date":"2020-03-08","objectID":"/2020/03/hammerspoon/:1:0","tags":["工具"],"title":"Hammerspoon 的使用","uri":"/2020/03/hammerspoon/"},{"categories":null,"content":"安装 执行 brew cask install hammerspoon 安装，安装完成后在偏好设置里点击 Enable Accessibility 授权 hammerspoon 使用辅助功能的权限。之后只要在 ~/.hammerspoon/init.lua 中编写脚本然后选择 Reload Config 就可以生效了。可以 Getting Started with Hammerspoon 上复制 Hello World 自己试下。 ","date":"2020-03-08","objectID":"/2020/03/hammerspoon/:2:0","tags":["工具"],"title":"Hammerspoon 的使用","uri":"/2020/03/hammerspoon/"},{"categories":null,"content":"使用 官方提供了很多有用的工具集封装，简单的功能基本覆盖，如果没有特殊需求的话基本没有必要使用更底层的 api。以下是我用到的几个： ModalMgr : 封装按键绑定 WinWin : 封装应用布局操作，可以轻松实现二分屏、三分屏 KSheet : 显示当前应用的快捷键位 SpeedMenu : 工具栏显示网速 ","date":"2020-03-08","objectID":"/2020/03/hammerspoon/:3:0","tags":["工具"],"title":"Hammerspoon 的使用","uri":"/2020/03/hammerspoon/"},{"categories":null,"content":"配置 --- 这里只是展示我的配置，实际使用的话去下面参考部分克隆下来，复制到本地的 `~/.hammerspoon` 下修改 --------------- 依赖定义 ------------------ hs.loadSpoon(\"ModalMgr\") hs.loadSpoon(\"WinWin\") hs.loadSpoon(\"KSheet\") hs.loadSpoon(\"SpeedMenu\") hs.loadSpoon(\"BingDaily\") -------------- 自定义配置 ----------------- --- 禁用热键提示，开始使用的时候可以先设置成 1 hs.hotkey.alertDuration = 0 --- 禁用切换应用时的文件名提示 hs.hints.showTitleThresh = 0 --- 禁用动画 hs.window.animationDuration = 0 -------------- 自定义功能 ----------------- --- 应用快速布局 if spoon.WinWin then spoon.ModalMgr:new(\"FastLayout\") local cmodal = spoon.ModalMgr.modal_list[\"FastLayout\"] -- 定义进入环境后的快捷键 cmodal:bind(\"\", \"escape\", \"退出快速布局\", function() spoon.ModalMgr:deactivate({ \"FastLayout\" }) end) cmodal:bind(\"shift\", \"/\", \"查看帮助\", function() spoon.ModalMgr:toggleCheatsheet() end) cmodal:bind(\"\", \"F\", \"全屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"fullscreen\") end) cmodal:bind(\"\", \"C\", \"居中\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"center\") end) cmodal:bind(\"\", \"H\", \"移动到左半屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"halfleft\") end) cmodal:bind(\"\", \"L\", \"移动到右半屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"halfright\") end) cmodal:bind(\"\", \"K\", \"移动到上半屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"halfup\") end) cmodal:bind(\"\", \"J\", \"移动到下半屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"halfdown\") end) cmodal:bind(\"\", \"Y\", \"移动到左三分之一屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"onethirdleft\") end) cmodal:bind(\"\", \"O\", \"移动到右三分之一屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"onethirdright\") end) cmodal:bind(\"\", \"U\", \"移动到上三分之一屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"onethirdup\") end) cmodal:bind(\"\", \"I\", \"移动到下三分之一屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"onethirddown\") end) cmodal:bind(\"\", \"N\", \"移动到左三分之二屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"twothirdsleft\") end) cmodal:bind(\"\", \".\", \"移动到右三分之二屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"twothirdsright\") end) cmodal:bind(\"\", \"M\", \"移动到上三分之二屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"twothirdsup\") end) cmodal:bind(\"\", \",\", \"移动到下三分之二屏\", function() spoon.WinWin:stash() spoon.WinWin:moveAndResize(\"twothirdsdown\") end) cmodal:bind( \"\", \"=\", \"放大\", function() spoon.WinWin:moveAndResize(\"expand\") end, nil, function() spoon.WinWin:moveAndResize(\"expand\") end ) cmodal:bind( \"\", \"-\", \"缩小\", function() spoon.WinWin:moveAndResize(\"shrink\") end, nil, function() spoon.WinWin:moveAndResize(\"shrink\") end ) -- 按下 ctrl + cmd + shift + L 进入快速布局 spoon.ModalMgr.supervisor:bind( { \"ctrl\", \"cmd\", \"shift\" }, \"L\", \"Enter FastLayout Environment\", function() spoon.ModalMgr:deactivateAll() spoon.ModalMgr:activate({ \"FastLayout\" }) end ) end --- 应用的快速切换 spoon.ModalMgr:new(\"GoApp\") local cmodal = spoon.ModalMgr.modal_list[\"GoApp\"] cmodal:bind(\"\", \"escape\", \"Deactivate GoApp\", function() spoon.ModalMgr:deactivate({ \"GoApp\" }) end) cmodal:bind(\"shift\", \"/\", \"Toggle Cheatsheet\", function() spoon.ModalMgr:toggleCheatsheet() end) hsapp_list = { { key = \"A\", name = \"Alacritty\" }, { key = \"C\", name = \"Google Chrome\" }, { key = \"W\", name = \"WeChat\" }, { key = \"Y\", name = \"网易有道词典\" }, { key = \"M\", id = \"com.apple.ActivityMonitor\" } } for _, v in ipairs(hsapp_list) do if v.id then local located_name = hs.application.nameForBundleID(v.id) if located_name then cmodal:bind(\"\", v.key, located_name, function() hs.application.launchOrFocusByBundleID(v.id) spoon.ModalMgr:deactivate({ \"GoApp\" }) end) end elseif v.name then cmodal:bind(\"\", v.key, v.name, function() hs.application.launchOrFocus(v.name) spoon.ModalMgr:deactivate({ \"GoApp\" }) end) end end spoon.ModalMgr.supervisor:bind( { \"ctrl\", \"cmd\", \"shift\" }, \"G\", \"Enter GoApp Environment\", function() spoon.ModalMgr:deactivateAll() spoon.ModalMgr:activate({ \"GoApp\" }) end ) --- 当前应用快捷键提示 if spoon.KSheet then spoon.ModalMgr:new(\"KeySheet\") local cmodal = spoon.ModalMgr.mo","date":"2020-03-08","objectID":"/2020/03/hammerspoon/:4:0","tags":["工具"],"title":"Hammerspoon 的使用","uri":"/2020/03/hammerspoon/"},{"categories":null,"content":"参考 Getting Started with Hammerspoon Hammerspoon Spoons Hammerspoon Docs Learn X in Y minutes OrionPax Configuration ","date":"2020-03-08","objectID":"/2020/03/hammerspoon/:5:0","tags":["工具"],"title":"Hammerspoon 的使用","uri":"/2020/03/hammerspoon/"},{"categories":null,"content":"简介 Ranger 是一个类似 Vim 键位的命令行文件管理器。 ","date":"2020-03-07","objectID":"/2020/03/ranger/:1:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"安装 mac 下执行brew install ranger 安装。 ","date":"2020-03-07","objectID":"/2020/03/ranger/:2:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"基础 ?: 查看帮助，ranger 的很多命令按过第一个键就会有相关提示 S: 跳转到当前目录 :: 进入命令模式 ","date":"2020-03-07","objectID":"/2020/03/ranger/:3:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"移动 h、j、k、l、G、gg、/ 等 vim 下的移动命令 m: 新建书签 ': 打开书签 um: 删除书签 ","date":"2020-03-07","objectID":"/2020/03/ranger/:3:1","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"编辑 yy: 复制 dd: 剪切 pp: 粘贴 cw、A、I: 重命名 ","date":"2020-03-07","objectID":"/2020/03/ranger/:3:2","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"其他 zh: 查看隐藏文件 o: 排序，根据提示选择 yn: 复制文件名 yo: 复制文件路径 v: 全选 / 凡选 space: 单选 V: 批量选择 ","date":"2020-03-07","objectID":"/2020/03/ranger/:3:3","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"自定义 以下命令都是自定义的，可以参考配置部分进行设置 cw: 智能重命名，单个文件单个重命名，多选文件批量重命名 md: 创建并进入目录 mf: 创建文件 C: 压缩 X: 取出到 f: 过滤查找当前目录 F: 调用 fzf 查找 ","date":"2020-03-07","objectID":"/2020/03/ranger/:3:4","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"文件预览 Ranger 还支持各种文件类型的预览，但是是可选项需要安装插件，需要用到的可以折腾一下。 ","date":"2020-03-07","objectID":"/2020/03/ranger/:4:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"配置 执行 ranger --copy-config=all 生成配置文件。 执行 echo \"set -g -x RANGER_LOAD_DEFAULT_RC FALSE\" \u003e\u003e ~/.config/fish/config.fish 禁用 Ranger 的默认配置。 根据需要修改 ~/.config/ranger/ 下的配置文件，可以在 commands.py 里添加脚本，并在 rc.conf 文件里配置按键映射使用。 修改~/.config/ranger/refle.conf 搜索Define the \"editor\" ，修改默认编辑器，当然也可以不改。 添加插件 ranger_devicons 为 Ranger 浏览的文件添加图标。 修改 rc.conf 文件 vcs_aware 为 true 为 Ranger 启用 git 提示。更多插件及快捷键设置看下面的参考。 为了支持压缩和解压操作还需执行 brew install atool 和 brew install unzip，安装额外插件。 ","date":"2020-03-07","objectID":"/2020/03/ranger/:5:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"参考 Ranger Wiki Custom Commands Plugins Useful Keybindings My Configuration ","date":"2020-03-07","objectID":"/2020/03/ranger/:6:0","tags":["工具"],"title":"Ranger 命令行下的文件管理器","uri":"/2020/03/ranger/"},{"categories":null,"content":"前言 MacOS 下个人的解决方案为 Alacritty + fishshell + Oh My Fish， 从 zsh 转到 fish 的原因就是因为 zsh 太慢了。Alacritty 是一个跨平台、GPU 增强的终端模拟器，目前还在实验阶段有不少问题，选择它的原因是因为它足够的简单以及出乎意料的快。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:1:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"Alacritty 执行命令安装brew cask install alacritty 下载 配置文件 并将其复制到$HOME/.config/alacritty/alacritty.yml , 你可以在 GitHub releases page 找到最新版本的配置文件。 在配置文件中搜索background_opacity: 1.0 , 修改透明度保存确认配置文件生效 (Alacritty 的配置文件是保存自动生效的） , 然后根据个人需要修改配置文件。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:2:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"新建 Alacritty 应用 新建一个 Alacritty 应用窗口的方式被写成了 Alacritty 的 Action , 可以在配置文件里设置热键。搜索key_bindings , 进行如下设置： key_bindings: - { key: N, mods: Command, action: SpawnNewInstance } ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:2:1","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"字体设置 配置文件里找到 Font configuration , 按需要修改即可。值得一提的是如果使用的是 Powerline 字体的话。符号有可能显示不出来，可以执行 export LANG=zh_CN.UTF-8 或者 set -x LANG zh_CN.UTF-8 修复，为了不用每次都执行需要写到你使用的 shell 的启动配置里，fish 的话是 ~/.config/fish/config.fish 。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:2:2","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"Fish 执行命令brew install fish安装 Fish，将 fish 设置为默认 shell sudo chsh -s /usr/bin/fish。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:3:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"集成功能 语法高亮 智能建议，Ctrl + f 接受建议 Tab 补全，超过一个列出全部供选择 alias，命令别名 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:3:1","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"Oh My Fish 执行curl -L https://get.oh-my.fish | fish 安装 Oh My Fish 管理 fish 插件和切换主题。主题可以参考 Themes。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:4:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"常用命令 omf search : 搜索插件 omf install \u003cname|url\u003e : 安装插件 omf list : 列出已安装插件 omf theme [theme] : 列出所有主题或者切换主题 omf doctor : 自检 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:4:1","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"注意 目前还有不少问题，有问题后先执行omf doctor 自检，按提示走。检查不到问题的就上 Github 瞧瞧。 ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:4:2","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"Powerline fonts / Nerd fonts 好看的字体也是必不可少的，有的主题是必须使用 Powerline 字体或者 Nerd 字体才能正常显示的，执行以下命令： # 为 brew 添加字体库 brew tap homebrew/cask-fonts # 搜索想用的字体 brew search \u003cname\u003e # 安装字体 brew cask install \u003cname\u003e ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:5:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"参考 宇宙第一 fish shell 入门 Powerline fonts Nerd fonts ","date":"2020-03-04","objectID":"/2020/03/mac-terminal/:6:0","tags":["杂谈"],"title":"MacOS 下的终端 + Shell 选择","uri":"/2020/03/mac-terminal/"},{"categories":null,"content":"计算机网络体系结构分层 OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:1:0","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"主要协议 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:2:0","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"IP 协议 按层次分，IP（Internet Protocol）网际协议位于网络层。InternetProtocol 这个名称可能听起来有点夸张，但事实正是如此，因为几乎所有使用网络的系统都会用到 IP 协议。TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半位置，其重要性可见一斑。可能有人会把“IP”和“IP 地址”搞混，“IP”其实是一种协议的名称。 IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:2:1","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"TCP 协议 按层次分，TCP 位于传输层，提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。 为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:2:2","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"DNS 协议 DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如 http://www.badidu.com。 用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。 为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:2:3","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"HTTP 协议 HTTP 协议学习笔记 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:2:4","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"协议之间的关系 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:3:0","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"TCP/IP 的具体含义是？ 从字面意义上讲，有人可能会认为 TCP/IP 是指 TCP 和 IP 两种协议。实际生活当中有时也确实就是指这两种协议。然而在很多情况下，它只是利用 IP 进行通信时所必须用到的协议群的统称。具体来说，IP 或 ICMP、TCP 或 UDP、TELNET 或 FTP、以及 HTTP 等都属于 TCP/IP 协议。他们与 TCP 或 IP 的关系紧密，是互联网必不可少的组成部分。TCP/IP 一词泛指这些协议，因此，有时也称 TCP/IP 为网际协议群。 ","date":"2020-01-08","objectID":"/2020/01/tcp-ip/:4:0","tags":["杂谈"],"title":"什么是TCP/IP","uri":"/2020/01/tcp-ip/"},{"categories":null,"content":"简介 curl 是一种命令行工具，作用是发出网络请求，然后得到和提取数据，显示在\"标准输出”（stdout）上面。 ","date":"2020-01-06","objectID":"/2020/01/curl/:1:0","tags":["工具"],"title":"curl 的使用","uri":"/2020/01/curl/"},{"categories":null,"content":"curl VS Postman 能够快速的进行接口测试。那为什么不选择 Postman ？ Postman 启动太慢了，对于我测试接口来说有些重了。我也不会用到一些 Postman 的其他功能。另外的一点是 Postman 只要自定义的状态码大于 999 ，就会报错（没有相应的描述），我也没有找到解决方案就只能迁移了。还能装 X 何乐而不为呢。 ","date":"2020-01-06","objectID":"/2020/01/curl/:2:0","tags":["工具"],"title":"curl 的使用","uri":"/2020/01/curl/"},{"categories":null,"content":"基础 ","date":"2020-01-06","objectID":"/2020/01/curl/:3:0","tags":["工具"],"title":"curl 的使用","uri":"/2020/01/curl/"},{"categories":null,"content":"常用参数 -b/--cookie \u003cname=string/file\u003e # cookie字符串或文件读取位置 -c/--cookie-jar \u003cfile\u003e # 操作结束后把cookie写入到这个文件中 -d/--data \u003cdata\u003e # HTTP POST方式传送数据 --data-urlencode \u003cname=data/name@filename\u003e # HTTP POST 数据 url 编码 -e/--referer # 来源网址 -H/--header \u003cline\u003e # 自定义头信息传递给服务器 -i/--include # 输出时包括protocol头信息 -I/--head # 只显示请求头信息 -L/--location # 跟随重定向 -o/--output \u003cpath\u003e # 把输出写到该文件中 -O/--remote-name # 把输出写到该文件中，保留远程文件的文件名 -s/--silent # 静默模式。不输出任何东西 -X \u003cmethod\u003e # 修改 request 请求的方法类型 -x/--proxy \u003chost[:port]\u003e # 使用 HTTP 代理 --socks5 \u003chost[:port]\u003e # 使用 socks5 代理 ","date":"2020-01-06","objectID":"/2020/01/curl/:3:1","tags":["工具"],"title":"curl 的使用","uri":"/2020/01/curl/"},{"categories":null,"content":"参考 使用 cURL 代替 Postman curl 网站开发指南 ","date":"2020-01-06","objectID":"/2020/01/curl/:4:0","tags":["工具"],"title":"curl 的使用","uri":"/2020/01/curl/"},{"categories":null,"content":"简介 简单说，SSH 是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用 SSH 协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。 最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995 年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。 需要指出的是，SSH 只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是 OpenSSH，它是自由软件，应用非常广泛。 ","date":"2019-12-31","objectID":"/2019/12/ssh/:1:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"SSH 登录流程 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 ","date":"2019-12-31","objectID":"/2019/12/ssh/:2:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"SSH 解决的问题 计算机间明文通信的安全性问题。 ","date":"2019-12-31","objectID":"/2019/12/ssh/:3:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"什么是中间人攻击？ SSH 之所以能够保证安全，原因在于它采用了公钥加密。这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。 因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wifi 区域），用伪造的公钥，获取用户的登录密码。 再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。这种风险就是著名的”中间人攻击\"（Man-in-the-middle attack）。 ","date":"2019-12-31","objectID":"/2019/12/ssh/:4:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"SSH 如何解决中间人攻击？ 口令登录。如果你是第一次登录对方主机，系统会出现下面类似的提示： $ ssh user@host The authenticity of host 'host (12.18.429.21)' can't be established. RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d. Are you sure you want to continue connecting (yes/no)? 这段话的意思是，无法确认 host 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？ 所谓\"公钥指纹”，是指公钥长度较长（这里采用 RSA 算法，长达 1024 位），很难比对，所以对其进行 MD5 计算，将它变成一个 128 位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。 很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。当远程主机的公钥被接受以后，它就会被保存在文件$HOME/.ssh/known_hosts之中。 下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。每个 SSH 用户都有自己的 known_hosts 文件，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 ","date":"2019-12-31","objectID":"/2019/12/ssh/:5:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"基础 ","date":"2019-12-31","objectID":"/2019/12/ssh/:6:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"ssh # 登录 ssh user@host # 指定端口登录，SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 ssh -p 2222 user@host # 查看已知主机 cat /root/.ssh/known_hosts # 设置自动登陆 ssh-copy-id -i ~/.ssh/id_rsa.pub user@host ","date":"2019-12-31","objectID":"/2019/12/ssh/:6:1","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"scp # scp # 本地复制到远程 scp /home/file.txt user@host:/home/ # 远程复制到本地 scp user@host:/home/file.txt /home/ # 目录复制 scp /home/folder user@host:/home/folder ","date":"2019-12-31","objectID":"/2019/12/ssh/:6:2","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"sftp # sftp # 进入 sftp 命令窗口 sftp user@host # 所有命令前面加l代表本地命令 # cd 路径 更改远程目录到“路径” # lcd 路径 更改本地目录到“路径” # ls [选项] [路径] 显示远程目录列表 # lls [选项] [路径] 显示本地目录列表 # 上传文件 put \u003c本地路径\u003e # 下载文件 get \u003c远程路径\u003e ","date":"2019-12-31","objectID":"/2019/12/ssh/:6:3","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"扩展 ","date":"2019-12-31","objectID":"/2019/12/ssh/:7:0","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"修改 SSH 默认端口 # 本人环境 Ubuntu 19.10，推荐修改完后先测试下能否连接在断开。 # 打开配置文件 vim /etc/ssh/sshd_config # 找到下面这一行默认配置 # Port 22 # 设置修改的端口号 # 保存后重启 ssh 服务 systemctl restart sshd # 检查端口是否以修改成功 ss -ntl ","date":"2019-12-31","objectID":"/2019/12/ssh/:7:1","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"免密登录 # 客户端生成公私钥，有的就不用了 ssh-keygen # 上传公钥到服务器 # 相当于在服务器的 ~/.ssh/authorized_keys 里添加了公钥内容 ssh-copy-id -i ~/.ssh/id_rsa.pub user@host # 之后就可以免密登录了测试下看看吧 ","date":"2019-12-31","objectID":"/2019/12/ssh/:7:2","tags":["工具"],"title":"SSH 命令的使用","uri":"/2019/12/ssh/"},{"categories":null,"content":"简介 Spring Boot是在Spring框架基础上创建的全新框架。相比于以往的一些开发框架，Spring Boot使用更加简单，而且功能更加丰富，性能更加稳定而健壮。Spring Boot的设计目的就是简化开发，让开发者能把更多的精力投入到实际业务中。Spring Boot核心理念是 Convention Over Configuration （约定优于配置）。 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:1:0","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Boot特点 开箱即用，根据项目依赖自动配置。 功能强大的服务体系，如：嵌入式服务、安全、性能指标、健康检查 绝无代码生成，可以不需要任何xml配置（使用Java配置和注解来代替） 对第三方技术几乎完美整合 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:2:0","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"基础 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:3:0","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"如何创建一个 Spring Boot 项目。 访问 Spring Initializr，配置项目的基础设置，并选择项目依赖，点击生成按钮，就可以获取到一个用来初始化项目的压缩包。解压后使用 IDEA 打开即可。 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:3:1","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Hello World 如果项目创建时选择了 Spring Web 依赖，直接创建一个 HelloWorldController 即可，没有的话需要在 pom.xml 里添加 Spring Web 的依赖。 使用 IDEA 启动项目，访问 http://localhost:8080/hello 进行测试。 使用 mvn clean package -Dmaven.test.skip 命令打包并跳过测试，使用 java -jar target\\bagevent-planning-0.0.1-SNAPSHOT.jar 运行 jar 包进行测试。 @RestController public class HelloWorldController { @GetMapping(\"/hello\") public String hello(){ return \"Hello World!\"; } } // 引入Spring Web 依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:3:2","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"应用场景 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:4:0","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"配置数据源 \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003c/dependency\u003e spring.datasource.url=jdbc:mysql://localhost:3306/bagevent?zeroDateTimeBehavior=convertToNull\u0026useUnicode=true\u0026characterEncoding=utf-8\u0026serverTimezone=GMT%2B8 spring.datasource.username=root spring.datasource.password=root ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:4:1","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring 中使用事务 Spring 中的事务传播特性 所谓事务的传播特性是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 Spring 中的事务隔离级别 TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 Spring 中使用编程式事务 Spring提供的最原始的事务管理方式是基于 TransactionDefinition、PlatformTransactionManager、TransactionStatus 编程式事务。而TransactionTemplate的编程式事务管理是使用模板方法设计模式对原始事务管理方式的封装。参考 深入理解TransactionTemplate编程式事务 // Show You Code // 有返回值的使用 TransactionCallback 即可 transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e){ //回滚 transactionStatus.setRollbackOnly(); } } }); Spring 中使用声明式事务 使用 @EnableTransactionManagement 开启事务注解支持。在方法或者类上添加 @Transactional ，在方法内部遇到运行时异常就会回滚了。注意：因为 Spring 声明式事务的实现方式是通过 AOP ，因此只有来自外部的方法调用才会被AOP代理捕获，类内部方法调用本类内部的其他方法并不会引起事务行为。 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 Spring 中使用 AOP 相关常用注解 @EnableAspectJAutoProxy : 开启 AOP 注解扫描 @Aspect : 声明切面 @Pointcut : 指定拦截方法 @Before : 方法执行前执行 @After / @AfterReturning / @AfterThrowing : 方法执行后执行 @Around : 方法执行前后都可以执行 @Order : 切面执行顺序 参考 Spring AOP 开发文档 Pointcut 定义文档 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:4:2","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"扩展 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:0","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Web 相关常用注解 @RestController : 相当于 @Controller + @ResponseBody 两个注解的结合，返回json数据不需要在方法前面加 @ResponseBody 注解了，但使用 @RestController 这个注解，就不能返回 jsp,html 页面，视图解析器无法解析 jsp,html 页面 @RequestMapping @GetMapping : 是一个组合注解是 @RequestMapping(method = RequestMethod.GET) 的缩写 @PostMapping @PutMapping @DeleteMapping @PatchMapping @RequestBody @ResponseBody @ResponseStatus @PathVariable @RequestParam @RequestHeader 参考 相关注解 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:1","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Data JDBC // Show You Code @Slf4j @Repository public class JdbcFooRepository { @Autowired private JdbcTemplate jdbcTemplate; /** * 简单插入 */ public void insertData() { Arrays.asList(\"b\", \"c\").forEach(bar -\u003e { // 插入一条 // 删除、修改操作同样使用 update 方法即可。 jdbcTemplate.update(\"INSERT INTO JdbcFoo (bar) VALUES (?)\", bar); }); } /** * 插入后返回 Id */ public void insertDataReturnId(){ // 插入后返回 id SimpleJdbcInsert simpleJdbcInsert = new SimpleJdbcInsert(jdbcTemplate).withTableName(\"JdbcFoo\").usingGeneratedKeyColumns(\"foo_id\"); HashMap\u003cString, String\u003e row = new HashMap\u003c\u003e(); row.put(\"bar\", \"d\"); Number id = simpleJdbcInsert.executeAndReturnKey(row); log.info(\"foo_id of d: {}\", id.longValue()); } /** * 批量插入 */ public void batchInsert() { NamedParameterJdbcTemplate namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(jdbcTemplate); List\u003cJdbcFoo\u003e list = new ArrayList\u003c\u003e(); list.add(JdbcFoo.builder().bar(\"f\").build()); list.add(JdbcFoo.builder().bar(\"g\").build()); namedParameterJdbcTemplate .batchUpdate(\"INSERT INTO JdbcFoo (bar) VALUES (:bar)\", SqlParameterSourceUtils.createBatch(list)); } /** * 简单查询 */ public List\u003cJdbcFoo\u003e listData() { log.info(\"Count: {}\", jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM JdbcFoo\", Long.class)); List\u003cString\u003e list = jdbcTemplate.queryForList(\"SELECT bar FROM JdbcFoo\", String.class); list.forEach(s -\u003e log.info(\"bar: {}\", s)); List\u003cJdbcFoo\u003e fooList = jdbcTemplate.query(\"SELECT * FROM JdbcFoo\", (rs, rowNum) -\u003e JdbcFoo.builder() .fooId(rs.getLong(1)) .bar(rs.getString(2)) .build()); fooList.forEach(f -\u003e log.info(\"JdbcFoo: {}\", f)); return fooList; } } ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:2","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Data JPA 常用 JPA 注解 实体 @Entity、@MappedSuperclass @Table(name) 主键 @Id @GeneratedValue(strategy, generator) @SequenceGenerator(name, sequenceName) 映射 @Column(name, nullable, length, insertable, updatable) @JoinTable(name)、@JoinColumn(name) 关系 @OneToOne、@OneToMany、@ManyToOne、@ManyToMany @OrderBy ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:3","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Boot Actuator Spring Boot 自带监控功能的 Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、环境变量、日志信息、线程信息等 使用 pom.xml 文件引入依赖 浏览器打开链接 http://localhost:8080/actuator/ 测试 默认支持的只有 info 和 health，需要添加其他 endpoint 配置 management.endpoints.web.exposure.include=* \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e Endpoints ID 描述 auditevents 显示当前应用程序的审计事件信息 beans 显示一个应用中所有Spring Beans的完整列表 conditions 显示配置类和自动配置类(configuration and auto-configuration classes)的状态及它们被应用或未被应用的原因 configprops 显示一个所有@ConfigurationProperties的集合列表 env 显示来自Spring的 ConfigurableEnvironment的属性 flyway 显示数据库迁移路径，如果有的话 health 显示应用的健康信息（当使用一个未认证连接访问时显示一个简单的’status’，使用认证连接访问则显示全部信息详情） info 显示任意的应用信息 liquibase 展示任何Liquibase数据库迁移路径，如果有的话 metrics 展示当前应用的metrics信息 mappings 显示一个所有@RequestMapping路径的集合列表 scheduledtasks 显示应用程序中的计划任务 sessions 允许从Spring会话支持的会话存储中检索和删除(retrieval and deletion)用户会话。使用Spring Session对反应性Web应用程序的支持时不可用。 shutdown 允许应用以优雅的方式关闭（默认情况下不启用） threaddump 执行一个线程dump heapdump 返回一个GZip压缩的hprof堆dump文件 jolokia 通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用） logfile 返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息 prometheus 以可以被Prometheus服务器抓取的格式显示metrics信息 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:4","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Lombok 我们在开发过程中，通常都会定义大量的JavaBean，然后通过IDE去生成其属性的构造器、getter、setter、equals、hashcode、toString方法，当要增加属性或者对某个属性进行改变时，比如命名、类型等，都需要重新去生成上面提到的这些方法。这样重复的劳动没有任何意义，Lombok里面的注解可以轻松解决这些问题。以下是常用相关注解： @Data：注解在类上，将类提供的所有属性都添加get、set方法，并添加、equals、canEquals、hashCode、toString方法 @Setter：注解在类上，为所有属性添加set方法、注解在属性上为该属性提供set方法 @Getter：注解在类上，为所有的属性添加get方法、注解在属性上为该属性提供get方法 @Builder：使用builder模式创建对象 @NotNull：在参数中使用时，如果调用时传了null值，就会抛出空指针异常 @NoArgsConstructor：创建一个无参构造函数 @AllArgsConstructor：创建一个全参构造函数 @RequiredArgsConstructor：会生成一个包含常量，和标识了NotNull的变量的构造方法 @ToString：创建一个toString方法 @Slf4j / @CommonsLog / @Log4j2 @Accessors(chain = true)使用链式设置属性，set方法返回的是this对象 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:5","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring cache abstraction 基本注解 @EnableCaching : 开启 Spring Cache 注解 @EnableCaching(proxyTargetClass = true) @Cacheable : 缓存方法返回结果 @CacheEvict : 缓存清理 @CachePut : 保证方法被调用，又希望结果被缓存。与@Cacheable区别在于是否每次都调用方法，常用于更新。 @CacheConfig : 统一配置本类的缓存注解的属性 参考 史上最全的Spring Boot Cache使用与整合 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:6","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Data Redis Redis Template // Show You Code public Optional\u003cRedisFoo\u003e findOneCacheFooByRedisTemplate(String bar) { String CACHE = RedisFoo.class.getSimpleName(); // 有缓存的话从缓存里取出返回 HashOperations\u003cString, String, RedisFoo\u003e hashOperations = redisFooRedisTemplate.opsForHash(); if (redisFooRedisTemplate.hasKey(CACHE) \u0026\u0026 hashOperations.hasKey(CACHE, bar)) { log.info(\"Get CacheFoo {} from Redis.\", bar); return Optional.ofNullable(hashOperations.get(CACHE, bar)); } Optional\u003cRedisFoo\u003e redisFoo = findOneByBar(bar); // 不为空的话，存到缓存里 if (redisFoo.isPresent()) { log.info(\"Put CacheFoo {} to Redis.\", bar); hashOperations.put(CACHE, bar, redisFoo.get()); redisFooRedisTemplate.expire(CACHE, 1, TimeUnit.MINUTES); } return redisFoo; } Redis Repository // Show You Code // RedisFooCache.java @RedisHash(value = \"RedisFooCache\", timeToLive = 60) @Data @NoArgsConstructor @AllArgsConstructor @Builder public class RedisFooCache { @Id private Long fooId; @Indexed private String bar; private Date createTime; } // RedisFooCacheRepository.java public interface RedisFooCacheRepository extends CrudRepository\u003cRedisFooCache, Long\u003e, QueryByExampleExecutor\u003cRedisFooCache\u003e { } // RedisFooService.java public Optional\u003cRedisFoo\u003e findOneCacheFooByRedisRepository(String bar) { Optional\u003cRedisFooCache\u003e redisFooCache = findOneCacheByBar(bar); if (redisFooCache.isPresent()) { return Optional.of(convertToRedisFoo(redisFooCache.get())); } else { Optional\u003cRedisFoo\u003e redisFoo = findOneByBar(bar); redisFoo.ifPresent(r -\u003e { redisFooCacheRepository.save(convertToRedisFooCache(r)); log.info(\"Save RedisFoo {} to cache.\", r); }); return redisFoo; } } ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:7","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Spring Boot Admin 简介 Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。 应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册（通过HTTP）或使用SpringCloud注册中心（例如Eureka，Consul）发现。 UI是的AngularJs应用程序，展示Spring Boot Admin Client的Actuator端点上的一些监控。 常用的功能 显示健康状况 显示 JVM 和内存指标 显示数据源指标 显示缓存指标 显示构建信息编号 关注并下载日志文件 查看 JVM 系统和环境属性 查看 Spring Boot 配置属性 轻松的日志级管理 与 JMX-beans 交互 查看线程转储 查看 http 跟踪 查看 auditevents 查看 http-endpoints 查看计划任务 查看和删除活动会话（使用spring-session） 下载heapdump 状态变更通知，可以通过自定义的方式发送WeChat通知（通过电子邮件，Slack，Hipchat，……） 状态更改的事件日志（非持久性） 参考 Spring Boot Admin Reference Guide ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:8","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Slf4j + Log4j2 引入依赖时，需要注意的是，需要排除掉 Spring Boot 默认对 Logback 的依赖 pom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-logging\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-log4j2\u003c/artifactId\u003e \u003c/dependency\u003e log4j2-spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cConfiguration status=\"WARN\"\u003e \u003cProperties\u003e \u003cProperty name=\"LOG_EXCEPTION_CONVERSION_WORD\"\u003e%xwEx\u003c/Property\u003e \u003cProperty name=\"LOG_LEVEL_PATTERN\"\u003e%5p\u003c/Property\u003e \u003cProperty name=\"LOG_DATEFORMAT_PATTERN\"\u003eyyyy-MM-dd HH:mm:ss.SSS\u003c/Property\u003e \u003cProperty name=\"CONSOLE_LOG_PATTERN\"\u003e%clr{%d{${LOG_DATEFORMAT_PATTERN}}}{faint} %clr{${LOG_LEVEL_PATTERN}} %clr{%pid}{magenta} %clr{---}{faint} %clr{[%15.15t]}{faint} %clr{%-40.40c{1.}}{cyan} %clr{:}{faint} %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}\u003c/Property\u003e \u003cProperty name=\"FILE_LOG_PATTERN\"\u003e%d{${LOG_DATEFORMAT_PATTERN}} ${LOG_LEVEL_PATTERN} %pid --- [%t] %-40.40c{1.} : %m%n${sys:LOG_EXCEPTION_CONVERSION_WORD}\u003c/Property\u003e \u003cProperty name=\"FILE_LOG_PATH\"\u003e/var/log\u003c/Property\u003e \u003c/Properties\u003e \u003cAppenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\" follow=\"true\"\u003e \u003cPatternLayout pattern=\"${sys:CONSOLE_LOG_PATTERN}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFileInfo\" fileName=\"${sys:FILE_LOG_PATH}/info/info.log\" filePattern=\"${sys:FILE_LOG_PATH}/info/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log\"\u003e \u003cThresholdFilter level=\"info\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/\u003e \u003cPatternLayout pattern=\"${sys:FILE_LOG_PATTERN}\"/\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"24\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"100 MB\"/\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e \u003cRollingFile name=\"RollingFileWarn\" fileName=\"${sys:FILE_LOG_PATH}/warn/warn.log\" filePattern=\"${sys:FILE_LOG_PATH}/warn/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log\"\u003e \u003cThresholdFilter level=\"warn\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/\u003e \u003cPatternLayout pattern=\"${sys:FILE_LOG_PATTERN}\"/\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"24\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"100 MB\"/\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e \u003cRollingFile name=\"RollingFileError\" fileName=\"${sys:FILE_LOG_PATH}/error/error.log\" filePattern=\"${sys:FILE_LOG_PATH}/error/$${date:yyyy-MM}/warn-%d{yyyy-MM-dd}-%i.log\"\u003e \u003cThresholdFilter level=\"error\" onMatch=\"ACCEPT\" onMismatch=\"DENY\"/\u003e \u003cPatternLayout pattern=\"${sys:FILE_LOG_PATTERN}\"/\u003e \u003cPolicies\u003e \u003cTimeBasedTriggeringPolicy modulate=\"true\" interval=\"24\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"100 MB\"/\u003e \u003c/Policies\u003e \u003c/RollingFile\u003e \u003c/Appenders\u003e \u003cLoggers\u003e \u003cLogger name=\"org.apache.catalina.startup.DigesterFactory\" level=\"error\" /\u003e \u003cLogger name=\"org.apache.catalina.util.LifecycleBase\" level=\"error\" /\u003e \u003cLogger name=\"org.apache.coyote.http11.Http11NioProtocol\" level=\"warn\" /\u003e \u003clogger name=\"org.apache.sshd.common.util.SecurityUtils\" level=\"warn\"/\u003e \u003cLogger name=\"org.apache.tomcat.util.net.NioSelectorPool\" level=\"warn\" /\u003e \u003cLogger name=\"org.eclipse.jetty.util.component.AbstractLifeCycle\" level=\"error\" /\u003e \u003cLogger name=\"org.hibernate.validator.internal.util.Version\" level=\"warn\" /\u003e \u003clogger name=\"org.springframework.boot.actuate.endpoint.jmx\" level=\"warn\"/\u003e \u003cRoot level=\"info\"\u003e \u003cAppenderRef ref=\"Console\" /\u003e \u003cAppenderRef ref=\"RollingFileInfo\"/\u003e \u003cAppenderRef ref=\"RollingFileWarn\"/\u003e \u003cAppenderRef ref=\"RollingFileError\"/\u003e \u003c/Root\u003e \u003c/Loggers\u003e \u003c/Configuration\u003e 参考 聊一聊log4j2配置文件log4j2.xml ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:9","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"Swagger @Api：用在请求的类上，表示对类的说明 tags=\"说明该类的作用，可以在UI界面上看到的注解\" value=\"该参数没什么意义，在UI界面上也看到，所以不需要配置\" @ApiOperation：用在请求的方法上，说明方法的用途、作用 value=\"说明方法的用途、作用\" notes=\"方法的备注说明\" @ApiImplicitParams：用在请求的方法上，表示一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 name：参数名 value：参数的汉字说明、解释 required：参数是否必须传 paramType：参数放在哪个地方 · header --\u003e 请求参数的获取：@RequestHeader · query --\u003e 请求参数的获取：@RequestParam · path（用于restful接口）--\u003e 请求参数的获取：@PathVariable · body（不常用） · form（不常用） dataType：参数类型，默认string · string · number · integer · boolean · array · object defaultValue：参数的默认值 @ApiResponses：用在请求的方法上，表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如\"请求参数没填好\" response：抛出异常的类 @ApiModel：用于响应类上，表示一个返回响应数据的信息 （这种一般用在post创建的时候，使用@RequestBody这样的场景， 请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：用在属性上，描述响应类的属性 ","date":"2019-11-22","objectID":"/2019/11/spring-boot/:5:10","tags":["框架"],"title":"Spring Boot 的使用","uri":"/2019/11/spring-boot/"},{"categories":null,"content":"优劣对比 名称 性能 开发效率 接入成本 原生兼容性 多端支持 状态管理 样式支持 TypeScript 校验程度 成熟程度 更新频率 Issues(open/closed) Star 原生 最高 最低 中等 - 不支持 不支持 wxss 不支持 最低 成熟 高 - - 内嵌 最低 最高 最低 不兼容 - - - - - - - - - Taro 中等 较高 较低 中等 中等 Redux、Mbox、Dva sass、less、CSS Moudle 支持 中等 较高 高 594 / 3274 22.2k wepy 中等 中等 较高 较高 较低 Redux sass、less 勉强支持 较低 较高 高 267 / 1638 19.1k mpvue 中等 中等 中等 中等 较低 vuex sass、less 勉强支持 较低 较高 高 374 / 1237 19k mpx 中等 中等 中等 较高 中等 vuex sass、less 支持 中等 较低 高 11 / 148 1.8k chameleon 中等 较低 中等 较低 较高 vuex sass、less 不支持 中等 较低 高 47 / 191 6.7k uni-app 中等 较高 中等 中等 中等 vuex sass、less 支持 中等 中等 高 193 / 609 13.7k 排除使用原生小程序和内嵌 web 的解决方案后各框架对比: 开发效率: 得益于 Typescript 对 JSX 的支持，Taro 在编写组件时可以获得更好的自动补全。 接入成本: Taro 采用 React 规范，学习成本低一点。 原生兼容性: 混写代码的情况下 wepy 和 mpx 提供了更好的原生代码的支持。 多端支持: chameleon 有一套自研的多态协议，uni-app 和 Taro 则是都在 H5 实现了一套兼容的组件库和 API，mpvue 和 WePY 都提供了转换各端小程序的功能，但都没有 h5 和移动端的支持。 组件库/工具库/Demo: uni-app \u003e WePY \u003e Taro \u003e mpvue \u003e chameleon、mpx。uni-app 有自己的 IDE 且是国人团队开发的。 流行程度: uni-app 号称有上万案例，有 30+ 个 QQ 交流群（最大人数 2000）。紧跟其后的为 Taro、mpvue、WePY。 开源建设: 从第三方贡献者数量来看，Taro 在这一方面领先，并且 Taro 的一些核心包/功能（MobX、CSS Modules、alias）也是由第三方开发者贡献的。WePY 作为其中开源最早的框架紧随其后。mpvue 由于停滞开发了很久就比较落后了。uni-app 在开源建设上并不热心，甚至有些部分代码都没有开源。 ","date":"2019-10-16","objectID":"/2019/10/mini-progarm/:1:0","tags":["杂谈"],"title":"Mini Progarm 技术选型","uri":"/2019/10/mini-progarm/"},{"categories":null,"content":"前言 本文已过时。现在个人的解决方案为 Windows Terminal + fishshell + Oh My Fish， 从 zsh 转到 fish 的原因就是因为 zsh 太慢了。 WIN10 命令行工具最终选择了 WSL + Ubuntu + Terinus + Oh My Zsh。在 Hyper 和 Terminus 之前选择了 Terminus，只是因为 Terminus 模糊透明真的好看，一位伟人曾经说过好看就是第一生产力。 ","date":"2019-10-10","objectID":"/2019/10/windows-terminal/:1:0","tags":["工具"],"title":"WIN10 下终端解决方案","uri":"/2019/10/windows-terminal/"},{"categories":null,"content":"搭建 启用 WSL ，管理员运行 PowerShell ，执行 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 去 Microsoft Store 搜索 WSL 下载一个，推荐选择 Ubuntu 初始化 Ubuntu 系统 使用 Scoop 安装 Terminus scoop install terminus 修改 Terminus 配置，Shell -\u003e Profile 选择 WSL / Ubuntu 。样式上就按自己的需求改 安装 zsh ，sudo apt udpate \u0026\u0026 sudo apt install -y zsh 安装 Oh My Zsh ，sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 设置 zsh 为默认 shell ，chsh -s $(which zsh) 修改 zsh 的主题并添加需要的插件 ","date":"2019-10-10","objectID":"/2019/10/windows-terminal/:2:0","tags":["工具"],"title":"WIN10 下终端解决方案","uri":"/2019/10/windows-terminal/"},{"categories":null,"content":"WSL 的 PATH 会包含 WIN10 的 PATH 问题 // 两个系统里存在的同名的命令就会有问题 sudo vim ~/.bashrc // 追加 PATH=$(/usr/bin/printenv PATH | /usr/bin/perl -ne 'print join(\":\", grep { !/\\/mnt\\/[a-z]/ } split(/:/));') ","date":"2019-10-10","objectID":"/2019/10/windows-terminal/:3:0","tags":["工具"],"title":"WIN10 下终端解决方案","uri":"/2019/10/windows-terminal/"},{"categories":null,"content":"参考 打造 Windows 10 下最强终端方案：WSL + Terminus + Oh My Zsh + The Fuck Hyper.js + Oh My ZSH as Ubuntu on Windows (WSL) Terminal ","date":"2019-10-10","objectID":"/2019/10/windows-terminal/:4:0","tags":["工具"],"title":"WIN10 下终端解决方案","uri":"/2019/10/windows-terminal/"},{"categories":null,"content":"简介 Nest 是一个用于构建高效，可扩展的 Node.js 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 TypeScript（但仍然允许开发人员使用纯 JavaScript 编写代码）并结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。 ","date":"2019-09-28","objectID":"/2019/09/nest/:1:0","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"安装 // 安装 Nest yarn global add @nestjs/cli // 初始化项目 nest new \u003cproject-name\u003e ","date":"2019-09-28","objectID":"/2019/09/nest/:2:0","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"基础 ","date":"2019-09-28","objectID":"/2019/09/nest/:3:0","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"控制器 控制器层负责处理传入的请求, 并返回对客户端的响应。使用 @Controller 进行装饰。 HTTP 请求装饰器 @Get()、 @Post、 @Put() 、 @Delete()、 @Patch()、 @Options()、 @Head()和 @All()。 Request 对象 「Request」对象表示 HTTP 请求，并具有「Request」查询字符串，参数，HTTP 标头 和 正文的属性（在这里阅读更多），但在大多数情况下, 不必手动获取它们。 我们可以使用专用的装饰器，比如开箱即用的 @Body() 或 @Query() 。 下面是装饰器和 普通表达对象的比较。 装饰器 对象 @Request() req @Response() res @Next() next @Session() req.session @Param(key?: string) req.params / req.params[key] @Body(key?: string) req.body / req.body[key] @Query(key?: string) req.query / req.query[key] @Headers(name?: string) req.headers / req.headers[name] 路由注册顺序 请注意，路由注册顺序（每个路由的函数在类中出现的顺序）很重要。假设您有一个通过 identifier（cats/:id）返回 cat 的路由。如果在类定义中注册另一个端点，它会立即返回所有 cat（cats），则 GET /cats 请求不会命中第二个处理程序，因为所有路由参数都是可选的。简而言之就是把精确路由放在模糊路由下面。请参阅以下示例： @Controller('cats') export class CatsController { @Get(':id') findOne(@Param('id') id: string) { return `This action returns a #${id} cat`; } @Get() findAll() { // This endpoint will never get called // because the \"/cats\" request is going // to be captured by the \"/cats/:id\" route handler } } ","date":"2019-09-28","objectID":"/2019/09/nest/:3:1","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"提供者 几乎所有的东西都可以被认为是提供者 - service, repository, factory, helper 等等。他们都可以通过 constructor 注入依赖关系，也就是说，他们可以创建各种关系。但事实上，提供者不过是一个用@Injectable() 装饰器注解的类。 // 创建提供者 @Injectable() export class CatsService {...} // 注册提供者 @Module({ controllers: [CatsController], providers: [CatsService], }) // 使用提供者 @Controller('cats') export class CatsController { // CatsService 通过类构造函数注入。不要害怕 private readonly 缩短的语法。这意味着我们已经在同一位置创建并初始化了 catsService 成员。 constructor(private readonly catsService: CatsService) {} ... } ","date":"2019-09-28","objectID":"/2019/09/nest/:3:2","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"模块 模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。 @module() 装饰器接受一个描述模块属性的对象： key 作用 providers 由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享 controllers 必须创建的一组控制器 imports 导入模块的列表，这些模块导出了此模块中所需提供者 exports 由本模块提供并应在其他模块中可用的提供者的子集。 默认情况下, 模块封装提供者。这意味着如果提供者如果不是当前模块的一部分, 也不是从另外已导入的模块导出的，那么它就是无法注入的。 ","date":"2019-09-28","objectID":"/2019/09/nest/:3:3","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"中间件 中间件是一个在路由处理器之前被调用的函数。 中间件函数可以访问请求和响应对象，以及应用程序请求响应周期中的 next() 中间件函数。 next() 中间件函数通常由名为 next 的变量表示。Nest 中间件实际上等价于 express 中间件。 下面是 Express 官方文档中所述的中间件功能： 中间件函数可以执行以下任务: 执行任何代码。 对请求和响应对象进行更改。 结束请求-响应周期。 调用堆栈中的下一个中间件函数。 如果当前的中间件函数没有结束请求-响应周期, 它必须调用 next() 将控制传递给下一个中间件函数。否则, 请求将被挂起。 创建中间件 Nest 中间件可以是一个函数，也可以是一个带有 @Injectable() 装饰器的类。 这个类应该实现 NestMiddleware 接口, 而函数没有任何特殊的要求。 @Injectable() export class LoggerMiddleware implements NestMiddleware { use(req: Request, res: Response, next: Function) { console.log('Request...'); next(); } } 应用中间件 中间件不能在 @Module() 装饰器中列出。我们必须使用模块类的 configure() 方法来设置它们。包含中间件的模块必须实现 NestModule 接口。我们将 LoggerMiddleware 设置在 ApplicationModule 层上。 @Module({ imports: [CatsModule], }) export class ApplicationModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer .apply(LoggerMiddleware) .forRoutes('cats'); } } 中间件消费者 MiddlewareConsumer 是一个帮助类。它提供了几种内置方法来管理中间件。他们都可以被简单地链接起来。在 forRoutes() 可接受一个字符串、多个字符串、对象、一个控制器类甚至多个控制器类。在大多数情况下，您可能只会传递一个由逗号分隔的控制器列表。 函数式中间件 export function logger(req, res, next) { console.log(`Request...`); next(); }; 多个中间件 consumer.apply(cors(), helmet(), logger).forRoutes(CatsController); 全局中间件 const app = await NestFactory.create(ApplicationModule); // 为了一次将中间件绑定到每个注册路由，我们可以利用实例 INestApplication 提供的方法 use() app.use(logger); await app.listen(3000); ","date":"2019-09-28","objectID":"/2019/09/nest/:3:4","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"扩展 ","date":"2019-09-28","objectID":"/2019/09/nest/:4:0","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"异常过滤器 内置的异常层负责处理整个应用程序中的所有抛出的异常。当捕获到未处理的异常时，最终用户将收到友好的响应。 ","date":"2019-09-28","objectID":"/2019/09/nest/:4:1","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"管道 管道是具有 @Injectable() 装饰器的类。管道应实现 PipeTransform 接口。管道将输入数据转换为所需的输出。另外，它可以处理验证，因为当数据不正确时可能会抛出异常。 内置管道 Nest 自带两个开箱即用的管道，即 ValidationPipe 和 ParseIntPipe。他们从 @nestjs/common 包中导出。 类验证器（Class validator） Nest 与 class-validator 配合得很好。这个优秀的库允许您使用基于装饰器的验证。基于装饰器的验证对于管道功能非常强大，因为我们可以访问已处理属性的 metatype。在我们开始之前，我们需要安装所需的软件包。 yarn add class-validator class-transformer 安装完成后，我们就可以向 CreateCatDto 类添加一些装饰器。 import { IsString, IsInt } from 'class-validator'; export class CreateCatDto { @IsString() readonly name: string; @IsInt() readonly age: number; @IsString() readonly breed: string; } 最后一步是设置 ValidationPipe 。管道，与异常过滤器相同，它们可以是方法范围的、控制器范围的和全局范围的。另外，管道可以是参数范围的。我们可以直接将管道实例绑定到路由参数装饰器，例如@Body()。让我们来看看下面的例子： @Post() async create(@Body(new ValidationPipe()) createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } 当验证逻辑仅涉及一个指定的参数时，参数范围的管道非常有用。要在方法级别设置管道，您需要使用 UsePipes() 装饰器。 @Post() @UsePipes(ValidationPipe) async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } 由于 ValidationPipe 被创建为尽可能通用，所以我们将把它设置为一个全局作用域的管道，用于整个应用程序中的每个路由处理器。 async function bootstrap() { const app = await NestFactory.create(ApplicationModule); app.useGlobalPipes(new ValidationPipe()); await app.listen(3000); } bootstrap(); ","date":"2019-09-28","objectID":"/2019/09/nest/:4:2","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"守卫 守卫是一个使用 @Injectable() 装饰器的类。 守卫应该实现 CanActivate 接口。守卫有一个单独的责任。它们确定请求是否应该由路由处理程序处理。到目前为止，访问限制逻辑大多在中间件内。这样很好，因为诸如 token 验证或将 request 对象附加属性与特定路由没有强关联。但中间件是非常笨的。它不知道调用 next() 函数后会执行哪个处理程序。另一方面，守卫可以访问 ExecutionContext 对象，所以我们确切知道将要执行什么。守卫在每个中间件之后执行的，但在拦截器和管道之前。 授权看守卫 import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; @Injectable() export class AuthGuard implements CanActivate { canActivate( context: ExecutionContext, ): boolean | Promise\u003cboolean\u003e | Observable\u003cboolean\u003e { const request = context.switchToHttp().getRequest(); return validateRequest(request); } } 不管 validateRequest() 函数背后的逻辑是什么，重点是展示使用守卫是多么简单。每个守卫都提供一个 canActivate() 方法。守卫可能通过 (Promise 或 Observable) 同步地或异步地返回它的布尔答复。如果返回 true, 将处理用户调用。如果返回 false, 则 Nest 将忽略当前处理的请求。 Execution context ExecutionContext 提供了更多功能，它扩展了 ArgumentsHost，但是也提供了有关当前执行过程的更多详细信息。getHandler() 方法返回对当前处理的处理程序的引用,而 getClass() 返回此特定处理程序所属的 Controller 类的类型。用另外的话来说,如果用户指向在 CatsController 中定义和注册的 create() 方法, getHandler() 将返回对 create() 方法的引用，在这种情况下, getClass() 将只返回一个 CatsController 的类型（不是实例）。 基于角色的认证 创建自定义角色装饰器 import { SetMetadata } from '@nestjs/common'; // SetMetadata() 附加自定义元数据的功能 export const Roles = (...roles: string[]) =\u003e SetMetadata('roles', roles); 使用角色装饰器 @Post() @Roles('admin') async create(@Body() createCatDto: CreateCatDto) { this.catsService.create(createCatDto); } 创建角色认证守卫 import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common'; import { Observable } from 'rxjs'; import { Reflector } from '@nestjs/core'; @Injectable() export class RolesGuard implements CanActivate { constructor(private readonly reflector: Reflector) {} canActivate(context: ExecutionContext): boolean { // getHandler() 将返回对 create() 方法的引用 // 使用反射器获取方法元数据 const roles = this.reflector.get\u003cstring[]\u003e('roles', context.getHandler()); if (!roles) { return true; } const request = context.switchToHttp().getRequest(); const user = request.user; const hasRole = () =\u003e user.roles.some((role) =\u003e roles.includes(role)); return user \u0026\u0026 user.roles \u0026\u0026 hasRole(); } } 绑定守卫 守卫可以是控制器范围的，方法范围的和全局范围的。为了建立守卫，我们使用 @UseGuards() 装饰器。这个装饰器可以有无数的参数，也就是说，你可以传递几个守卫并用逗号分隔它们。 // 绑定到 Controller @Controller('cats') @UseGuards(RolesGuard) export class CatsController {} // 绑定到全局 const app = await NestFactory.create(ApplicationModule); app.useGlobalGuards(new RolesGuard()); ","date":"2019-09-28","objectID":"/2019/09/nest/:4:3","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"拦截器 拦截器是使用 @Injectable() 装饰器注解的类。拦截器应该实现 NestInterceptor 接口。 ","date":"2019-09-28","objectID":"/2019/09/nest/:4:4","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"自定义装饰器 Nest 是基于装饰器这种语言特性而创建的。ES2016 的装饰器是一个可以将目标对象，名称和属性描述符作为参数的返回函数的表达式。你可以通过装饰器前缀 @ 来使用它，并且把它放在你试图装饰的顶部。装饰器可以被定义为一个类或是属性。 参数装饰器 在 node.js 的世界中，把属性值附加到 request 对象中是一种很常见的做法。然后你可以在任何时候在路由处理程器（route handlers）中手动取到它们，例如，使用下面这个构造： const user = req.user; 为了使其更具可读性和透明性，我们可以创建 @User() 装饰器并且在所有控制器中重复利用它。 import { createParamDecorator } from '@nestjs/common'; export const User = createParamDecorator((data, req) =\u003e { return req.user; }); @Get() async findOne(@User() user: UserEntity) { console.log(user); } ","date":"2019-09-28","objectID":"/2019/09/nest/:4:5","tags":["框架"],"title":"Nest 的使用","uri":"/2019/09/nest/"},{"categories":null,"content":"简介 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:1:0","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"基础 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:2:0","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"全局对象、变量、函数 全局对象 global : 表示 Node 所在的全局环境 process : 该对象表示 Node 所处的当前进程，允许开发者与该进程互动。 console : 指向 Node 内置的 console 模块，提供命令行环境中的标准输入、标准输出功能。 全局方法 setTimeout() clearTimeout() setInterval() clearInterval() require() Buffer() 简介 : Buffer 对象是 Node 处理二进制数据的一个接口。它是 Node 原生提供的全局对象。JavaScript 比较擅长处理字符串，对于处理二进制数据，就不太擅长，比如 TCP 数据流。Buffer 对象就是为了解决这个问题而设计的。它是一个构造函数，生成的实例代表了 V8 引擎分配的一段内存，是一个类似数组的对象，成员都为 0 到 255 的整数值，即一个 8 位的字节。 write() : write 方法可以向指定的 Buffer 对象写入数据。它的第一个参数是所写入的内容，第二个参数（可省略）是所写入的起始位置（默认从 0 开始），第三个参数（可省略）是编码方式，默认为 utf8。 slice() : slice 方法返回一个按照指定位置、从原对象切割出来的 Buffer 实例。它的两个参数分别为切割的起始位置和终止位置。 toString() : toString 方法将 Buffer 实例，按照指定编码（默认为 utf8）转为字符串。 toJSON() : toJSON 方法将 Buffer 实例转为 JSON 对象。如果 JSON.stringify 方法调用 Buffer 实例，默认会先调用 toJSON 方法。 全局变量 __filename : 指向当前运行的脚本文件名。 __dirname : 指向当前运行的脚本所在的目录。 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:2:1","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"常用标准库 http 模块 创建 Web 服务器 const http = require('http'); const hostname = '127.0.0.1'; const port = 3000; //创建HTTP服务器 const server = http.createServer((req, res) =\u003e { res.statusCode = 200; res.setHeader('Content-Type', 'text/plain'); res.end('Hello World\\n'); }); //监听指定地址下的指定端口并设置触发事件 server.listen(port, hostname, () =\u003e { console.log(`Server running at http://${hostname}:${port}/`); }); 模拟请求 const http = require('http'); const querystring = require('querystring'); //封装请求参数 const data = querystring.stringify({ 'msg': 'Hello World!' }); const options = { hostname: 'localhost', port: 9988, path: '/api/v2/product/optest', method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': Buffer.byteLength(data) } }; //创建请求对象并绑定相关事件处理方法 const req = http.request(options, (res) =\u003e { console.log(`状态码: ${res.statusCode}`); res.on('data', (chunk) =\u003e { console.log(`响应主体: ${chunk}`); }); res.on('end', () =\u003e { console.log('响应中已无数据'); }); }); req.on('error', (e) =\u003e { console.error(`请求遇到问题: ${e.message}`); }); //写入请求数据 req.write(data); req.end(); querystring 模块 对象转 URL 参数字符串 querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' }); // 返回 'foo=bar\u0026baz=qux\u0026baz=quux\u0026corge=' querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':'); // 返回 'foo:bar;baz:qux' URL 参数字符串转对象 querystring.parse(\"foo=bar\u0026abc=xyz\u0026abc=123\"); // 返回 { foo: 'bar', abc: ['xyz', '123'] } 对象 url 模块 解析 URL exports.startServer = (route, handle) =\u003e { http .createServer((req, res) =\u003e { //解析URL 获取访问接口路径 var pathname = url.parse(req.url).pathname; route(handle, pathname, res, req); }) .listen(8888, hostname, () =\u003e { console.log(`Server running at http://${hostname}:${port}/`); }); }; fs 模块 读文件 //readFile方法的第一个参数是文件的路径，可以是绝对路径，也可以是相对路径。注意，如果是相对路径，是相对于当前进程所在的路径（process.cwd()），而不是相对于当前脚本所在的路径。 //readFile方法的第二个参数是读取完成后的回调函数。该函数的第一个参数是发生错误时的错误对象，第二个参数是代表文件内容的Buffer实例。 fs.readFile(\"./image.png\", function(err, buffer) { if (err) throw err; process(buffer); }); //readFileSync方法的第一个参数是文件路径，第二个参数可以是一个表示配置的对象，也可以是一个表示文本文件编码的字符串。默认的配置对象是{encoding: null, flag: 'r'}，即文件编码默认为null，读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回一个Buffer实例，否则返回的是一个字符串。 var text = fs.readFileSync(fileName, \"utf8\"); 写文件 //writeFile方法的第一个参数是写入的文件名，第二个参数是写入的字符串，第三个参数是回调函数。回调函数前面，还可以再加一个参数，表示写入字符串的编码（默认是utf8）。 fs.writeFile(\"message.txt\", \"Hello Node.js\", err =\u003e { if (err) throw err; console.log(\"It's saved!\"); }); //writeFileSync方法用于同步写入文件。它的第一个参数是文件路径，第二个参数是写入文件的字符串，第三个参数是文件编码，默认为utf8。 fs.writeFileSync(fileName, str, \"utf8\"); 新建目录 //mkdir接受三个参数，第一个是目录名，第二个是权限值，第三个是回调函数。 var fs = require(\"fs\"); fs.mkdir(\"./helloDir\", 0777, function(err) { if (err) throw err; }); 判断文件还是目录 var fs = require(\"fs\"); //stat方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。我们往往通过该方法，判断正在处理的到底是一个文件，还是一个目录。 fs.readdir(\"/etc/\", function(err, files) { if (err) throw err; files.forEach(function(file) { fs.stat(\"/etc/\" + file, function(err, stats) { if (err) throw err; if (stats.isFile()) { console.log(\"%s is file\", file); } else if (stats.isDirectory()) { console.log(\"%s is a directory\", file); } console.log(\"stats: %s\", JSON.stringify(stats)); }); }); }); 监听文件变化 var fs = require(\"fs\"); //watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 fs.watchFile(\"./testFile.txt\", function(curr, prev) { console.log(\"the current mtime is: \" + curr.mtime); console.log(\"the previous mtime was: \" + prev.mtime); }); fs.writeFile(\"./testFile.txt\", \"changed\", function(err) { if (err) throw err; console.log(\"file write complete\"); }); 使用输入输出流实现大文件 Copy function fileCopy(filename1, filename2, done) { var input = fs.createReadStream(filename1); var output = fs.createWriteStream(filename2); input.on(\"data\", function(d) { output.write(d); }); input.on(\"error\", function(err) { throw err; }); input.on(\"end\", function() { output.end(); }); } events 模块 简介 : 回调函数模式让 Node 可以处理异步操作。但是，为了适应回调函数，异步操作只能有两个状态：开始和结束。对于那些多状态的异步操作（状态 1，状态 2，状态 3，……），回调函数就会无法处理，你不得不将异步操作拆开，分成多个阶段。每个阶段结束时，调用下一个回调函数。为了解决这个问题，Node 提供 Event Emitter 接口。通过事件，解决多状态异步操作的响应问题。 EventEmitt","date":"2019-09-23","objectID":"/2019/09/nodejs/:2:2","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"扩展 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:3:0","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"Node 模块系统 概述 Node.js 采用模块化结构，按照 CommonJS 规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。 什么是模块化？ 存在文件作用域 存在通信规则 加载(require) 导出(module.exports) 导出 exports node 中每个 js 文件，都有一个 module 对象，其 exports 属性相当于其暴露的接口对象。可以使用module.exports.xxx = xxx添加向外暴露的接口。如果一个文件只向外暴露一个方法或者其他类型的属性，可以直接使用module.exports = xxx。注意在 Node 解释 js 文件时，会在其头部加上隐式的let exports = module.exports因此只要不改变指针指向的情况下，可以使用export代替module.exports。 加载 require 加载规则 会执行加载模块中的代码 重复 require，不会执行模块中的代码，仅能拿到module.exports接口对象。 模块标识 核心模块 被编译到二进制文件中，直接使用名字加载。 第三方模块 凡是第三方模块都需要使用 npm 来下载 加载的时候使用require(’packageName’) 加载的文件的位置在node_modules/packageName/package.json 中{”main”:”加载文件“} 没有配置加载文件的情况会默认为index.js node_modules文件夹会从当前文件所在路径，向上迭代查找使用最近的一个。 自定义模块 ./开头，代表当前路径,不可省。 ../开头，代表上级路径,不可省。 引入时.js后缀可省 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:3:1","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"事件轮询 工作流程 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:3:2","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"包管理 NPM npm init 生成package.json文件 -y 跳过向导 npm install 将package.json文件中的依赖项全部安装 npm install \u003cpackageName\u003e 安装第三方模块到node_modules —-save 将安装第三方模块信息，添加到package.json文件的依赖项中。 npm help 查看帮助文档 Yarn yarn install 将package.json文件中的依赖项全部安装 yarn add \u003cpackageName\u003e 安装第三方模块到node_modules，并且包第三方模块信息添加到package.json文件中 yarn global add \u003cpackageName\u003e 安装到全局 package.json文件 Node 项目的项目描述文件，参考package.json 常用文件参数，各参数见名知意。 写 CLI #!/usr/bin/env node 指定解释器 npm link 创建软链放到环境变量 package.json 里添加 bin 属性 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:3:3","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"参考 NPM 官网 所有第三方模块都可以在此网站搜查看相关信息。 Yarn 官网 最佳实践 深入浅出 NodeJs 模块机制 CommonJS 规范 What is the Event Loop? Node.js 的事件循环工作流程以及生命周期的详细讲解 ","date":"2019-09-23","objectID":"/2019/09/nodejs/:4:0","tags":["框架"],"title":"Node.js 知识总结","uri":"/2019/09/nodejs/"},{"categories":null,"content":"简介 除了个人搭建梯子的方式，还可以选用各大主流机场或者小型机场。 ","date":"2019-09-23","objectID":"/2019/09/ladder/:1:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"前置条件 服务器：上搬瓦工、Vultr 或者其他 VPS 厂商买个服务器 SSH 客户端: 直接用命令也行，对 ssh 命令不熟悉的可以使用 XShell 作为客户端。 域名：使用 Trajan 的话，还需要用来伪装的域名。 ","date":"2019-09-23","objectID":"/2019/09/ladder/:2:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"SSR 下载一键搭建脚本 git clone -b master https://github.com/flyzy2005/ss-fly. 运行 SSR 搭建脚本 ss-fly/ss-fly.sh -ssr. 输入对应参数 客户端下载并配置 # 相关命令 启动：/etc/init.d/shadowsocks start 停止：/etc/init.d/shadowsocks stop 重启：/etc/init.d/shadowsocks restart 状态：/etc/init.d/shadowsocks status 配置文件路径：/etc/shadowsocks.json 日志文件路径：/var/log/shadowsocks.log 代码安装目录：/usr/local/shadowsocks ","date":"2019-09-23","objectID":"/2019/09/ladder/:3:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"V2Ray 下载一键搭建脚本 bash \u003c(curl -s -L https://git.io/v2ray.sh). 输入对应参数 客户端下载并配置 ","date":"2019-09-23","objectID":"/2019/09/ladder/:4:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"Trajan 配置域名映射，将二级域名地址映射到 VPS 服务器 IP 地址。 执行脚本并输入相应参数 wget -N --no-check-certificate \"https://raw.githubusercontent.com/V2RaySSR/Trojansh/master/trojan1.sh\" \u0026\u0026 chmod +x trojan1.sh \u0026\u0026 ./trojan1.sh wget -N --no-check-certificate \"https://raw.githubusercontent.com/V2RaySSR/Trojansh/master/trojan2.sh\" \u0026\u0026 chmod +x trojan2.sh \u0026\u0026 ./trojan2.sh wget -N --no-check-certificate \"https://raw.githubusercontent.com/V2RaySSR/Trojansh/master/trojan3.sh\" \u0026\u0026 chmod +x trojan3.sh \u0026\u0026 ./trojan3.sh wget -N --no-check-certificate \"https://github.com/ylx2016/Linux-NetSpeed/releases/download/sh/tcp.sh\" \u0026\u0026 chmod +x tcp.sh \u0026\u0026 ./tcp.sh 客户端下载并配置 ","date":"2019-09-23","objectID":"/2019/09/ladder/:5:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"客户端 客户端有很多根据自己喜欢的来吧。 shadowsocks-windows v2rayN Clash ","date":"2019-09-23","objectID":"/2019/09/ladder/:6:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"参考 搬瓦工一键搭建 shadowsocks-shadowsocksR 并开启 BBR 加速 V2Ray 搭建详细图文教程 试试最新的Trojan一键脚本 ","date":"2019-09-23","objectID":"/2019/09/ladder/:7:0","tags":["方法"],"title":"如何科学上网","uri":"/2019/09/ladder/"},{"categories":null,"content":"简介 一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 ","date":"2019-08-29","objectID":"/2019/08/git/:1:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"Git 的三种对象 commit 对象 用于表示一个提交 commit 对象之间会组织成一棵树的结构 每一次提交都会产生一个 commit 对象 除了第一次提交产生的 commit 对象，其它的 commit 对象都会有父亲 commit 对象 如果只是提交操作，则父亲节点只有 1 个 如果是 merge 操作，则父亲节点会有 2 个 commit 对象包含的信息有 parent，父亲提交对象 tree, 根目录树对象 author，作者 committer，提交者 tree 对象 用于表示一个目录 blob 对象 用于表示一个文件 tree 和 blob 对象可以看成是 git 内部采用的文件系统对象 这些对象都保存在.git/objects/目录下，每一个对象都会生成 1 个 40 位的哈希值，前 2 位作为文件夹，后 38 位作为文件名 不同名，相同内容的文件，其哈希值相同，其 blob 对象也是共用的 ","date":"2019-08-29","objectID":"/2019/08/git/:2:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"Git 中的工作区、暂存区、版本库 图例参考： 工作区：用来编辑保存项目文件的地方，也是用户能直接操作到的地方。 暂存区：保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，是一个叫 index 的文件，通常多数说法还是叫暂存区域。 版本库：也叫本地版本库，之所以说 git 快，是因为它是分布式版本控制系统，大部分提交都是对本地仓库而言的，不依赖网络，最后一次会推送的到远程仓库。 总结 git 基本的工作流程如下： 在工作目录中修改(此处修改包含了创建和删除)文件； 暂存文件，将文件 add 放入暂存区域； 提交更新，找到暂存区域的文件，将暂存区的文件 commit 到版本库； 如果工作区的文件改乱了（包括了误删、误改），想回到上一版本，就可以使用 git checkout 命令将版本库中的文件检出到工作区将本次更改 discard(覆盖)掉。 ","date":"2019-08-29","objectID":"/2019/08/git/:3:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"Git 和 SVN 有什么区别？ GIT SVN 分布式 集中式 可以离线提交 只能在线提交 ","date":"2019-08-29","objectID":"/2019/08/git/:4:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"什么是 Git 中的“裸存储库”？ Git 中的 “裸” 存储库只包含版本控制信息而没有工作文件（没有工作树）。也就是只有 .git 文件夹。 ","date":"2019-08-29","objectID":"/2019/08/git/:5:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"git pull 和 git fetch 有什么区别？ git pull = git fetch + git merge ","date":"2019-08-29","objectID":"/2019/08/git/:6:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"如果想要在提交之前运行代码性检查工具，并在测试失败时阻止提交，该怎样配置 Git 存储库？ 可以通过与存储库的 pre-commit hook 相关的简单脚本来完成。git 会在提交之前触发 pre-commit hook。你可以在脚本里对代码进行检查，如果脚本以非 0 退出，将会阻止提交操作。 ","date":"2019-08-29","objectID":"/2019/08/git/:7:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"Git 有什么分支策略？ 功能分支（Feature branching） 要素分支模型将特定要素的所有更改保留在分支内。当通过自动化测试对功能进行全面测试和验证时，该分支将合并到主服务器中。 任务分支（Task branching） 在此模型中，每个任务都在其自己的分支上实现，任务键包含在分支名称中。很容易看出哪个代码实现了哪个任务，只需在分支名称中查找任务键。 发布分支（Release branching） 一旦开发分支获得了足够的发布功能，你就可以克隆该分支来形成发布分支。创建该分支将会启动下一个发布周期，所以在此之后不能再添加任何新功能，只有错误修复，文档生成和其他面向发布的任务应该包含在此分支中。一旦准备好发布，该版本将合并到主服务器并标记版本号。此外，它还应该再将自发布以来已经取得的进展合并回开发分支。 ","date":"2019-08-29","objectID":"/2019/08/git/:8:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"配置 ","date":"2019-08-29","objectID":"/2019/08/git/:9:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"初始化配置 # 最小配置信息 git config --global user.name 'your_name' git config --global user.email 'your_email' # config的三个作用域 # 当前仓库有效 git config --local # 当前用户所有仓库有效 git config --global # 当前系统所有用户的所有仓库有效 git config --system # 显示config配置 git config --list [作用域] ","date":"2019-08-29","objectID":"/2019/08/git/:9:1","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"修改 HTTP 传输请求数据时最大的缓存字节数 git config --global http.postBuffer 524288000 ","date":"2019-08-29","objectID":"/2019/08/git/:9:2","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"远程 HTTPS 验证时记住密码 git config --global credential.helper store ","date":"2019-08-29","objectID":"/2019/08/git/:9:3","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"配置全局 git 编码 # 解决中文乱码情况 git config --global gui.encoding utf-8 ","date":"2019-08-29","objectID":"/2019/08/git/:9:4","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"使用代理提高 git 速度 git config --global http.proxy http://127.0.0.1:1080 git config --global https.proxy http://127.0.0.1:1080 ","date":"2019-08-29","objectID":"/2019/08/git/:9:5","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"应用场景 ","date":"2019-08-29","objectID":"/2019/08/git/:10:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"本地仓库管理 # 已有项目加入Git管理 cd \u003c项目目录\u003e git init # 新增项目并使用Git管理 git init \u003cyour_project\u003e # 检查修改内容 git status # 将文件加入Git版本控制(工作目录 -\u003e 暂存区) git add [文件名] [-u : 管理全部修改] # 提交暂存区更新内容(暂存区 -\u003e 版本库) git commit -m '提交原因' ","date":"2019-08-29","objectID":"/2019/08/git/:10:1","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"远程仓库管理 # 密钥位置 C:\\Users\\ibm\\.ssh\\* # 默认公钥文件名称 id_rsa.pub (需在github添加公钥) # 没有使用过 ssh 的需要创建ssh-keygen(公私钥对) ssh-keygen -C 'your_email' # 将本地仓库和远程仓库关联 git remote add origin \u003c*.git\u003e # 克隆远程仓库 git clone [--depth=number] \u003c仓库地址\u003e # 使用本地引用更新远程引用，同时发送完成给定引用所需的对象 git push [远程主机名: 通常origin] [-u : 指定默认主机(以后origin可省)] # 将远程存储库中的更改合并到当前分支中 git pull [远程主机名] [远程分支名] # 建立追踪关系(如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名) # 如果当前分支只有一个追踪分支，连远程主机名都可以省略。 git branch --set-upstream [本地分支名] origin/[远程分支名] ","date":"2019-08-29","objectID":"/2019/08/git/:10:2","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"分支管理 # 拉去远程分支信息 git fetch # 创建分支 git branch \u003cbranchName\u003e # 创建并切换分支 git switch -c \u003cbranchName\u003e # 使用远程分支创建本地对应分支 git switch -c \u003cbranchName\u003e origin/\u003coriginBranchName\u003e # 切换分支 git switch \u003cbranchName\u003e # 查看分支 git branch [-a: 查看远程] # 合并指定分支到当前分支 git merge \u003cbranchName\u003e # 删除分支 git branch -d \u003cbranchName\u003e # 删除远程分支 git push origin --delete \u003cbranchName\u003e ","date":"2019-08-29","objectID":"/2019/08/git/:10:3","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"查看 commit 历史 git log [--oneline : 单行简洁] [--all : 查看所有分支] [-n\u003cnumber\u003e : 查看最近number次提交] [--graph : 分支演化] # 查看参考日志 git reflog # 打开可视化 git log 查看器 gitk # 常用git log 命令 设置别名 # 查看自己的提交(简洁描述) git config --global alias.lm \"log --no-merges --color --date=format:'%Y-%m-%d %H:%M:%S' --author='your_name' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" # 查看自己的提交(展示修改的文件概览) git config --global alias.lms \"log --no-merges --color --stat --date=format:'%Y-%m-%d %H:%M:%S' --author='your_name' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" # 查看提交(简洁描述) git config --global alias.ls \"log --no-merges --color --graph --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" # 查看提交(展示修改的文件概览) git config --global alias.lss \"log --no-merges --color --stat --graph --date=format:'%Y-%m-%d %H:%M:%S' --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Cblue %s %Cgreen(%cd) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit\" ","date":"2019-08-29","objectID":"/2019/08/git/:10:4","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"比较文件差异 # 工作区和暂存区 git diff [filename : 指定文件] # 暂存区和 GIT 仓库 git diff --cached [commit : 指定GIT仓库的提交版本] [filename : 指定文件] # 工作目录和 GIT 仓库 git diff [commit : 指定GIT仓库的提交版本] [filename : 指定文件] # Commit 和 Commit git diff \u003ccommit_id\u003e \u003ccommit_id\u003e # 以上命令可以不指定 \u003cfilename\u003e，则对全部文件操作。commit 可以设置为HEAD指针。 ","date":"2019-08-29","objectID":"/2019/08/git/:10:5","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"退回已提交未推送的 commit # 记下当前 commit 的 id # HEAD 指向上一次提交 git reset --hard HEAD~1 # 将相应的 commit 的内容覆盖回暂存区 git checkout \u003ccommit\u003e -- . ","date":"2019-08-29","objectID":"/2019/08/git/:10:6","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"从暂存区退回工作区修改 git restore --staged \u003cfiles\u003e # or git reset HEAD ","date":"2019-08-29","objectID":"/2019/08/git/:10:7","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"丢弃工作区修改 git restore \u003cfiles\u003e # or git checkout -- . ","date":"2019-08-29","objectID":"/2019/08/git/:10:8","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"丢弃工作区和暂存区的修改 git checkout HEAD -- . # or git reset --hard HEAD ","date":"2019-08-29","objectID":"/2019/08/git/:10:9","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"丢弃未提交的 commit # 找到要将 HEAD 指针移动到的 commit 的 Id git reset --hard \u003ccommit_id\u003e # 将头指针指向上一次的 commit，并覆盖工作区和暂存区 git reset --hard HEAD~1 ","date":"2019-08-29","objectID":"/2019/08/git/:10:10","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"丢弃已提交的 commit git revert -n \u003ccommit\u003e git commit -m \u003cmessage\u003e ","date":"2019-08-29","objectID":"/2019/08/git/:10:11","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"恢复误操作丢弃的 commit # 查看参考日志找到丢弃的 commit 的 id git reflog # 将头指针指向对应 commit git reset --hard \u003ccommit_id\u003e ","date":"2019-08-29","objectID":"/2019/08/git/:10:12","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"暂存工作区修改去干其它重要的事情 # 该命令保存本地修改，并恢复工作目录以匹配HEAD提交 git stash # 查看已有存储 git stash list # 查看存储stash的文件变化 git stash show # 取回存储 git stash pop [stash_name] ","date":"2019-08-29","objectID":"/2019/08/git/:10:13","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"忽略已被 git 管理的文件 # 从git管理中删除指定文件 git rm --cached \u003c文件\u003e # 更新 .gitignore 后提交 ","date":"2019-08-29","objectID":"/2019/08/git/:10:14","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"查看 git 对象 //git对象查看 git cat-file [-t : 查看类型] [-p : 查看内容] \u003cgit对象hash\u003e ","date":"2019-08-29","objectID":"/2019/08/git/:10:15","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"扩展 ","date":"2019-08-29","objectID":"/2019/08/git/:11:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"多人协作工作流程 首先，可以试图用git push origin \u003cbranch-name\u003e推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u003cbranch-name\u003e推送就能成功！ 查看远程库信息，使用 git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 如果 git pull 提示 no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to \u003cbranch-name\u003e origin/\u003cbranch-name\u003e； ","date":"2019-08-29","objectID":"/2019/08/git/:11:1","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"如何进行多个 SSH Key 的管理 生成 SSH Key 时，对文件进行命名。 检查是否有已配置的代理 ssh-add -l 运行私钥管理器 exec ssh-agent bash 添加私钥 ssh-add ~/.ssh/id_rsa_XXX 在 github 添加公钥 创建配置文件 touch ~/.ssh/config # 默认的github用户 OrionPax19970905 Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_OrionPax19970905 user OrionPax19970905 # ZQianlvT Host github.zqt.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa user ZQianlvT #Host #配置别名 #HostName #这个是真实的域名地址 #IdentityFile #这里是id_rsa的地址 #PreferredAuthentications #配置登录时用什么权限认证--可设置publickey,password publickey,keyboard-interactive等 #User #配置使用用户名 测试 ssh -T git@github.com #测试OrionPax19970905 ssh -T git@github.zqt.com #测试ZQianlvT ","date":"2019-08-29","objectID":"/2019/08/git/:11:2","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"如何在 GitHub 上搜索感兴趣的项目 基础语法 高级搜索页面 ","date":"2019-08-29","objectID":"/2019/08/git/:11:3","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"参考 SSH Key 管理 廖雪峰的 Git 教程 图解 Git 工作区、暂存区、版本库之间的关系 ","date":"2019-08-29","objectID":"/2019/08/git/:12:0","tags":["工具"],"title":"Git 的使用","uri":"/2019/08/git/"},{"categories":null,"content":"简介 小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。微信小程序则是微信平台的小程序，背靠微信的用户体系、数据。 ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:1:0","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"微信 web 小程序和传统 web 的文件结构对比 - 传统 web 微信小程序 结构 HTML WXML 样式 CSS WXSS 逻辑 JavaScript JavaScript 配置 - JSON ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:2:0","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"开发环境搭建 ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:3:0","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"获取 AppID 注册微信小程序开发者账号，进入开发设置页面复制 AppID ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:3:1","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"微信开发工具 下载微信开发者工具，功能按照界面描述理解就可以了。 ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:3:2","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"基础 ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:0","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"项目目录 pages : 小程序对应页面的目录 index : 首页 index.js : index 页面下的 JS index.wxml : index 页面下的页面结构 index.wxss : index 页面下的样式文件 page1 : 子页面 page1.js page1.json : page1 页面的配置文件 page1.wxml page1.wxss components : 自定义组件目录(结构类似 pages) utils : 自己封装的工具函数路径 app.js : 全局的教本文件 app.json : 全局的配置文件 app.wxss : 全局的样式文件 project.config.json : 项目的描述文件类似package.json ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:1","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"全局配置 app.json 小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。完整配置项说明请参考小程序全局配置 // 常用配置 { \"pages\": [ \"pages/index/index\", \"pages/logs/index\" ], \"window\": { \"navigationBarTitleText\": \"Demo\" }, \"tabBar\": { \"list\": [{ \"pagePath\": \"pages/index/index\", \"text\": \"首页\" }, { \"pagePath\": \"pages/logs/logs\", \"text\": \"日志\" }] }, \"networkTimeout\": { \"request\": 10000, \"downloadFile\": 10000 }, \"debug\": true, \"navigateToMiniProgramAppIdList\": [ \"wxe5f52902cf4de896\" ] } ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:2","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"页面配置 每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。完整配置项说明请参考小程序页面配置 // 常用配置 { \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"black\", \"navigationBarTitleText\": \"微信接口功能演示\", \"backgroundColor\": \"#eeeeee\", \"backgroundTextStyle\": \"light\" } ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:3","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"注册小程序 每个小程序都需要在 app.js 中调用 App 方法注册小程序示例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。详细的参数含义和使用请参考 App 参考文档。 // app.js App({ onLaunch (options) { // Do something initial when launch. }, onShow (options) { // Do something when show. }, onHide () { // Do something when hide. }, onError (msg) { console.log(msg) }, globalData: 'I am global data' }) ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:4","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"注册页面 对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。 //index.js Page({ data: { text: \"This is page data.\" }, onLoad: function(options) { // 页面创建时执行 }, onShow: function() { // 页面出现在前台时执行 }, onReady: function() { // 页面首次渲染完毕时执行 }, onHide: function() { // 页面从前台变为后台时执行 }, onUnload: function() { // 页面销毁时执行 }, onPullDownRefresh: function() { // 触发下拉刷新时执行 }, onReachBottom: function() { // 页面触底时执行 }, onShareAppMessage: function () { // 页面被用户分享时执行 }, onPageScroll: function() { // 页面滚动时执行 }, onResize: function() { // 页面尺寸变化时执行 }, onTabItemTap(item) { // tab 点击时执行 console.log(item.index) console.log(item.pagePath) console.log(item.text) }, // 事件响应函数 viewTap: function() { this.setData({ text: 'Set some data for updating view.' }, function() { // this is setData callback }) }, // 自由数据 customData: { hi: 'MINA' } }) ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:5","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"注册自定义组件 开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。 创建自定义组件 \u003c!--xxx.json--\u003e { \"component\": true } Component({ properties: { // 这里定义了innerText属性，属性值可以在组件使用时指定 innerText: { type: String, value: 'default value', } }, data: { // 这里是一些组件内部数据 someData: {} }, methods: { // 这里是一个自定义方法 customMethod: function(){} } }) 使用自定义组件 \u003c!--xxx.json--\u003e { \"usingComponents\": { \"component-tag-name\": \"path/to/the/custom/component\" } } \u003cview\u003e \u003c!-- 以下是对一个自定义组件的引用 --\u003e \u003ccomponent-tag-name inner-text=\"Some text\"\u003e\u003c/component-tag-name\u003e \u003c/view\u003e ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:6","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"视图结构 数据绑定 \u003c!--wxml--\u003e \u003cview\u003e {{message}} \u003c/view\u003e // page.js Page({ data: { message: 'Hello MINA!' } }) 列表渲染 \u003c!--wxml--\u003e \u003cview wx:for=\"{{array}}\"\u003e {{item}} \u003c/view\u003e // page.js Page({ data: { array: [1, 2, 3, 4, 5] } }) 条件渲染 \u003c!--wxml--\u003e \u003cview wx:if=\"{{view == 'WEBVIEW'}}\"\u003e WEBVIEW \u003c/view\u003e \u003cview wx:elif=\"{{view == 'APP'}}\"\u003e APP \u003c/view\u003e \u003cview wx:else=\"{{view == 'MINA'}}\"\u003e MINA \u003c/view\u003e // page.js Page({ data: { view: 'MINA' } }) ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:7","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"基本组件 view 微信小程序的块级标签，类似 HTML 的\u003cdiv\u003e。 hover-class : 指定按下去的样式类。当 hover-class=\"none\" 时，没有点击态效果。 text 微信小程序的行级标签，类似 HTML 的\u003cspan\u003e。只能嵌套自己。 selectable : 文本是否可选 space : 显示连续空格 decode : 是否解码 image src : 图片资源地址 lazy-load : 图片是否懒加载 video src : 视频资源地址 swiper 轮播视图容器。其中只能放swiper-item。 navigator url : 跳转链接 ","date":"2019-08-04","objectID":"/2019/08/wx-mini/:4:8","tags":["框架"],"title":"微信小程序开发","uri":"/2019/08/wx-mini/"},{"categories":null,"content":"简介 ","date":"2019-07-25","objectID":"/2019/07/typescript/:1:0","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"什么是 TypeScript? TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持。 ","date":"2019-07-25","objectID":"/2019/07/typescript/:1:1","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"为什么选择 TypeScript? TypeScript 增加了代码的可读性和可维护性 有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念 短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本 可能和一些库结合的不是很完美 ","date":"2019-07-25","objectID":"/2019/07/typescript/:1:2","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"基础 ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:0","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"原始数据类型 原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol。 let isDone: boolean = false; let decLiteral: number = 6; let myName: string = 'Tom'; let u: undefined = undefined; let n: null = null; // JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数 function alertName(): void { alert('My name is Tom'); } ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:1","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"任意值 // 如果是一个普通类型，在赋值过程中改变类型是不被允许的 error TS2322: Type 'number' is not assignable to type 'string'. let myFavoriteNumber: string = 'seven'; myFavoriteNumber = 7; // 但如果是 any 类型，则允许被赋值为任意类型 let myFavoriteNumber: any = 'seven'; myFavoriteNumber = 7; // 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型 let something; // 等价于 let something: any; 在任意值上访问任何属性都是允许的 也允许调用任何方法 声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值 ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:2","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"类型推论 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。其实就是根据初始化的值来确认类型，不进行初始化就是 any ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:3","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"接口 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。 // 简单的例子 定义的变量的属性必须和接口保持一致，多或少都是不可以的。赋值的时候，变量的形状必须和接口的形状保持一致。 interface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 }; // 可选属性 仍然不允许添加未定义的属性 interface Person { name: string; age?: number; // 这个属性是可选的 } ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:4","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"数组的类型 // 「类型 + 方括号」表示法 let fibonacci: number[] = [1, 1, 2, 3, 5]; // 数组泛型 let fibonacci: Array\u003cnumber\u003e = [1, 1, 2, 3, 5]; // 用接口表示数组 interface NumberArray { [index: number]: number; } let fibonacci: NumberArray = [1, 1, 2, 3, 5]; ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:5","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"函数的类型 // 简单的函数定义 声明式 function sum(x: number, y: number): number { return x + y; } // 函数表达式定义函数 在 TypeScript 的类型定义中，=\u003e 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。 let mySum: (x: number, y: number) =\u003e number = function (x: number, y: number): number { return x + y; }; // 箭头函数语法糖 let mySum: (x: number, y: number) =\u003e number = (x: number, y: number): number =\u003e { return x + y; }; // 用接口定义函数的形状 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { return source.search(subString) !== -1; } // 可选参数 可选参数后面不允许再出现必须参数 function buildName(firstName: string, lastName?: string) { ... } // 剩余参数 function push(array: any[], ...items: any[]) { items.forEach(function(item) { array.push(item); }); } // 重载 TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string { ... } ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:6","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"类型断言 将一个联合类型的变量指定为一个更加具体的类型。类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的。 \u003c类型\u003e值 // or 值 as 类型 // 在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用这一种 ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:7","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"声明文件 当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。 // 相关语法 declare var // 声明全局变量 declare function // 声明全局方法 declare class // 声明全局类 declare enum // 声明全局枚举类型 declare namespace // 声明（含有子属性的）全局对象 interface 和 type // 声明全局类型 export // 导出变量 export namespace // 导出（含有子属性的）对象 export default ES6 // 默认导出 export = commonjs // 导出模块 export as namespace UMD // 库声明全局变量 declare global // 扩展全局变量 declare module // 扩展模块 /// \u003creference /\u003e 三斜线指令 TypeScript 声明文件使用 ","date":"2019-07-25","objectID":"/2019/07/typescript/:2:8","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"扩展 ","date":"2019-07-25","objectID":"/2019/07/typescript/:3:0","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"类型别名 // 简单的例子 类型别名常用于联合类型 type Name = string; type NameResolver = () =\u003e string; type NameOrResolver = Name | NameResolver; function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n; } else { return n(); } } ","date":"2019-07-25","objectID":"/2019/07/typescript/:3:1","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"字符串字面量类型 // 字符串字面量类型用来约束取值只能是某几个字符串中的一个。类型别名与字符串字面量类型都是使用 type 进行定义。 type EventNames = 'click' | 'scroll' | 'mousemove'; function handleEvent(ele: Element, event: EventNames) { // do something } ","date":"2019-07-25","objectID":"/2019/07/typescript/:3:2","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"类 // 属性和方法 // 使用 class 定义类，使用 constructor 定义构造函数。 class Animal { constructor(name) { this.name = name; } sayHi() { return `My name is ${this.name}`; } } let a = new Animal('Jack'); // 通过 new 生成新实例的时候，会自动调用构造函数。 console.log(a.sayHi()); // My name is Jack // 类的继承 子类中使用 super 关键字来调用父类的构造函数和方法 class Cat extends Animal { constructor(name) { super(name); // 调用父类的 constructor(name) console.log(this.name); } sayHi() { return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi() } } // 存取器 getter 和 setter 可以改变属性的赋值和读取行为 class Animal { constructor(name) { this.name = name; } get name() { return 'Jack'; } set name(value) { console.log('setter: ' + value); } } let a = new Animal('Kitty'); // setter: Kitty a.name = 'Tom'; // setter: Tom console.log(a.name); // Jack // 静态方法 class Animal { static isAnimal(a) { return a instanceof Animal; } } ","date":"2019-07-25","objectID":"/2019/07/typescript/:3:3","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"类与接口 interface Alarm { alert(); } class Door { } class SecurityDoor extends Door implements Alarm { alert() { console.log('SecurityDoor alert'); } } class Car implements Alarm { alert() { console.log('Car alert'); } } ","date":"2019-07-25","objectID":"/2019/07/typescript/:3:4","tags":["语言"],"title":"TypeScript 知识总结","uri":"/2019/07/typescript/"},{"categories":null,"content":"简介 Taro 是一套遵循 React 语法规范的 多端开发 解决方案。现如今市面上端的形态多种多样，Web、React-Native、微信小程序等各种端大行其道，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。 使用 Taro，我们可以只书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动/QQ 小程序、快应用、H5、React-Native 等）运行的代码。 ","date":"2019-07-25","objectID":"/2019/07/taro/:1:0","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"基础 ","date":"2019-07-25","objectID":"/2019/07/taro/:2:0","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"安装及使用 # 使用 npm 安装 CLI $ npm install -g @tarojs/cli # 出现 sass 相关的错误 $ npm install -g mirror-config-china # 创建一个模板项目 $ taro init myApp # 运行/打包 # h5 $ yarn dev:h5 $ yarn build:h5 # 微信 $ yarn dev:weapp $ yarn build:weapp # 支付宝 $ yarn dev:alipay $ yarn build:alipay # 字节跳动 $ yarn dev:tt $ yarn build:tt # QQ $ yarn dev:qq $ yarn build:qq # 快应用 $ yarn dev:quickapp $ yarn build:quickapp # 项目检查 $ taro doctor ","date":"2019-07-25","objectID":"/2019/07/taro/:2:1","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"跨平台开发 if (process.env.TARO_ENV === 'weapp') { require('path/to/weapp/name') } else if (process.env.TARO_ENV === 'h5') { require('path/to/h5/name') } ","date":"2019-07-25","objectID":"/2019/07/taro/:2:2","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"编译配置 Taro 的编译配置文件是 config/index.js。 下面列几个用到修改的配置： sourceRoot: 'src', // 源码目录 outputRoot: 'dist', // 打包目录，如果需要打包不同的目录就要调整 // Taro 的编译存在一些坑，不按照他的包结构来的话有些内容就不会编译到，可以用这项配置，来把原生小程序中不会被编译的内容 Copy 到对应 dist 目录防止引用不到。 copy: { patterns: [ { from: 'src/asset/tt/', to: 'dist/asset/tt/', ignore: '*.js' }, // 指定需要 copy 的目录 { from: 'src/asset/tt/sd.jpg', to: 'dist/asset/tt/sd.jpg' } // 指定需要 copy 的文件 ] }, ","date":"2019-07-25","objectID":"/2019/07/taro/:2:3","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"扩展 ","date":"2019-07-25","objectID":"/2019/07/taro/:3:0","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"基于 Taro 开发第三方多端 UI 库 // 为了打包出可以在 H5 端使用的组件库，需要在 config/index.js 文件中增加一些配置 if (process.env.TARO_BUILD_TYPE === 'ui') { Object.assign(config.h5, { enableSourceMap: false, enableExtract: false, enableDll: false }) config.h5.webpackChain = chain =\u003e { chain.plugins.delete('htmlWebpackPlugin') chain.plugins.delete('addAssetHtmlWebpackPlugin') chain.merge({ output: { path: path.join(process.cwd(), 'dist', 'h5'), filename: 'index.js', libraryTarget: 'umd', library: 'taro-ui-sample' }, externals: { nervjs: 'commonjs2 nervjs', classnames: 'commonjs2 classnames', '@tarojs/components': 'commonjs2 @tarojs/components', '@tarojs/taro-h5': 'commonjs2 @tarojs/taro-h5', 'weui': 'commonjs2 weui' } }) } } // 打包命令 taro build --ui ","date":"2019-07-25","objectID":"/2019/07/taro/:3:1","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"使用小程序原生组件 直接使用即可，但是如果不做多端的兼容处理就会导致其他端无法编译了。 ","date":"2019-07-25","objectID":"/2019/07/taro/:3:2","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"使用 MobX // counter.ts // 定义 Store import { observable } from 'mobx' const counterStore = observable({ counter: 0, counterStore() { this.counter++ }, increment() { this.counter++ }, decrement() { this.counter-- }, incrementAsync() { setTimeout(() =\u003e { this.counter++ }, 1000) } }) export default counterStore // src/app.ts // 设置 Provider 和 React 类似但是全局只能有一个，且只能在 app.ts 上 import counterStore from './store/counter' const store = { counterStore } ... render () { return ( \u003cProvider store={store}\u003e \u003cIndex /\u003e \u003c/Provider\u003e ) } ... // IndexPage.tsx // 消费 Store import Taro, { Component } from '@tarojs/taro' import { observer, inject } from '@tarojs/mobx' import './index.scss' @inject('counterStore') @observer class Index extends Component { //... } export default Index ","date":"2019-07-25","objectID":"/2019/07/taro/:3:3","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"开发第三方多端非 UI 库 前提: Taro 目前并未提供非 UI 库多端编译的命令 tsc 编译，不支持 h5 。(Taro 编译的时候对于 h5 会把 @tarojs/taro 替换成 @tarojs/taro-h5，还有一些其他的兼容处理) Taro 不支持 require，因此也不支持动态导入，所以它自己也没有实现一个多端公用的包 解决方案: 同时打出多端的包，然后用 require 动态导入 配置信息: // config/index.js // 借用下 Taro 开发第三方多端 UI 库的配置与导出结构，省的自己写脚本了。 if (process.env.TARO_BUILD_TYPE === 'ui') { Object.assign(config.h5, { enableSourceMap: false, enableExtract: false, enableDll: false }) config.h5.webpackChain = chain =\u003e { chain.plugins.delete('htmlWebpackPlugin') chain.plugins.delete('addAssetHtmlWebpackPlugin') chain.merge({ output: { path: path.join(process.cwd(), 'dist', 'h5'), filename: 'index.js', libraryTarget: 'umd', library: 'taro-ui-sample' }, externals: { nervjs: 'commonjs2 nervjs', classnames: 'commonjs2 classnames', '@tarojs/components': 'commonjs2 @tarojs/components', '@tarojs/taro-h5': 'commonjs2 @tarojs/taro-h5', 'weui': 'commonjs2 weui' } }) } } // tsconfig.json \"rootDir\": \"./src\", // 源代码路径 \"outDir\": \"dist/weapp\", // 输出位置 \"declaration\": true, // 自动生成声明文件 \"declarationDir\": \"types\", // 将声明文件统一生成到types路径下 // package.json \"typings\": \"types/index.d.ts\" // 指定项目声明文件位置 相关命令: // 将项目作为 UI 库打包, 生成 H5 下需要引用的包。 taro build --ui // TypeScript 编译 tsc // NPM 打补丁(提高一个小版本) npm version patch // 发布更新 npm publish // 更新引入包 npm update @bageventjs/packageName ","date":"2019-07-25","objectID":"/2019/07/taro/:3:4","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"参考 Taro 全局配置 Taro APP 生命周期 Taro 页面生命周期 Taro 组件生命周期 Taro 编译配置详情 MobX 中文文档 ","date":"2019-07-25","objectID":"/2019/07/taro/:4:0","tags":["框架"],"title":"Taro 的使用","uri":"/2019/07/taro/"},{"categories":null,"content":"简介 Tomcat 服务器是一个免费的开放源代码的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试 JSP 程序的首选。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:1:0","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"安装 Windows 下安装使用 Scoop scoop install tomcat。Linux 参考 Linux 下安装 Tomcat。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:2:0","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"基础 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:3:0","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"作用 sevlet 管理。将 servlet 存放在服务器中，客户端访问服务器中的 servlet，服务器提供 servlet 的生命周期的管理。 多线程支持。容器会自动为接收的每个 servlet 请求创建一个新的 java 线程，servlet 运行完之后，容器会自动结束这个线程。 jsp 支持。容器将 jsp 翻译成 servlet！ ","date":"2019-07-23","objectID":"/2019/07/tomcat/:3:1","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"Tomcat 的目录结构 bin : 存放 tomcat 的命令 conf : 存放 tomcat 的配置信息。其中 server.xml 文件是核心的配置文件。 lib : 支持 tomcat 软件运行的 jar 包。其中还有技术支持包，如 servlet，jsp logs : 运行过程的日志信息 temp : 临时目录 webapps : 共享资源目录。web 应用目录。（注意不能以单独的文件进行共享） work : tomcat 的运行目录。jsp 运行时产生的临时文件就存放在这里 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:3:2","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"Web 应用的目录结构 WebRoot 静态资源（html+css+js+image+vedio） WEB-INF(固定写法) classes :（可选）固定写法。存放 class 字节码文件 lib :（可选）固定写法。存放 jar 包文件 web.xml ","date":"2019-07-23","objectID":"/2019/07/tomcat/:3:3","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"常用配置 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:0","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"修改 Tomcat 控制台标题 在 bin 目录下创建 setenv.bat 文件并添加一行 set TITLE=自定义标题，重启服务测试。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:1","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"修改 JSESSIONID 在 Cookie 中的名称 在 Context 容器标签上增加 sessionCookieName 参数 \u003cContext path=”/” docBase=”webapp” sessionCookieName=”CustomSessionName”\u003e\u003c/Context\u003e ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:2","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"server.xml 个端口的作用 \u003cServer port=\"8005\" shutdown=\"SHUTDOWN\"\u003e 服务端口，shutdown 命令执行时会关闭对应端口的服务。 \u003cConnector port=\"8080\" protocol=\"HTTP/1.1\" HTTP 协议端口。 \u003cConnector port=\"8009\" protocol=\"AJP/1.3\" AJP 协议端口。AJP 协议负责和其他的 HTTP 服务器(如 Apache )建立连接；在把 Tomcat 与其他 HTTP 服务器集成时，就需要用到这个连接器。之所以使用 Tomcat 和其他服务器集成，是因为 Tomcat 可以用作 Servlet/JSP 容器，但是对静态资源的处理速度较慢，不如 Apache 和 IIS 等 HTTP 服务器。 redirectPort=\"8443\" /\u003e redirectPort 表示当强制要求 HTTPS 而请求是 HTTP 时，重定向至端口号为8443的 Connector。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:3","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"修改默认 web 目录 可以通过配置 \u003cContext\u003e 元素的 docBase 属性来修改。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:4","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"多种配置 Context 元素的途径 Tomcat 6.x 提供了多种配置 \u003cContext\u003e 元素的途径。当 Tomcat 6.x 加载一个 Web 应用时，会依次按照以下五种方式尝试查找 Web 应用的 \u003cContext\u003e 元素，直到找到为止： 到 \u003cCATALINA_HOME\u003e/conf/context.xml 文件中查找 \u003cContext\u003e 元素。这个文件中的 \u003cContext\u003e 元素的信息适用于所有Web应用。 到 \u003cCATALINA_HOME\u003e/conf/enginename/hostname/context.xml.default 文件中查找 \u003cContext\u003e 元素。[enginename]表示 \u003cEngine\u003e 的 name 属性，[hostname]表示 \u003cHost\u003e 的name属性。在 context.xml.default 文件中的 \u003cContext\u003e 元素的信息适用于当前虚拟主机中的所有 Web 应用。 到 \u003cCATALINA_HOME\u003e/conf/enginename/hostname/[contextpath].xml 文件中查找 \u003cContext\u003e 元素。[contextpath]表示单个 Web 应用的 URL 入口。在[contextpath].xml文件中的 \u003cContext\u003e 元素的信息只适用于单个 Web 应用，例如以下文件中的 \u003cContext\u003e元素适用于名为“Catalina”的Engine下的localhost主机中的helloapp应用： \u003cCATALINA_HOME\u003e/conf/Catalina/localhost/helloapp.xml 到Web应用的META-INF/context.xml 文件中查找 \u003cContext\u003e 元素。这个文件中的 \u003cContext\u003e 元素的信息适用于当前 Web 应用。 到 \u003cCATALINA_HOME\u003e/conf/server.xml 文件中的 \u003cHost\u003e 元素中查找 \u003cContext\u003e 子元素。该 \u003cContext\u003e 元素的信息只适用于单个Web应用。 ","date":"2019-07-23","objectID":"/2019/07/tomcat/:4:5","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"参考 详解Tomcat 配置文件server.xml ","date":"2019-07-23","objectID":"/2019/07/tomcat/:5:0","tags":["工具"],"title":"Tomcat 的使用","uri":"/2019/07/tomcat/"},{"categories":null,"content":"简介 React Router 是完整的 React 路由解决方案。React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。 ","date":"2019-07-23","objectID":"/2019/07/react-router/:1:0","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"为什么需要路由？ 单页应用许需要进行页面的切换 通过 URL 可以定位到页面 更有语义的组织资源 ","date":"2019-07-23","objectID":"/2019/07/react-router/:2:0","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"基础 ","date":"2019-07-23","objectID":"/2019/07/react-router/:3:0","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"三种路由实现方式 URL 路径 hash 路由 内存路由 ","date":"2019-07-23","objectID":"/2019/07/react-router/:3:1","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"API \u003cLink\u003e : 普通的链接，不会触发浏览器刷新。to : 跳转链接的路径，如 /users/123。 \u003cRedirect\u003e : 重定向当前页面，例如：登录判断。 \u003cRoute\u003e : 路径匹配时显示对应组件。 const routes = ( \u003cRoute component={App}\u003e \u003cRoute path=\"groups\" component={Groups} /\u003e \u003cRoute path=\"users\" component={Users} /\u003e \u003c/Route\u003e ); class App extends React.Component { render() { return ( \u003cdiv\u003e {/* 这会是 \u003cUsers\u003e 或 \u003cGroups\u003e */} {this.props.children} \u003c/div\u003e ); } } path : URL 中的路径。它会组合父 route 的路径，除非它是从 / 开始的， 将它变成一个绝对路径。 components : 当匹配到 URL 时，单个的组件会被渲染。它可以 被父 route 组件的 this.props.children 渲染。 \u003cSwitch\u003e : 只显示第一个匹配的路由 ","date":"2019-07-23","objectID":"/2019/07/react-router/:3:2","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"React Router 特性 声明式路由定义。页面任意地方可以定义路由通过 URL 加载组件。 动态路由。页面解析时，才解析路由。 ","date":"2019-07-23","objectID":"/2019/07/react-router/:4:0","tags":["框架"],"title":"React Router 的使用","uri":"/2019/07/react-router/"},{"categories":null,"content":"简介 Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 ","date":"2019-07-23","objectID":"/2019/07/redux/:1:0","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"三大原则 单一数据源 整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。 State 是只读的（可预测性） 唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象(state + action = new state)。 使用纯函数来执行修改 为了描述 action 如何改变 state tree ，你需要编写 reducers。输入相同，输出一定相同。 ","date":"2019-07-23","objectID":"/2019/07/redux/:2:0","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"基础 ","date":"2019-07-23","objectID":"/2019/07/redux/:3:0","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"Action Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。Action 本质上是 JavaScript 普通对象。我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。 const ADD_TODO = 'ADD_TODO'; //添加新 todo 任务的 action 是这样的： { type: ADD_TODO, text: 'Build my first Redux app' } ","date":"2019-07-23","objectID":"/2019/07/redux/:3:1","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"Reducer Reducers 指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。 ","date":"2019-07-23","objectID":"/2019/07/redux/:3:2","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"Store getState() : 返回应用当前的 state 树。 dispatch(action) : 分发 action。这是触发 state 变化的惟一途径。 subscribe(listener) : 添加一个变化监听器。每当 dispatch action 的时候就会执行，state 树中的一部分可能已经变化。你可以在回调函数里调用 getState() 来拿到当前 state。 ","date":"2019-07-23","objectID":"/2019/07/redux/:3:3","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"API createStore(reducer, [preloadedState], enhancer) 创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。 combineReducers(reducers) 随着应用变得越来越复杂，可以考虑将 reducer 函数 拆分成多个单独的函数，拆分后的每个函数负责独立管理 state 的一部分。combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。 bindActionCreators(actionCreators, dispatch) 把一个 value 为不同 action creator 的对象，转成拥有同名 key 的对象。同时使用 dispatch 对每个 action creator 进行包装，以便可以直接调用它们。 ","date":"2019-07-23","objectID":"/2019/07/redux/:3:4","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"react-redux API \u003cProvider store\u003e \u003cProvider store\u003e 使组件层级中的 connect() 方法都能够获得 Redux store。 connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options]) 连接 React 组件与 Redux store。 mapStateToProps(state, [ownProps]): stateProps: 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。 [mapDispatchToProps(dispatch, [ownProps]): dispatchProps] (Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中 dispatch 方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。 ","date":"2019-07-23","objectID":"/2019/07/redux/:3:5","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"框架特性 ","date":"2019-07-23","objectID":"/2019/07/redux/:4:0","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"不可变数据 为什么需要不可变数据 性能优化(引用比较) 易于调试和跟踪(计算 diff 值) 易于推测 如何操作不可变数据 原生写法 //性能最高 const state = { filter: \"completed\", todos: [\"Learn React\"] }; const newState = { ...state, todos: [...state.todos, \"Learn Redux\"] }; const newState2 = Object.assign({}, state, { todos: [...state.todos, \"Learn Redux\"] }); immutability-helper //深层次的不可变数据方便 import update from 'immutability-helper'; const state = {filter : \"completed\", todos: [\"Learn React\"]}; const newState = update(state, { todos: {$push: [\"Learn Redux\"]}); immer //可读性强，性能层次较深的话会较低 import produce from \"immer\"; const state = { filter: \"completed\", todos: [\"Learn React\"] }; const newState = produce(state, drafState =\u003e { drafState.todos.push(\"Learn Redux\"); }); ","date":"2019-07-23","objectID":"/2019/07/redux/:4:1","tags":["框架"],"title":"Redux 的使用","uri":"/2019/07/redux/"},{"categories":null,"content":"简介 定义 : jQuery 是一个快速、简洁的 JavaScript 函数库，jQuery 设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装 JavaScript 常用的功能代码，提供一种简便的 JavaScript 设计模式，优化 HTML 文档操作、事件处理、动画设计和 Ajax 交互。 产生原因 : JavaScript 的 DOM API 十分不好用、JavaScript 面对不同的浏览器需要写不同的代码。 ","date":"2019-07-23","objectID":"/2019/07/jquery/:1:0","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"基础 ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:0","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用选择器 基本 #id element .class * selector1,selector2,selectorN 层级 ancestor descendant parent \u003e child prev + next prev ~ siblings 筛选 :first :not(selector) :even :odd :eq(index) :gt(index) :last :lt(index) :focus 内容 :contains(text) :empty :has(selector) :parent 可见性 :hidden :visible 属性 [attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrsel2][attrSelN] 子元素 :first-child :last-child 表单 :input :text :password :radio :checkbox :submit :image :reset :button :file 表单属性 :enabled :disabled :checked :selected ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:1","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用核心函数 each(callback) size() get([index]) index([selector|element]) data([key],[value]) ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:2","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用 AJAX 函数 $.ajax(url,[settings]) $.getJSON(url,[data],[fn]) $.post(url,[data],[fn],[type]) ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:3","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用筛选函数 过滤 eq(index|-index) first() last() hasClass(class) has(expr|ele) 查找 children([expr]) find(e|o|e) next([expr]) parent([expr]) parents([expr]) prev([expr]) ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:4","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用 DOM 元素操作函数 attr(name|pro|key,val|fn) removeAttr(name) addClass(class|fn) removeClass([class|fn]) html([val|fn]) text([val|fn]) val([val|fn|arr]) ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:5","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用文档处理函数 append(content|fn) appendTo(content) prepend(content|fn) prependTo(content) after(content|fn) before(content|fn) insertAfter(content) insertBefore(content) remove([expr]) ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:6","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"常用事件函数 ready(fn) on(eve,[sel],[data],fn) off(eve,[sel],[fn]) eventName([[data],fn]) : HTML 事件去掉 on 就是 jQuery 的事件函数 ","date":"2019-07-23","objectID":"/2019/07/jquery/:2:7","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"值得一提 ","date":"2019-07-23","objectID":"/2019/07/jquery/:3:0","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"JS 对象和 jQuery 对象的区别 jQuery 对象就是 JS new Object()生成的普通对象。 ","date":"2019-07-23","objectID":"/2019/07/jquery/:3:1","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"何时使用筛选方法来进行选择 当$选择器里的字符串需要出现this时，因为this是一个对象，而使用$选择器要么传一个对象要么传一个字符串，而不能把对象和字符串相结合使用，就使用筛选方法来选择。 ","date":"2019-07-23","objectID":"/2019/07/jquery/:3:2","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"应用场景 ","date":"2019-07-23","objectID":"/2019/07/jquery/:4:0","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"JS 对象和 jQuery 对象的相互转换方法 JS 对象-\u003eJQuery 对象 : $(dom); jQuery 对象-\u003eJS 对象 : $('h1')[1];或者$('h1').get(1); ","date":"2019-07-23","objectID":"/2019/07/jquery/:4:1","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"参考 JQuery 手册 ","date":"2019-07-23","objectID":"/2019/07/jquery/:5:0","tags":["框架"],"title":"Jquery 的使用","uri":"/2019/07/jquery/"},{"categories":null,"content":"问题描述 因为 React 的状态到虚拟 DOM 再到 DOM 绘制的框架实现和通过 JQuery 去直接修改 DOM 是有冲突的。所以如果使用了 React 框架的话，最好就不要再使用会直接修改 DOM 的 JQuery 框架。 ","date":"2019-07-23","objectID":"/2019/07/react-e2/:1:0","tags":["问题"],"title":"React 和直接修改 DOM 的前端框架的兼容性问题","uri":"/2019/07/react-e2/"},{"categories":null,"content":"React 和 JQuery UI Sortable 产生原因: 使用 Sortable 进行拖拽排序时，在放置时 Sortable 会先根据拖拽起始和目标修改一次 DOM。然后如果在拖拽后更新了数据，React 会 render DOM，但是 React 并不知道 Sortable 对 DOM 进行了修改，因此产生的冲突。 解决方式: 在 stop 回调方法里取消 Sortable 的排序，将排序操作交给 React 管理。 stop: function () { $schArLiBox.sortable(\"cancel\"); } ","date":"2019-07-23","objectID":"/2019/07/react-e2/:1:1","tags":["问题"],"title":"React 和直接修改 DOM 的前端框架的兼容性问题","uri":"/2019/07/react-e2/"},{"categories":null,"content":"React 和 JQuery tipsy 产生原因: React 修改 title 后，如果是置为\"\"或删除 title 属性，都不会另 tipsy 重新加载 original-title 属性，只有修改为其他值是才重加载。因此要删除的话就有问题。 解决方式: 使用 jQuery 手动删除修改的元素的 original-title 属性 ","date":"2019-07-23","objectID":"/2019/07/react-e2/:1:2","tags":["问题"],"title":"React 和直接修改 DOM 的前端框架的兼容性问题","uri":"/2019/07/react-e2/"},{"categories":null,"content":"问题描述 React 的 JAX 语法中进行动态数据绑定时不能动态绑定 HTML。 ","date":"2019-07-23","objectID":"/2019/07/react-e1/:1:0","tags":["问题"],"title":"JAX 中 HTML 代码段被识别为字符串的问题","uri":"/2019/07/react-e1/"},{"categories":null,"content":"产生原因 JAX 的设计者，在设计时为了防止 XSS 攻击，特意限制了。 ","date":"2019-07-23","objectID":"/2019/07/react-e1/:2:0","tags":["问题"],"title":"JAX 中 HTML 代码段被识别为字符串的问题","uri":"/2019/07/react-e1/"},{"categories":null,"content":"解决方式 //使用dangerouslySetInnerHTML(注意__html是两个_) \u003cdiv dangerouslySetInnerHTML={{__html: html}} /\u003e 不合时宜的使用 innerHTML 可能会导致 cross-site scripting (XSS) 攻击。 净化用户的输入来显示的时候，经常会出现错误，不合适的净化也是导致网页攻击的原因之一。我们的设计哲学是让确保安全应该是简单的，开发者在执行“不安全”的操作的时候应该清楚地知道他们自己的意图。dangerouslySetInnerHTML 这个 prop 的命名是故意这么设计的，以此来警告，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据。 ","date":"2019-07-23","objectID":"/2019/07/react-e1/:3:0","tags":["问题"],"title":"JAX 中 HTML 代码段被识别为字符串的问题","uri":"/2019/07/react-e1/"},{"categories":null,"content":"简介 React 是一个用于构建用户界面的 JavaScript 库。(就是个状态机，将根据数据源映射出 UI，遵守一定的规范可以将，UI 和 逻辑分离，更容易调试和编写单元测试) 声明式 React 可以非常轻松地创建用户交互界面。为你应用的每一个状态设计简洁的视图，在数据改变时 React 也可以高效地更新渲染界面。以声明式编写 UI，可以让你的代码更加可靠，且方便调试。 组件化 创建好拥有各自状态的组件，再由组件构成更加复杂的界面。无需再用模版代码，通过使用 JavaScript 编写的组件你可以更好地传递数据，将应用状态和 DOM 拆分开来。 ","date":"2019-07-23","objectID":"/2019/07/react/:1:0","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"基础 ","date":"2019-07-23","objectID":"/2019/07/react/:2:0","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"Hello World ReactDOM.render( \u003ch1\u003eHello, world!\u003c/h1\u003e, document.getElementById('root') ); ","date":"2019-07-23","objectID":"/2019/07/react/:2:1","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"理解 JSX 本质 : 不是模板引擎而是动态创建组件(使用 JavaScript 原生的 DOM API document.createElement())的语法糖。JSX 防注入攻击。React DOM 在渲染之前默认会过滤所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本)攻击。 对比其他模板语言的优点 使用声明式创建页面比较直观 使用代码创建页面十分灵活 不需要学习一门新的模板语言 约定 React 认为小写的 tag 是原生的 DOM 节点，例如:\u003cdiv\u003e。 大写字母开头的为自定义组件。 JAX 标记可以直接使用属性语法，例如:\u003cmenu.Item\u003e。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:2","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"元素渲染 React 只会更新必要的部分。React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。根据我们以往的经验，将界面视为一个个特定时刻的固定内容（就像一帧一帧的动画），而不是随时处于变化之中（而不是处于变化中的一整段动画），将会有利于我们理清开发思路，减少各种 bug。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:3","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"理解 React 组件 概念 React 组件一般不提供方法，而是某种状态机。 React 组件可以理解为一个纯函数(输入是什么结果一定是什么)。 单向数据绑定(外部通过 props 传递参数给内部，内部发生变化时暴露事件给外部)。 实例 //JavaScript函数方式 function Welcome(props) { return \u003ch1\u003eHello, {props.name}\u003c/h1\u003e; } //ES6 class 定义一个组件(使用类就允许我们使用其它特性，例如局部状态、生命周期钩子) //组件名称必须以大写字母开头。 //组件的返回值只能有一个根元素。这也是我们要用一个\u003cdiv\u003e来包裹所有\u003cWelcome /\u003e元素的原因。 class Welcome extends React.Component { render() { return \u003ch1\u003eHello, {this.props.name}\u003c/h1\u003e; } } 创建一个 React 组件 方法论 创建静态 UI(原型)。 考虑组件的状态组成(外部传递还是内部维护)。 考虑组件的交互方式(内部用户进行的操作如何暴露给外部的人使用)。 单一职责原则 每个组件只做一件事。 如果组件变得复杂，那么应该拆分成小的组件(拆分小组件可以在降低复杂度的同时提高性能，对组件状态进行更新时刷新范围变小)。 DRY 原则 能够计算得到的状态就不要单独存储。 组件尽量无状态，所需数据通过 props 获取。 受控组件和非受控组件 受控组件 : 组件或表单元素状态由使用者维护。React 中表单元素通常作为受控组件使用。对外暴露修改事件的静态组件也属于受控组件。 非受控组件 : 组件状态由自身维护，或表单元素状态由 DOM 自身维护。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:4","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"Props 当 React 遇到的元素是用户自定义的组件，它会将 JSX 属性作为单个对象传递给该组件，这个对象称之为“props”。 Props 的只读性。无论是使用函数或是类来声明一个组件，它决不能修改它自己的 props。 我们建议从组件自身的角度来命名 props，而不是根据使用组件的上下文命名。 React 是非常灵活的，但它也有一个严格的规则：所有的 React 组件必须像纯函数那样使用它们的 props。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:5","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"State 不要直接更新状态。应当使用 setState()。构造函数是唯一能够初始化 this.state 的地方。 状态更新可能是异步的。React 可以将多个 setState() 调用合并成一个调用来提高性能。因为 this.props 和 this.state 可能是异步更新的，你不应该依靠它们的值来计算下一个状态。 数据自顶向下流动。父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。 经过计算后的值不应该赋给 state，正确的模式应该是在渲染时计算这些值。这样保证了计算后的值永远不会与派生出它的 props 值不同步。 在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:6","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"React 组件生命周期及使用场景 render() 唯一必须实现的方法 render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。 constructor(props) 用于初始化内部状态(很少使用) 唯一可以直接修改 state 的地方 static getDerivedStateFromProps(props, state) 当 state 需要从 props 初始化时使用 尽量不要使用(维护两者状态一致性会增加复杂度) 每次 render 都会调用 典型场景：表单控件获取默认值 componentDidMount() UI 渲染完成后调用 只执行一次 典型场景：获取外部资源初始化 state componentWillUnmount() 组件移除时调用 典型场景：释放资源 getSnapshotBeforeUpdate(prevProps, prevState) 在最近一次渲染输出（提交到 DOM 节点）之前调用。 典型场景：获取 render 之前的 DOM 状态(例如：滚动位置) componentDidUpdate(prevProps, prevState, snapshot) 每次 UI 更新时调用 典型场景：页面需要根据 props 变化重新获取数据 shouldComponentUpdate(nextProps, nextState) 决定 Virtual DOM 是否要重绘 一般可以由 PureComponent 自动实现 典型场景：性能优化 ","date":"2019-07-23","objectID":"/2019/07/react/:2:7","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"React 事件处理 React 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素的写法) 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。 你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this, 当你调用这个函数的时候 this 的值会是 undefined。 向事件处理程序传递参数 //两种方式是等价的，分别通过 arrow functions 和 Function.prototype.bind 来为事件处理函数传递参数。 //通过箭头函数的方式，事件对象必须显式的进行传递 \u003cbutton onClick={(e) =\u003e this.deleteRow(id, e)}\u003eDelete Row\u003c/button\u003e //但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面。 \u003cbutton onClick={this.deleteRow.bind(this, id)}\u003eDelete Row\u003c/button\u003e ","date":"2019-07-23","objectID":"/2019/07/react/:2:8","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"条件渲染 与运算符 \u0026\u0026 三目运算符 阻止组件渲染。在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:9","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"Keys Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的 id 作为元素的 key。当元素没有确定的 id 时，你可以使用他的序列号索引 index 作为 key。==如果列表项目的顺序可能会变化，我们不建议使用索引来用作键值，因为这样做会导致性能的负面影响==，还可能引起组件状态问题。如果你选择不指定显式的键值，那么 React 将默认使用索引用作为列表项目的键值。 元素的 key 只有放在其环绕数组的上下文中才有意义。比方说，如果你提取出一个 ListItem 组件，你应该把 key 保存在数组中的这个\u003cListItem /\u003e元素上，而不是放在 ListItem 组件中的\u003cli\u003e元素上。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:10","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"表单 在 HTML 当中，像\u003cinput\u003e,\u003ctextarea\u003e, 和 \u003cselect\u003e这类表单元素会维持自身状态，并根据用户输入进行更新。但在 React 中，可变的状态通常保存在组件的状态属性中，并且只能用 setState() 方法进行更新。我们通过使 react 变成一种单一数据源的状态来结合二者。React 负责渲染表单的组件仍然控制用户后续输入时所发生的变化。相应的，其值由 React 控制的输入表单元素称为“受控组件”。 多个输入的解决方法 //当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。 handleInputChange(event) { const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState({ [name]: value }); } ","date":"2019-07-23","objectID":"/2019/07/react/:2:11","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"状态提升 在 React 应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。然后，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的共同祖先中。 向下传递父组件的 State 及其更新方法。 状态提升要写更多的“炉墙代码”，比起双向绑定方式，但带来的好处是，你也可以花更少的工作量找到和隔离 bug。因为任何生活在某些组件中的状态数据，也只有该组件它自己能够操作这些数据，发生 bug 的表面积就被大大地减小了。 如果某些数据可以由 props 或者 state 推导出来，那么它很有可能不应该在 state 中出现。 ","date":"2019-07-23","objectID":"/2019/07/react/:2:12","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"扩展 ","date":"2019-07-23","objectID":"/2019/07/react/:3:0","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"理解 Virtual DOM 虚拟 DOM 如何工作(DIFF 算法) 广度优先分层比较，针对 UI 很少发生跨层移动 兄弟间位置移动会根据 key 交换位置 DOM 跨层移动 React 不会做检查，就是简单的删除然后添加 虚拟 DOM 的两个假设 组件的 DOM 结构是相对稳定的 类型相同的兄弟节点可以被唯一标识 ","date":"2019-07-23","objectID":"/2019/07/react/:3:1","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"组件设计模式 高阶组件 高阶组件接收组件作为参数，定义通用逻辑、状态，render 方法中将定义的状态和逻辑作为 props 传给接收的组件并直接返回。 高阶组件类似于已实现的功能接口，子组件引入高阶组件import 高阶组件函数名 form \"组件路径\"，在内部使用高阶组件将会传递的 props，然后导出通过高阶组件封装的组件给外部使用export default 高阶组件函数名(组件) 不要改变原始组件，高阶组件应该使用组合技术，将输入组件包裹到一个容器组件。 约定：贯穿传递不相关 props 属性给被包裹的组件 render() { // 过滤掉专用于这个阶组件的props属性， // 不应该被贯穿传递 const { extraProp, ...passThroughProps } = this.props; // 向被包裹的组件注入props属性，这些一般都是状态值或 // 实例方法 const injectedProp = someStateOrInstanceMethod; // 向被包裹的组件传递props属性 return ( \u003cWrappedComponent injectedProp={injectedProp} {...passThroughProps} /\u003e ); } 约定：包装显示名字以便于调试 //最常用的技术是包裹显示名字给被包裹的组件。所以，如果你的高阶组件名字是 withSubscription， //且被包裹的组件的显示名字是 CommentList，那么就是用 WithSubscription(CommentList)这样的显示名字 function withSubscription(WrappedComponent) { class WithSubscription extends React.Component { /* ... */ } WithSubscription.displayName = `WithSubscription(${getDisplayName( WrappedComponent )})`; return WithSubscription; } function getDisplayName(WrappedComponent) { return WrappedComponent.displayName || WrappedComponent.name || \"Component\"; } 告诫：不要在 render 方法内使用高阶组件 告诫：必须将静态方法做拷贝。当你应用一个高阶组件到一个组件时，原始组件被包裹于一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。 告诫：Refs 属性不能贯穿传递 典型场景：通用逻辑复用 参考：高阶组件 框架(外包装)组件 框架组件接收 props.children 作为可变的 UI 显示。定义通用 UI，变化部分使用 props.children，使用者决定这部分如何展示。 典型场景：通用 UI 复用 ","date":"2019-07-23","objectID":"/2019/07/react/:3:2","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"Context Context 通过组件树提供了一个传递数据的方法，从而避免了在每一个层级手动的传递 props 属性。 不要仅仅为了避免在几个层级下的组件传递 props 而使用 context，它是被用于在多个层级的多个组件需要访问相同数据的情景。 实例 // 创建一个 theme Context, 默认 theme 的值为 light const ThemeContext = React.createContext(\"light\"); function ThemedButton(props) { // ThemedButton 组件从 context 接收 theme return ( \u003cThemeContext.Consumer\u003e {theme =\u003e \u003cButton {...props} theme={theme} /\u003e} \u003c/ThemeContext.Consumer\u003e ); } // 中间组件 function Toolbar(props) { return ( \u003cdiv\u003e \u003cThemedButton /\u003e \u003c/div\u003e ); } class App extends React.Component { render() { return ( \u003cThemeContext.Provider value=\"dark\"\u003e \u003cToolbar /\u003e \u003c/ThemeContext.Provider\u003e ); } } 可以使用高阶组件的设计模式很容易的封装 Context const ThemeContext = React.createContext(\"light\"); // 在函数中引入组件 export function withTheme(Component) { // 然后返回另一个组件 return function ThemedComponent(props) { // 最后使用context theme渲染这个被封装组件 // 注意我们照常引用了被添加的属性 return ( \u003cThemeContext.Consumer\u003e {theme =\u003e \u003cComponent {...props} theme={theme} /\u003e} \u003c/ThemeContext.Consumer\u003e ); }; } React 以前使用实验性的 context API 运行，旧的 API 将会在 16.x 版本中得到支持，但使用到它的应用应该迁移到新版本。遗留的 API 将在未来的 React 版本中被移除。 Context 使用教程 ","date":"2019-07-23","objectID":"/2019/07/react/:3:3","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"脚手架工具 Create React App 是 Facebook 的一个最简依赖的脚手架工具，适合学习 React 或者开发简单应用。 Rekit 基于 Create React App 多整合了很多必要的库，同时提供拆分大型项目耦合度的架构。 Codesandbox 在线 IDE + 脚手架，不关注项目细节，打包部署过程隐藏。 ","date":"2019-07-23","objectID":"/2019/07/react/:3:4","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"生态圈 Redux Redux 是 React 全家桶的一员，Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 React Router React Router 是完整的 React 路由解决方案。React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。 webpack 前端打包工具 react-loadable 和 webpack 结合实现按需加载，提高 APP 第一次访问速度 import Loadable from 'react-loadable'; import Loading from './my-loading-component'; const LoadableComponent = Loadable({ loader: () =\u003e import('./my-component'), loading: Loading, }); export default class App extends React.Component { render() { return \u003cLoadableComponent/\u003e; } } ","date":"2019-07-23","objectID":"/2019/07/react/:3:5","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"问题 ","date":"2019-07-23","objectID":"/2019/07/react/:4:0","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"JAX 中 HTML 代码段被识别为字符串的问题 ","date":"2019-07-23","objectID":"/2019/07/react/:4:1","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"React 和直接修改 DOM 的前端框架的兼容性问题 ","date":"2019-07-23","objectID":"/2019/07/react/:4:2","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"参考 React 官方文档 ","date":"2019-07-23","objectID":"/2019/07/react/:5:0","tags":["框架"],"title":"React 的使用","uri":"/2019/07/react/"},{"categories":null,"content":"问题描述 Hibernate 使用多线程，且在线程内部获取对象懒加载的属性就会出现 No Session。 ","date":"2019-07-23","objectID":"/2019/07/hibernate-e1/:1:0","tags":["问题"],"title":"Hibernate 多线程下 No Session 问题","uri":"/2019/07/hibernate-e1/"},{"categories":null,"content":"产生原因 其他线程并未获取到Session。 ","date":"2019-07-23","objectID":"/2019/07/hibernate-e1/:2:0","tags":["问题"],"title":"Hibernate 多线程下 No Session 问题","uri":"/2019/07/hibernate-e1/"},{"categories":null,"content":"解决方式 // 解决方法1 public static boolean bindHibernateSessionToThread(SessionFactory sessionFactory) { if (TransactionSynchronizationManager.hasResource(sessionFactory)) { return true; } else { Session session = sessionFactory.openSession(); session.setFlushMode(FlushMode.MANUAL); SessionHolder sessionHolder = new SessionHolder(session); TransactionSynchronizationManager.bindResource(sessionFactory, sessionHolder); } return false; } // 将线程上绑定的Session关闭 public static void closeHibernateSessionFromThread(boolean participate, Object sessionFactory) { if (!participate) { SessionHolder sessionHolder = (SessionHolder)TransactionSynchronizationManager.unbindResource(sessionFactory); SessionFactoryUtils.closeSession(sessionHolder.getSession()); } } //使用(注意在线程中使用的对象要是在线程中查出来的，不能是查出来再开线程) SessionFactory sessionFactory = ContextHolder.getBean(SessionFactory.class); boolean participate = ConcurrentUtil.bindHibernateSessionToThread(sessionFactory); //...Method ConcurrentUtil.closeHibernateSessionFromThread(participate, sessionFactory); // 解决方法2 // 配置 Hibernate Lazy=\"false\" ","date":"2019-07-23","objectID":"/2019/07/hibernate-e1/:3:0","tags":["问题"],"title":"Hibernate 多线程下 No Session 问题","uri":"/2019/07/hibernate-e1/"},{"categories":null,"content":" # windows 查看占用端口的进程 netstat -ano|findstr \u003c端口号\u003e # windows 停止进程 taskkill /f /t /im \u003c进程id\u003e ","date":"2019-07-20","objectID":"/2019/07/idea-e1/:0:0","tags":["问题"],"title":"Idea 意外终止，Web 服务未停止，导致的端口被占用问题解决","uri":"/2019/07/idea-e1/"},{"categories":null,"content":"简介 Java 是一门面向对象编程语言，不仅吸收了 C++语言的各种优点，还摒弃了 C++里难以理解的多继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。Java 语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。 Java 具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。Java 可以编写桌面应用程序、Web 应用程序、分布式系统和嵌入式系统应用程序等。 ","date":"2019-07-18","objectID":"/2019/07/java/:1:0","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"JAVA SE ","date":"2019-07-18","objectID":"/2019/07/java/:2:0","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"异常体系 API Throwable 类 Error 类 Exception 类 RuntimeException 类 自定义异常方式 实现一个类并继承异常体系中的一个类，使其可以被抛出。还可以定义构造函数用来描述这个异常类。 异常处理方式 函数内容如果抛出编译时异常，那么要么函数声明时用 throws 声明，要么使用 try catch 处理，否则编译失败。 如果调用到了声明异常的函数，那么要么 throws,要么 try catch，否则编译失败。 功能内可以解决使用 try catch 解决；解决不了使用 throws 告诉调用者。 多 catch 情况，多 catch 的父类 catch 放在最下面 ","date":"2019-07-18","objectID":"/2019/07/java/:2:1","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"线程体系 API Runnable 接口 Thread 类 Lock 接口 Condition 接口 多线程的好处和弊端 解决了程序多个部分同时运行的问题 线程太多会导致效率的降低 开启多线程的方法 定义一个类继承 Thread 类，覆盖 Thread 类中的 run()方法，直接创建 Thread 类的子类线程对象，调用其 start()方法开启线程执行其 run()方法体的内容。 定义类实现 Runnable 接口，实现接口中的 run()方法，通过 Thread 类创建线程对象，并将 Runnable 接口的子类对象作为构造函数的参数进行传递，最后调用线程对象 start()方法开启线程。(常用) 使用匿名内部类复写 Thread 来调用 start()方法开启线程。或使用匿名内部类实现或 Runnable 作为参数传递给另一个匿名 Thread 对象调用 start()方法。(快速方式) 线程安全问题 前提 有多个线程在操作共享数据。 操作共享数据的代码有多条 原因 : 当一个线程在执行操作共享数据的多条代码中，其他代码参与了运算，并改变了共享数据的值，就会产生线程安全问题。 解决方法 : 同步。解决了线程的安全问题，但是相对的降低了效率，因为同步外的线程都会判断同步锁。要注意同步的多线程必须使用同一个锁。 多生产多消费问题解决方案 用 while 判断标记，解决线程获得执行权后，是否运行；用 notifyAll()唤醒线程，保证必然唤醒对方线程。(降低效率) 使用 jdk1.5 新增的用来代替 synchronized 和 Object 中关于线程监视操作的函数的 Lock 和 Condition 接口，只要在一个锁上创建两个监视器，然后使用 signal()方法唤醒对方监视器上的线程。 结束线程的方法 通常使用循环控制标记结束线程 当线程等待读不到标记时，使用线程类的 interrupt()方法，强制从等待状态唤醒，并在处理其会产生的 InterruptedException 时，令其读到结束标记。 ","date":"2019-07-18","objectID":"/2019/07/java/:2:2","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"集合体系 Collection 接口 List 接口(保证存取顺序，元素可以重复) Vector 类 ArrayList 类(数组数据结构，不同步。) LinkedList 类(链表数据结构，不同步。) Set 接口(保证对象唯一) HashSet 类(哈希表数据结构，不同步) LinkedHashSet 类(保证唯一的同时，保证存取顺序) TreeSet 类(二叉树结构，不同步。) Map 接口(存储一些具有对应关系的数据) Hashtable 类 HashMap 类(哈希表结构；不同步；允许 null 作为键值；) LinkedHashMap 类(在使用哈希表结构的同时，保证存取顺序。) TreeMap 类(二叉树结构；不同步) Iterator 接口(用于对集合进行遍历) Collections 类(集合排序；集合二分查找；最值查询；集合逆序；给所有元素赋值；集合随机排列；将指定集合变成同步集合；) Arrays 类(数组二分查找；数组复制；给所有元素赋值；排序；将数组转换位 List 集合) ","date":"2019-07-18","objectID":"/2019/07/java/:2:3","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"IO 体系 InputStream 抽象类(字节输入流) FileInputStream 类 OutputStream 抽象类(字节输出流) FileOutputStream 类 Reader 抽象类(字符输入流) InputStreamReader 类 Writer 抽象类(字符输出流) OutputStreamWriter 类 File 类(文件操作) ","date":"2019-07-18","objectID":"/2019/07/java/:2:4","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"网络体系 ","date":"2019-07-18","objectID":"/2019/07/java/:2:5","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"反射体系 Type 接口 ParameterizedType 接口 Class 类 AccessibleObject 类 Proxy 类 InvocationHandler 接口 ","date":"2019-07-18","objectID":"/2019/07/java/:2:6","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"其他常用类 Object String StringBuffer StringBuilder 基本数据类型对象包装类 Byte Short Integer Long Float Double Character Boolean System Runtime Process 抽象类 Math Random Date DateFormat 抽象类 SimpleDateFormat Calendar 抽象 Locale ","date":"2019-07-18","objectID":"/2019/07/java/:2:7","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"其他常用接口 Comparable 接口 Comparator 接口 ","date":"2019-07-18","objectID":"/2019/07/java/:2:8","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"JAVA EE ","date":"2019-07-18","objectID":"/2019/07/java/:3:0","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"Servlet API Servlet 接口 HttpServlet 类 ServletConfig 接口 用于加载 servlet 的初始化参数 HttpServlet 类 ServletContext 接口 表示一个当前的 web 应用环境。一个 web 应用中只有一个 ServletContext 上下文对象。 RequestDispatcher 接口 接收来自客户机的请求，并将它们发送到服务器上的任何资源(如 servlet、HTML 文件或 JSP 文件)。 ServletRequest 接口 获取请求信息 HttpServletRequest 接口 ServletResponse 接口 设置响应信息 HttpServletResponse Cookie 类 将会话数据保存在浏览器客户端 Cookie 数据类型只能保存非中文字符串类型的。可以保存多个 cookie，但是浏览器一般只允许存放 300 个 Cookie，每个站点最多存放 20 个 Cookie，每个 Cookie 的大小限制为 4KB。 HttpSession 接口 将会话数据保存到服务端 Filter 接口 FilterChain 接口 FilterConfig 接口 EventListener 接口 servlet 资源的查询过程 到当前 web 应用下的 web.xml 文件查找是否有匹配的 url-pattern 如果找到匹配的 url-pattern,则使用当前 servlet-name 的名称到 web.xml 文件中查询是否相同名称的 servlet 配置。如果找到，则取出对应的 servlet 配置信息中的 servlet-class 内容。通过反射,构造 Servlet 的对象,然后调用 Servlet 里面的方法 如果没有匹配的 url-pattern，则交给 tomcat 的内置的 DefaultServlet 处理。DefaultServlet 程序到 web 应用的根目录下查找是存在一个名称为\"uri 字符串值\"的静态文件。如果找到该文件，则读取该文件内容，返回给浏览器，如果找不到该文件，则返回 404 错误页面。 Sevlet 的生命周期 通过映射找到到 servlet-class 的内容 通过反射构造 FirstServlet 对象 创建 ServletConfig 对象，通过反射调用 init 方法 创建 request，response 对象，通过反射调用 service 方法 当 tomcat 服务器停止或 web 应用重新部署，通过反射调用 destroy 方法 Servlet 的多线程并发问题 servlet 对象在 tomcat 服务器是单实例多线程的。因为 servlet 是多线程的，所以当多个 servlet 的线程同时访问了 servlet 的共享数据，如成员变量，可能会引发线程安全问题。 把使用到共享数据的代码块进行同步（使用 synchronized 关键字进行同步） 建议在 servlet 类中尽量不要使用成员变量。如果确实要使用成员，必须同步。而且尽量缩小同步代码块的范围。（哪里使用到了成员变量，就同步哪里！！），以避免因为同步而导致并发效率降低。 转发和重定向 转发 地址栏不会改变 转发只能转发到当前 web 应用内的资源 可以在转发过程中，可以把数据保存到 request 域对象中 重定向 地址栏会改变，变成重定向到地址 重定向可以跳转到当前 web 应用，或其他 web 应用，甚至是外部域名网站 不能再重定向的过程，把数据保存到 request 中 本质是浏览器重新请求一次服务器的另一个 URL 域对象 HttpServletRequet 域对象 ServletContext 域对象 HttpSession 域对象 PageContext 域对象 过滤器 简介 Filter 也称之为过滤器，它是 Servlet 技术中最激动人心的技术，WEB 开发人员通过 Filter 技术，对 web 服务器管理的所有 web 资源：例如 Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现 URL 级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 作用 乱码处理 用户访问权限判断 执行过程 服务器创建 Filter 实例 执行其 init()方法 浏览器请求资源时，服务器调用过滤器链中的第一个过滤器的 doFilter()方法 在服务器调用的 doFilter()方法中，应用传入的 FilterChain 对象调用其 doFilter()方法，访问过滤器链中的下一个过滤器的 doFilter()方法或资源的 service()方法 调用完资源的 service()方法后会返回到最后一个调用的 doFilter()方法依次往前 服务器停止执行 destroy()方法 监听器 简介 Listener 用于监听 java web 程序中的事件，例如创建、修改、删除 Session、request、context 等，并触发响应的事件。 ","date":"2019-07-18","objectID":"/2019/07/java/:3:1","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"JSP ","date":"2019-07-18","objectID":"/2019/07/java/:3:2","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"JDBC ","date":"2019-07-18","objectID":"/2019/07/java/:3:3","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"JavaMail ","date":"2019-07-18","objectID":"/2019/07/java/:3:4","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"语言特性 ","date":"2019-07-18","objectID":"/2019/07/java/:4:0","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"面向对象 封装 隐藏对象的属性和实现细节，仅对外提供公共的访问方式。 将变化隔离；便于使用；提高重用性；提高安全性； 将不需要对外提供的内容都隐藏起来；把属性都隐藏提供公共方法对其访问。 继承 提高了代码的复用性；为多态提供了前提。 打破了封装性 子父类中成员变量的特点 子类的对象存储在堆中，包含一个父类空间用来存储父类的成员变量。 使用 super 来引用父类成员变量 子父类成员函数的特点-覆盖 当子类需要定义父类中某个方法的其他特有功能时，就使用覆盖。 静态只能覆盖静态或被静态覆盖。 子类方法覆盖父类方法时，子类权限必须要大于等于父类的权限 子父类中构造函数的特点 子类并不继承父类的构造函数；子类继承了父类获取到了父类中的内容，所有在使用父类内容之前要对其进行初始化，因此子类构造函数的第一行有个隐式的 super();；如果父类中没有定义空参的构造函数，那么子类构造函数必须使用 super 明确要调用父类中的哪个构造函数。 子类对象的初始化过程 堆内存对象的默认初始化 调用对应的构造函数，但并未执行初始化 在构造函数第一行会先执行父类的构造函数进行初始化 父类初始化完毕后，子类的构造函数初始化并不开始，而是先执行子类属性的显示初始化。 构造代码块初始化 最后进行子类构造函数的特定初始化 多态 表现形式 : 父类或接口引用指向子类对象 提高了代码的扩展性，前期定义的代码可以使用后期的内容 前期定义的代码不能调用后期子类的特有内容 前提 必须有关系：实现、继承； 必须有覆盖； 转型 向上转型限制对特有功能的访问 向下转型为了使用子类的特有方法 对于转型，自始至终都是子类对象在做着类型变化 类型判断 instanceof：用于判断对象的具体类型，只能用于引用数据类型的判断，通常在向下转型前用于引用类型的判断。 成员特点 变量 编译时参考引用变量所属的类中是否有调用的成员变量 运行时使用引用变量所属的类中的成员变量 函数 编译时参考引用变量所属的类中是否有调用的函数 运行时使用的是对象所属的类中的函数 静态函数 编译运行都参考引用变量所属的类中的方法 抽象 抽象类 应用场景 : 描述类的信息不足时使用 抽象类不可以被实例化；子类覆盖了抽象类的抽象方法后才可以实例化；存在构造函数用于给子类初始化 接口 应用场景 : 当一个类中的方法都是抽象的时候，可以使用 interface 定义接口,接口的出现避免了单继承的局限性 接口是对外暴露的规则；接口是程序的功能扩展；接口的出现降低了耦合性； 接口中的成员都有固定的修饰符 全局常量：public static final 抽象方法：public abstract ","date":"2019-07-18","objectID":"/2019/07/java/:4:1","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"泛型 简介 泛型是 JDK1.5 以后才有的;将运行时期的 ClassCastException 转到了编译时期;且可以避免频繁类型转化！ 作用 设计公用的类、方法，对公用的业务实现进行抽取 使程序更灵活 泛型类 当类中操作的引用数据类型不确定时，就用泛型表示。 在创建爱泛型类对象的时候，确定类型 泛型方法 当方法操作的引用数据类型不确定时，可以给方法定义独有的泛型；当方法静态时，不能使用类上定义的泛型，如果需要使用泛型，只能定义在方法上。 在使用泛型方法的时候，确定泛型类型 泛型接口 当接口中操作的引用数据类型不确定时，就用泛型表示 如果实现接口的类是泛型类，那么类型在创建泛型类的时候确定 也可以在业务实现类中直接确定接口的类型 定义语法 泛型类：修饰符 class 类名\u003c泛型类型\u003e{code...}；创建泛型类时，需要在左右类名后加上泛型,且必须相同不存在左边泛型限定是右边泛型限定的父类的情况。 泛型接口：类似于类 泛型方法：修饰符 \u003c泛型类型\u003e 返回类型 方法名(参数列表){code...}；使用泛型方法时，会自动根据传入的参数判断定义的泛型类型。 泛型限定 通过为引用类型的变量的泛型添加泛型限定，来限定被指向的对象能够使用的泛型定义 ?(? extends Object)的简写 当类型不明确，又不对其进行操作时(或者只使用 Object 的方法操作)，就使用通配符明确。 (上限)? extends E 接受 E 类型或 E 的子类型对象，能使用 E 类型的方法。 当使用集合存储元素(一堆)时，作为参数被存储的集合同样需要指定泛型，为了能够存储元素及其子类对象，就需要进行泛型限定，要不然就会因为定义引用变量的泛型必须和实际参数传递的泛型定义一致的原因，导致不能存储包含元素的子类对象的集合。也就是说作为参数传递的集合泛型的定义需要能接受泛型定义为父类的集合和泛型定义为其子类的集合。 (下限)? super E 接受 E 类型或者 E 类型的父类型。 当传递一个操作元素的需要定义泛型的参数(Comparator 等)时，为了能够接受泛型定义为自身的和泛型定义为其父类的对象(能以父类的方法操作子类的对象)，就使用泛型的下限。例如，为了给存储学生的集合排序，应该能够传递给人排序的比较器。 擦除和补偿 编译时，为了兼容以前的类加载器，会将泛型去掉，生成的 class 文件是不带泛型的。 运行时，通过获取元素的类型进行自动的转换动作，不许要再强制转换了。 ","date":"2019-07-18","objectID":"/2019/07/java/:4:2","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"注解 简介 从 JDK 1.5 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注解)。 作用 告诉编译器如何运行程序 简化(取代)配置文件(不便于维护：例如修改配置，要重新编译！) ","date":"2019-07-18","objectID":"/2019/07/java/:4:3","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"包 对类文件进行分类管理；给类提供多层命名空间；包也是一种封装形式； ","date":"2019-07-18","objectID":"/2019/07/java/:4:4","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"跨平台 对于同一个程序，在编译成中间码之后，在不同平台上使用不同的虚拟机(JVM)进行解释运行，就实现了 java 的跨平台性。 ","date":"2019-07-18","objectID":"/2019/07/java/:4:5","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"其他 特别自动类型转换 Java 中涉及 byte、short 和 char 类型的运算操作首先会把这些值转换为 int 类型，然后对 int 类型值进行运算，最后得到 int 类型的结果。因此，如果把两个 byte 类型值相加，最后会得到一个 int 类型的结果。如果需要得到 byte 类型结果，必须将这个 int 类型的结果显式转换为 byte 类型。 因为代码中的常量通常是 int 类型，因此使用它们对 byte、short、char 进行赋值时，会有一次隐式的范围检测和向下的类型转换。 对于运算赋值符，它们在运算后会根据左边用来接收的变量的类型，做一次隐式的类型转换(可以向下)。 编译时期会完成所有全是常量的表达式的计算，包括全是字符串的拼接。 类加载时会创建所有字符串常量对象存入常量池 两同两小一大原则 ：方法名和返回值列表相同，则子类返回类型小于等于父类返回类型、子类抛出异常小于等于父类异常、子类访问权限大于父类访问权限 ","date":"2019-07-18","objectID":"/2019/07/java/:4:6","tags":["语言"],"title":"Java 知识总结","uri":"/2019/07/java/"},{"categories":null,"content":"第一课 了解 SQL 数据类型兼容问题 数据类型及其名称是 SQL 不兼容的一个主要原因。虽然大多数基本数据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是，偶然会有相同的数据类型在不同的 DBMS 中具有不同的名称。对此用户毫无办法，重要的是在创建表结构时要记住这些差异。 应该总是定义主键 虽然并不总是需要主键，但多数数据库设计者都会保证他们创建的每个表具有一个主键，以便于以后的数据操作和管理。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:1:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第二课 检索数据 不使用通配符 一般而言，除非你确实需要表中的每一列，否则最好别使用 * 通配符。虽然使用通配符能让你自己省事，不用明确列出所需列，但检索不需要的列通常会降低检索和应用程序的性能。 不能部分使用 DISTINCT DISTINCT 关键字作用于所有的列，不仅仅是跟在其后的那一列。例 如，你指定 SELECT DISTINCT vend_id, prod_price ... ，除非指定的 两列完全相同，否则所有的行都会被检索出来。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:2:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第三课 排序检索数据 未排序数据 如果没有明确排序查询结果，则返回的数据没有特定的顺序。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。如果不排序，数据一般将以它在底层表中出现的顺序显示，这有可能是数据最初添加到表中的顺序。但是如果数据随后进行过更新或删除，那么这个顺序将会受到 DBMS 重用回收存储空间的方式的影响。因此，如果不明确控制的话，则最终的结果不能也不应该依赖该排序顺序。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:3:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第四课 过滤数据 SQL 过滤与应用过滤 优化数据库后可以更快速有效地对数据进行过滤。而让客户端应用或开发语言处理数据库的工作将会极大地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户端过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:4:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第五课 高级数据过滤 在 WHERE 子句中使用圆括号 AND 在求值过程中优先级比 OR 更高。任何时候使用具有 AND 和 OR 操作符的 WHERE 子句，都应该使用圆括号明确地分组操作符。不要过分依赖默认求值顺序，即使它确实如你希望的那样。使用圆括号没有什么坏处，它能消除歧义。 为什么要使用 IN 操作符 代替 OR？ 在有很多合法选项时，IN 操作符的语法更清楚，更直观。在与其他 AND 和 OR 操作符组合使用 IN 时，求值顺序更容易管理。IN 操作符一般比一组 OR 操作符执行得更快。IN 的最大优点是可以包含其他 SELECT 语句，能够更动态地建立 WHERE 子句。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:5:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第六课 用通配符进行过滤 使用通配符的技巧 通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间。不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:6:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第七课 创建计算字段 客户端与服务器的格式 在 SQL 语句内可完成的许多转换和格式化工作都可以直接在客户端应用程序内完成。但一般来说，在数据库服务器上完成这些操作比在客户端中完成要快得多。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:7:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"第八课 使用函数处理数据 函数带来的问题 不可移植 为了代码的可移植，许多 SQL 程序员不赞成使用特定于实现的功能。虽然这样做很有好处，但有的时候并不利于应用程序的性能。如果不使用这些函数，编写某些应用程序代码会很艰难。必须利用其他方法来实现 DBMS 可以非常有效完成的工作。 是否应该使用函数？ 现在，你面临是否应该使用函数的选择。决定权在你，使用或是不使用也没有对错之分。如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写的 SQL 代码的含义。 ","date":"2019-07-18","objectID":"/2019/07/sql-book1/:8:0","tags":["读书"],"title":"《SQL 必知必会》读书笔记","uri":"/2019/07/sql-book1/"},{"categories":null,"content":"简介 定义：JavaScript 一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言。 产生原因：网页没有复杂交互行为。 ","date":"2019-07-18","objectID":"/2019/07/javascript/:1:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"语法 ","date":"2019-07-18","objectID":"/2019/07/javascript/:2:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"变量类型 number string boolean object function null undefined ","date":"2019-07-18","objectID":"/2019/07/javascript/:2:1","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"关键字 流程控制 return continue break do while for if else switch case 定义 var ：定义变量 let : 不可重复声明、块级作用域(ES6+) const : 不可重复声明、块级作用域(ES6+) function new 异常处理 try ：测试代码块的错误 catch：处理错误 finally throw ：创建自定义错误 类型判断 typeof instanceof 其他 this in : 与 for 一起使用用于遍历对象的属性名或判断某个对象是否具有某个属性 delete : 删除对象的某个属性，只能删除自身定义的公有属性，即\"this.属性名\"定义的属性，而不能删除私有属性或通过 proptotype 定义的公有属性（已实践）。此外可删除直接在对象上添加的属性，如var a = new Object();a.name = \"name\"; delete a.name; with : 引用一个对象，使访问属性与方法更加方便（只能访问与修改属性，不能增加属性与方法） ","date":"2019-07-18","objectID":"/2019/07/javascript/:2:2","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"运算符 数学运算符 : +,-,*,/,% 比较运算符 : \u003e,\u003c,==,!=,\u003e=,\u003c=,===,!== 逻辑运算符 : \u0026\u0026,||,! 位操作符 : ^,~,\u0026,|,«,»,»\u003e ","date":"2019-07-18","objectID":"/2019/07/javascript/:2:3","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"函数的定义 正常方式function mysum(num1,num2){return num1+num2;} 直接量/匿名方式var mysum = function(num1,num2){return num1+num2;} 构造器方式new Function(\"num1\",\"num2\",\"return num1+num2;\") 箭头函数(ES6) ","date":"2019-07-18","objectID":"/2019/07/javascript/:2:4","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"常用对象 ","date":"2019-07-18","objectID":"/2019/07/javascript/:3:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"内建对象 Math Date getTime() : 获取毫秒值 String length : 字符串的长度 indexOf() : 检索字符串。 substr() : 从起始索引号提取字符串中指定数目的字符。 split() : 把字符串分割为字符串数组。 Array length : 设置或返回数组中元素的数目。 join() : 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。 push() : 向数组的末尾添加一个或更多元素，并返回新的长度。 splice() : 删除元素，并返回删除元素 RegExp 修饰符 i : 执行对大小写不敏感的匹配。 g : 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。 中括号 [abc] : 查找方括号之间的任何字符。 [^abc] : 查找任何不在方括号之间的字符。 [0-9] : 查找任何从 0 至 9 的数字。 [a-z] : 查找任何从小写 a 到小写 z 的字符。 [A-Z] : 查找任何从大写 A 到大写 Z 的字符。 [A-z] : 查找任何从大写 A 到小写 z 的字符。 元字符 . : 查找单个字符，除了换行和行结束符。 \\w : 查找任意一个字母、数字或下划线字符。 \\W : 查找非\\w 字符。 \\d : 查找数字。 \\D : 查找非数字字符。 \\s : 查找空白字符。 \\S : 查找非空白字符。 \\b : 匹配单词边界。 \\B : 匹配非单词边界。 量词 n+ : 匹配任何包含至少一个 n 的字符串。 n* : 匹配任何包含零个或多个 n 的字符串。 n? : 匹配任何包含零个或一个 n 的字符串。 n{X} : 匹配包含 X 个 n 的序列的字符串。 n{X,Y} : 匹配包含 X 至 Y 个 n 的序列的字符串。 n{X,} : 匹配包含至少 X 个 n 的序列的字符串。 n$ : 匹配任何结尾为 n 的字符串。 ^n : 匹配任何开头为 n 的字符串。 ?=n : 匹配任何其后紧接指定字符串 n 的字符串。 ?!n : 匹配任何其后没有紧接指定字符串 n 的字符串。 ","date":"2019-07-18","objectID":"/2019/07/javascript/:3:1","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"HTML DOM 对象 document document.getElementById() : 返回对拥有指定 id 的第一个对象的引用。 element id : 设置或者返回元素的 id。 className : 设置或返回元素的 class 属性 style : 设置或返回元素的样式属性 title : 设置或返回元素的 title 属性 getAttribute() : 返回指定元素的属性值 setAttribute() : 设置或者改变指定属性并指定值 innerHTML : 设置或者返回元素的内容 outerHTML : 设置或返回元素的全部内容包括标签部分 clientHeight : 在页面上返回内容的可视高度（不包括边框，边距或滚动条） clientWidth : 在页面上返回内容的可视宽度（不包括边框，边距或滚动条） scrollHeight : 返回整个元素的高度（包括带滚动条的隐蔽的地方） scrollTop : 返回滚动的高度 ","date":"2019-07-18","objectID":"/2019/07/javascript/:3:2","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"HTML BOM 对象 window alert() : 显示带有一段消息和一个确认按钮的警告框。 setInterval(函数,毫秒数) : 每隔一段时间执行函数 clearInterval(定时器对象) : 结束定时器 setTimeout(函数,毫秒数) : 一段时间后执行函数 clearTimeout(超时器对象) : 结束超时器 location href : 返回完整的 URL(直接使用 location 就相当于调用这个属性) history back() : 加载 history 列表中的前一个 URL forward() : 加载 history 列表中的下一个 URL go() : 加载 history 列表中的某个具体页面 screen availHeight : 返回屏幕的高度（不包括 Windows 任务栏） availWidth : 返回屏幕的宽度（不包括 Windows 任务栏） height : 返回屏幕的总高度 width : 返回屏幕的总宽度 navigator userAgent : 返回由客户机发送服务器的 user-agent 头部的值 ","date":"2019-07-18","objectID":"/2019/07/javascript/:3:3","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"AJAX 对象 ActiveXObject XMLHttpRequest ","date":"2019-07-18","objectID":"/2019/07/javascript/:3:4","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"常用全局方法 parseInt() : 字符串转换整型 eval() : 执行字符串表达式，如果是变量需要加上括号：eval(\"(“+var+”)\") encodeURI(string)：对 URI 字符串进行 UTF-8 的编码 扩展 ","date":"2019-07-18","objectID":"/2019/07/javascript/:4:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"ES6 ","date":"2019-07-18","objectID":"/2019/07/javascript/:5:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"定义相关 let : 不可重复声明、块级作用域 const : 不可重复声明、块级作用域 解构赋值 左右两边结构必须一致 let [a,b,c] = [1,2,3]; let {a,b,c} = {a:1,b:2,c:3}; 右边必须符合语法 let {a,b,c} = {1,2,3};//错误 声明和赋值不能分开 ","date":"2019-07-18","objectID":"/2019/07/javascript/:5:1","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"函数相关 箭头函数(args) =\u003e { code... } 如果只有一个参数 () 可以省 如果只有一个 {return } 可以省 箭头函数不会绑定 this。 或则说箭头函数不会改变 this 本来的绑定。 多参数收集(...args) 将函数的剩余参数接收到一个数组，必须是最后一个参数。 多参数展开...args 将 args 的内容展开成 a,b,c 的形式。 默认参数function(a=1){ code...} ","date":"2019-07-18","objectID":"/2019/07/javascript/:5:2","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"数组对象常用新增方法 map(callback) : 映射函数 reduce(callback) : 汇总函数 filter(callback) : 过滤函数 ","date":"2019-07-18","objectID":"/2019/07/javascript/:5:3","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"模板字符串 用 `str` 反单引号定义字符串 可以在其中使用 ${var} 嵌入变量(未定义报错)，如果嵌入的是对象会调用其 toString()方法。 可以折行 可以嵌套 ","date":"2019-07-18","objectID":"/2019/07/javascript/:5:4","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"构造 Date 对象的字符串格式问题 JavaScript 构造 Date 对象时要传的字符串标准格式为 yyyy/MM/dd HH:mm:ss，正常情况下日期字符串的格式为 yyyy-MM-dd HH:mm:ss ，无法直接使用(Chrome 可以，IE 不可以)。需要字符串替换后使用 replace(/-/g,\"/\")。 参考 JavaScript 手册 ","date":"2019-07-18","objectID":"/2019/07/javascript/:6:0","tags":["语言"],"title":"JavaScript 知识总结","uri":"/2019/07/javascript/"},{"categories":null,"content":"简介 定义：层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 产生原因：单用 HTML 写出的页面显示的难看。 ","date":"2019-07-17","objectID":"/2019/07/css/:1:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"常用样式 ","date":"2019-07-17","objectID":"/2019/07/css/:2:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"字体 font-family : 字体类型 font-size : 字体大小 ","date":"2019-07-17","objectID":"/2019/07/css/:2:1","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"文本 color : 颜色 line-height : 行高 text-align : 对齐 text-shadow : 设置文字阴影 ","date":"2019-07-17","objectID":"/2019/07/css/:2:2","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"显示和隐藏 display none : 隐藏不占位 block : 块显示 inline : 行内显示 visibility hidden : 隐藏占位 visible : 显示 opactity : 设置透明度 ","date":"2019-07-17","objectID":"/2019/07/css/:2:3","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"尺寸 width : 设置宽度(屏幕自适应宽度 100%) height : 设置高度 max-width min-width max-height min-height ","date":"2019-07-17","objectID":"/2019/07/css/:2:4","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"定位 position absolute : 绝对定位(释放文档流中的位置，第一个定位的父标签左上角是原点) relative : 相对定位(不释放文档流中的位置，自己是原点) fixed : 固定定位 left : 设置左侧距原点的长度 top : 设置上方的距原点的长度 right : 设置右侧距原点的长度 bottom : 设置底部距原点的距离 z-index : 定义 z 轴高度(不设置为 0) vertical-align : 设置元素的垂直对齐方式。 ","date":"2019-07-17","objectID":"/2019/07/css/:2:5","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"内外边距 margin-top : 上部外边距 margin-right : 右侧外边距 margin-bottom : 底部外边距 margin-left : 左侧外边距 margin(缩写) : 全部、上下/左右、上/左右/下、上/右/下/左 padding-top : 上部内边距 padding-right : 右侧内边距 padding-bottom : 底部内边距 padding-left : 左侧内边距 padding(缩写) : 全部、上下/左右、上/左右/下、上/右/下/左 ","date":"2019-07-17","objectID":"/2019/07/css/:2:6","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"浮动和清除浮动 float : 设置浮动(只能在浮动之前文档流中的位置的往左或往右浮动) clear : 清除浮动(如果一个盒子里的 div 都浮动，就要在添加一个清除浮动的 div 把盒子的位置撑开) ","date":"2019-07-17","objectID":"/2019/07/css/:2:7","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"背景 background-color : 背景颜色 background-image : 背景图片 background-repeat : 背景图是否重复 background-attachment : 背景图片是否固定 background-position : 背景图片定位(可以使用%和 px 值和英语单词) background(缩写形式) : #ccc url(‘xxx.png’) no-repeat fixed 50% 50% background-size : 设置背景图片的尺寸 background-origin : 设置背景图的位置(padding-box\\border-box\\content-box) ","date":"2019-07-17","objectID":"/2019/07/css/:2:8","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"边框 border-width : 边框粗细 border-style : 边框样式 border-color : 边框颜色 border(缩写形式) : 1px solid #ccc border-left : 左侧边框 border-top : 顶部边框 border-right : 右侧边框 border-bottom : 底部边框 border-radius : 设置圆角 box-shadow : 设置阴影 ","date":"2019-07-17","objectID":"/2019/07/css/:2:9","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"鼠标 cursor : 改变鼠标样式(text\\pointer\\default\\wait\\help\\crosshair) ","date":"2019-07-17","objectID":"/2019/07/css/:2:10","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"表格 border-collapse : 表格边框是否合并 border-spacing : 表格边框之间的距离 ","date":"2019-07-17","objectID":"/2019/07/css/:2:11","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"滚动条 overflow : 设置滚动条状态(hidden、auto、scroll) ","date":"2019-07-17","objectID":"/2019/07/css/:2:12","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"选择符 ","date":"2019-07-17","objectID":"/2019/07/css/:3:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"元素选择符 通配选择符 * { color: #f00; } 类型选择符 p { font-size: 13px; } ID 选择符 #id { color: #f00; } 类选择符 .className { color: #f00; } ","date":"2019-07-17","objectID":"/2019/07/css/:3:1","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"关系选择符 包含选择符 ul li { color: #f00; } 子选择符 .test \u003e li \u003e a { color: #f00; } 相邻选择符 p + p { color: #f00; } 兄弟选择符 h3 ~ p { color: #f00; } table th:first-of-type { width: 100px; } ","date":"2019-07-17","objectID":"/2019/07/css/:3:2","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"属性选择符 选择符 描述 E[att] 选择具有 att 属性的 E 元素。 E[att = “val”] 选择具有 att 属性且属性值等于 val 的 E 元素。 E[att ~= “val”] 选择具有 att 属性且属性值为一用空格分隔的字词列表，其中一个等于 val 的 E 元素。 E[att ^= “val”] 选择具有 att 属性且属性值为以 val 开头的字符串的 E 元素。 E[att $= “val”] 选择具有 att 属性且属性值为以 val 结尾的字符串的 E 元素。 E[att *= “val”] 选择具有 att 属性且属性值为包含 val 的字符串的 E 元素。 E[att |= “val”] 选择具有 att 属性且属性值为以 val 开头并用连接符”-“分隔的字符串的 E 元素，如果属性值仅为 val，也将被选择。 ","date":"2019-07-17","objectID":"/2019/07/css/:3:3","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"伪类选择符 选择符 版本 描述 E:link CSS1 设置超链接a在未被访问前的样式。 E:visited CSS1 设置超链接a在其链接地址已被访问过时的样式。 E:hover CSS1/2 设置元素在其鼠标悬停时的样式。 E:active CSS1/2 设置元素在被用户激活（在鼠标点击与释放之间发生的事件）时的样式。 E:focus CSS1/2 设置元素在成为输入焦点（该元素的onfocus事件发生）时的样式。 E:first-child CSS2 匹配父元素的第一个子元素E。 E:last-child CSS3 匹配父元素的最后一个子元素E。 E:only-child CSS3 匹配父元素仅有的一个子元素E。 E:nth-child(n) CSS3 匹配父元素的第n个子元素E。 E:empty CSS3 匹配没有任何子元素（包括text节点）的元素E。 E:checked CSS3 匹配用户界面上处于选中状态的元素E。(用于input type为radio与checkbox时) E:disabled CSS3 匹配用户界面上处于禁用状态的元素E。 ","date":"2019-07-17","objectID":"/2019/07/css/:3:4","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"伪对象选择符 选择符 描述 E::first-letter 设置对象内的第一个字符的样式。 E::first-line 设置对象内的第一行的样式。 E::before 设置在对象前（依据对象树的逻辑结构）发生的内容。用来和 content 属性一起使用 E::after 设置在对象后（依据对象树的逻辑结构）发生的内容。用来和 content 属性一起使用 E::placeholder 设置对象文字占位符的样式。 E::selection 设置对象被选择时的颜色。 ","date":"2019-07-17","objectID":"/2019/07/css/:3:5","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"扩展 ","date":"2019-07-17","objectID":"/2019/07/css/:4:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"几种颜色的表示方式 英语表示 十进制表示 : rgb(); 十六进制表示 : #000000; 带透明度十进制 : rgba(); ","date":"2019-07-17","objectID":"/2019/07/css/:4:1","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"问题 ","date":"2019-07-17","objectID":"/2019/07/css/:5:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"sup 标签导致行距变大的问题 问题描述 使用 \u003csup\u003e 标签时，行距变大。 产生原因 \u003csup\u003e 标签可定义上标文本，HTML 默认的上标样式实现是会影响行高的。 解决方式 sup{ font-size:75%; line-height:0; position:relative; vertical-align:baseline; top:-0.5em; } ","date":"2019-07-17","objectID":"/2019/07/css/:5:1","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"参考 CSS 手册 ","date":"2019-07-17","objectID":"/2019/07/css/:6:0","tags":["语言"],"title":"CSS 知识总结","uri":"/2019/07/css/"},{"categories":null,"content":"简介 HTML 是一种用来描述网页的超文本标记语言，而不是编程语言，超文本就是指可以包含图片、链接，甚至音乐、程序等非文字元素。HTML 使用标记来描述网页，使用事件来处理交互。 ","date":"2019-07-17","objectID":"/2019/07/html/:1:0","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"基础 ","date":"2019-07-17","objectID":"/2019/07/html/:2:0","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"文档结构 \u003c!-- 声明HTML文档 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 语言，中文简体：zh-Hans，中文繁体：zh-Hant --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 文档头部，设置文档编码集，引入的css、Script等 --\u003e \u003chead\u003e \u003c!-- meta标签设置网页中的元数据 --\u003e \u003c!-- 字符集 --\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003e网页标题\u003c/title\u003e \u003c!-- CSS引入 --\u003e \u003clink rel=\"stylesheet\" href=\"style.css\" /\u003e \u003c!-- JS引入 --\u003e \u003cscript src=\"script.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 文档主体 --\u003e \u003c!-- 主要放置html标签 --\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-07-17","objectID":"/2019/07/html/:2:1","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"元素 元素是标签、标签的属性与其包装的内容的总称。 简单的了解一下元素属性 元素属性包含元素的额外信息，这些信息不会出现在实际的内容中,HTML 属性大致分为 3 类：全局属性(id、class、style、title)、某一类元素属性、某一个元素属性。HTML 属性写在 HTML 元素开始标签中，与标签名用空格分隔，然后就是我们元素的属性，属性一般为属性名=\"属性值”，属性值必须用双引号包裹，也有单独出现的属性如 input 的布尔属性 disabled。 块级元素和行内元素 在 HTML 中有两种你需要知道的重要元素类别，块级元素和行内元素。 块级元素默认占据整行宽度，在页面中以块的形式展现 —— 相对与其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。块级元素通常用于展示页面上结构化的内容，例如段落、列表、导航菜单、页脚等等。一个以 block 形式展现的块级元素不会被嵌套进行内元素中，但可以嵌套在其它块级元素中，如(p、div、hn、ul、ol、li)。 行内元素同行显示，默认宽度由内容决定，通常出现在块级元素中并包裹文档内容的一小部分，而不是一整个段落或者一组内容。行内元素不会导致文本换行：它通常出现在一堆文字之间例如超链接元素或者强调元素。 常用基础元素 标题 \u003ch1\u003e这是H1标签，块级标签\u003c/h1\u003e \u003ch2\u003eH2\u003c/h2\u003e \u003ch3\u003eH3\u003c/h3\u003e \u003ch4\u003eH4\u003c/h4\u003e \u003ch5\u003eH5\u003c/h5\u003e \u003ch6\u003eH6\u003c/h6\u003e 段落 \u003cp\u003e这是段落，块级标签，自动换行\u003c/p\u003e \u003cp\u003e段落2\u003c/p\u003e 图片 \u003cimg src=\"图片地址\" alt=\"图片描述\" width=\"50\" height=\"50\" /\u003e 超链接 \u003ca href=\"地址\" target=\"_blank\"\u003e这是超链接\u003c/a\u003e 包裹分隔块级元素 \u003cdiv\u003e \u003ch2\u003e区块标题\u003c/h2\u003e \u003cp\u003e区块描述文字\u003c/p\u003e \u003c/div\u003e 包裹分隔行内元素 \u003cspan\u003e作者：xxx\u003c/span\u003e \u003cspan\u003e发布时间：xx-xx-xx\u003c/span\u003e \u003cspan\u003e浏览量：xxxx\u003c/span\u003e 列表元素 有序列表 \u003col\u003e \u003cli\u003e苹果\u003c/li\u003e \u003cli\u003e香蕉\u003c/li\u003e \u003cli\u003e菠萝\u003c/li\u003e \u003cli\u003e西瓜\u003c/li\u003e \u003cli\u003e芒果\u003c/li\u003e \u003c/ol\u003e 无序列表 \u003cul\u003e \u003cli\u003e苹果\u003c/li\u003e \u003cli\u003e香蕉\u003c/li\u003e \u003cli\u003e菠萝\u003c/li\u003e \u003cli\u003e西瓜\u003c/li\u003e \u003cli\u003e芒果\u003c/li\u003e \u003c/ul\u003e 表格元素 标题（caption）、表头单元格（th）、头部（thread）、主体（tbody）、行（tr）、单元格（td）、底部（tfoot） \u003c!-- cellspacing——单元格间距，单元格之间的距离 cellpadding——单元格边距，单元格与边框之间的距离 --\u003e \u003ctable border=\"1\" cellspacing=\"0\" cellpadding=\"5\"\u003e \u003ccaption\u003e 成绩表 \u003c/caption\u003e \u003cthead\u003e \u003ctr\u003e \u003ctd\u003eFirst Name\u003c/td\u003e \u003ctd\u003eLast Name\u003c/td\u003e \u003ctd\u003ePoints\u003c/td\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eJill\u003c/td\u003e \u003ctd\u003eSmith\u003c/td\u003e \u003ctd\u003e50\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eEve\u003c/td\u003e \u003ctd\u003eJackson\u003c/td\u003e \u003ctd\u003e94\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eJohn\u003c/td\u003e \u003ctd\u003eDoe\u003c/td\u003e \u003ctd\u003e80\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eAdam\u003c/td\u003e \u003ctd\u003eJohnson\u003c/td\u003e \u003ctd\u003e67\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd colspan=\"2\"\u003e跨列的表格\u003c/td\u003e \u003ctd\u003e100\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd rowspan=\"2\"\u003e跨行的表格\u003c/td\u003e \u003ctd\u003e99\u003c/td\u003e \u003ctd\u003e99\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e88\u003c/td\u003e \u003ctd\u003e88\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd rowspan=\"2\" colspan=\"2\"\u003e跨行又跨列的表格\u003c/td\u003e \u003ctd\u003e22\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e11\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 表单元素 表单标签的属性 属性名称 描述 name 表单的名称 action 表单数据接受地址 target 打开 url 的方式，_blank 新窗口，_self 当前窗口 method 数据传送方法，get:通过 url 地址传送参数,网址中可以看到数据，post:后台传送 enctype 发送前如何将数据进行编码，仅与 method=\"post\"配对使用 application/x-www-form-urlencoded 默认值，发送前对所有字符进行编码：空格转+号，特殊字符传 ASCII 16 进制值 multipart/form-data 不对发送字符进行编码，在上传文件时，必须设置 text/plain 纯文本方式，仅将空格转为\"+\"号，不对特殊字符编码 表单域\u003cinput\u003e的属性 属性名称 描述 type 元素的类型，如 text 文本框、radio 单选按钮、select 下拉框等 name 元素的名称，主要用于服务端数据传送 value 元素的默认值，可当占位符 size 以字符计算的元素可见宽度，注意，不是像素或百分比 maxlength 元素允许的最大字符长度 disabled 禁用该控件，此时，既不能选择，也不能点击 readonly 该控件字段内容只读，不允许修改 \u003c!-- 单行文本 --\u003e \u003cinput type=\"text\" name=\"MyName\" value=\"不能为空\" /\u003e \u003c!-- 密码 --\u003e \u003cinput type=\"password\" name=\"pwd\" id=\"pwd\" /\u003e \u003c!-- 单选按钮 --\u003e \u003cinput type=\"radio\" name=\"gender\" id=\"male\" value=\"male\" checked /\u003e男 \u003cinput type=\"radio\" name=\"gender\" id=\"female\" value=\"female\" /\u003e女 \u003c!-- 复选框 --\u003e \u003cinput type=\"checkbox\" name=\"language\" id=\"php\" value=\"php\" checked /\u003e \u003cinput type=\"checkbox\" name=\"language\" id=\"java\" value=\"java\" /\u003e \u003c!-- 自定义按钮 --\u003e \u003cinput type=\"button\" value=\"点击\" /\u003e \u003c!-- 提交按钮 --\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c!-- 重置按钮 --\u003e \u003cinput type=\"reset\" value=\"重置\" /\u003e \u003c!-- 文件上传 --\u003e \u003cform action=\"\" method=\"post\" enctype=\"multipart/form-data\"\u003e \u003c!-- 支持批量上传 --\u003e \u003cinput type=\"file\" name=\"file\" id=\"file\" multiple /\u003e \u003c/form\u003e \u003c!-- 图像按钮 --\u003e \u003cinput type=\"image\" src=\"url\" alt=\"图片说明\" /\u003e \u003c!-- 隐藏字段 --\u003e \u003c!-- 用于存储一些字段的默认值，如ID，用户不可见 --\u003e \u003cinput type=\"hidden\" name=\"id\" value=\"1\" /\u003e \u003c!-- 下拉框 --\u003e \u003cselect name=\"address\" id=\"address\"\u003e \u003coption value=\"bj\" selected\u003e北京\u003c/option\u003e \u003coption value=\"\"\u003e上海\u003c/option\u003e \u003coption value=\"\"\u003e天津\u003c/option\u003e \u003coption value=\"\"\u003e广州\u003c/option\u003e \u003coption value=\"\"\u003e深圳\u003c/option\u003e \u003coption value=\"\"\u003e重庆\u003c/option\u003e \u003c/select\u003e \u003c!-- 下拉框分组 --\u003e \u003cselect name=\"address\" id=\"address\"\u003e \u003coptgroup label=\"直辖市\"\u003e \u003coption value=\"bj\" selected\u003e北京\u003c/option\u003e \u003coption value=\"\"\u003e上海\u003c/option\u003e \u003coption value=\"\"\u003e天津\u003c/option\u003e \u003coption value=\"\"\u003e重庆\u003c/option\u003e \u003c/optgroup\u003e \u003coptgroup label=\"省级\"\u003e \u003coption value=\"\"\u003e广州\u003c/option\u003e \u003coption value=\"\"\u003e深圳\u003c/option\u003e \u003c/optgroup\u003e \u003c/select\u003e \u003c!-- label标签 --\u003e \u003c!-- label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。 如果您在 label 元素内点击文本，就会触发此控件。 就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。--\u003e \u003cform action=\"\" method=\"post\" name=\"form\"\u003e \u003clabel for=\"MyName\"\u003e姓名：","date":"2019-07-17","objectID":"/2019/07/html/:2:2","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"常用事件 窗口事件 onload : 当文档被载入时执行脚本 onunload : 当文档被卸下时执行脚本 表单事件 onchange : 当元素改变时执行脚本 onsubmit : 当表单被提交时执行脚本 onreset : 当表单被重置时执行脚本 onselect : 当元素被选取时执行脚本 onblur : 当元素失去焦点时执行脚本 onfocus : 当元素获得焦点时执行脚本 键盘事件 onkeydown : 当键盘被按下时执行脚本 onkeypress : 当键盘被按下后又松开时执行脚本 onkeyup : 当键盘被松开时执行脚本 鼠标事件 onclick : 当鼠标被单击时执行脚本 ondblclick : 当鼠标被双击时执行脚本 onmousedown : 当鼠标按钮被按下时执行脚本 onmousemove : 当鼠标指针移动时执行脚本 onmouseout : 当鼠标指针移出某元素时执行脚本 onmouseover : 当鼠标指针悬停于某元素之上时执行脚本 onmouseup : 当鼠标按钮被松开时执行脚本 ","date":"2019-07-17","objectID":"/2019/07/html/:2:3","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"HTML 字符实体 在 HTML 中，某些字符是预留的不能直接使用，如小于号（\u003c）和大于号（\u003e），直接使用会误认为它们是标签。 所以如果我们希望正确地显示预留字符，那必须在 HTML 源代码中使用字符实体（character entities）。 显示结果 描述 实体名称 空格 \u0026nbsp; \u003c 小于号 \u0026lt; \u003e 大于号 \u0026gt; \u0026 和号 \u0026amp; © 版权符号 \u0026copy; × 乘号 \u0026times; ","date":"2019-07-17","objectID":"/2019/07/html/:2:4","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"扩展 ","date":"2019-07-17","objectID":"/2019/07/html/:3:0","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"深入了解 head 元素 \u003chead\u003e 元素用于定义网页的常规信息和元数据，虽然在网页中不可见，但是也是非常的重要。总得来说其里面的子元素大概分为三类，分别是：描述网页基本信息的，指向渲染网页需要其他文件链接的，各大厂商根据自己需要定制的。 网页基本信息 一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。 文档标题（浏览器标签中显示的文本）： \u003ctitle\u003e深入了解 head 元素\u003c/title\u003e 编码格式： \u003cmeta charset=\"utf-8\" /\u003e 视窗设置： \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /\u003e 搜索引擎优化相关内容： \u003cmeta name=\"keywords\" content=\"学习,前端,html,笔记\" /\u003e \u003cmeta name=\"description\" content=\"告诉搜索引擎网站的基本简介\" /\u003e IE 浏览器版本渲染设置： \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /\u003e 其他文件链接 一个完整的网页光有 HTML 结构是非常简陋的，就如一个毛坯房。有了结构之后，我们还需要加入样式与行为为网页增添色彩。 CSS 文件：\u003clink\u003e 元素经常位于文档的头部，用于引入样式文件 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style.css\" /\u003e JavaScript 文件：JavaScript 部分没必要非要放在文档头部; 实际上，把它放在文档的尾部（在 \u003c/body\u003e标签之前）是一个更好的选择 ，这样可以确保在加载脚本之前浏览器已经解析了 HTML 内容（如果脚本加载某个不存在的元素，浏览器会报错）。 \u003cscript src=“script.js\"\u003e\u003c/script\u003e 厂商定制 比如开启双核浏览器先河的 360 浏览器就定制了一个默认使用哪个内核来渲染页面，可以设置为 webkit 内核、IE 标准，IE 兼容三种模式。代码分别为： \u003c!-- 默认webkit内核 --\u003e \u003cmeta name=\"renderer\" content=\"webkit\" /\u003e \u003c!-- 默认IE标准模式 --\u003e \u003cmeta name=\"renderer\" content=\"ie-stand\" /\u003e \u003c!-- 默认IE兼容模式 --\u003e \u003cmeta name=\"renderer\" content=\"ie-comp\" /\u003e 同样分享页面到 QQ 的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容（具体参阅：腾讯移动 WEB 开发平台）。 \u003cmeta itemprop=\"name\" content=\"这是分享的标题\" /\u003e \u003cmeta itemprop=\"image\" content=\"http://imgcache.qq.com/qqshow/ac/v4/global/logo.png\" /\u003e \u003cmeta name=\"description\" itemprop=\"description\" content=\"这是要分享的内容\" /\u003e HTML meta 标签总结与属性使用介绍 参考 HTML meta 标签总结与属性使用介绍 ","date":"2019-07-17","objectID":"/2019/07/html/:3:1","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"!DOCYTYPE 声明 Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。 HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是\u003c!DOCTYPE\u003e的用处。 \u003c!DOCTYPE\u003e不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。 \u003c!DOCYTYPE\u003e是 HTML5 的版本声明 ","date":"2019-07-17","objectID":"/2019/07/html/:3:2","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"应用场景 ","date":"2019-07-17","objectID":"/2019/07/html/:4:0","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"如何给 DIV 添加onblur事件 div添加onblur事件 一般情况下，onblur事件只在input等元素中才有，而div却没有，因为div本身就没有focus的状态(因为div没有tabindex属性)，所以要给div加上此属性。 focus状态样式变化 定义tabindex属性后，元素是默认会加上焦点虚线的，那么在IE中可以通过hidefocus=\"true\"去除！其他浏览器通过outline=0进行去除！ \u003cdiv tabindex=\"0\" hidefocus=\"true\" onfocus='alert(\"得到焦点\");' onblur='alert(\"失去焦点\");' style=\"border:1px solid #ccc;width:200px;height:200px;outline=0;\"\u003e\u003c/div\u003e div内包含其他可以focus的元素的情况(如果是内部的元素导致的onblur不进行操作) 获取触发onblur时的焦点元素(点击的元素)，如果是自身或者子元素，就不进行操作。 if(relatedTarget != null \u0026\u0026 ($(relatedTarget).hasClass(\"select_m_r_box\") || $(relatedTarget).parents(\".select_m_r_box\").size() \u003e 0)){ return; } 获取焦点元素的浏览器兼容问题(IE坑爹) IE获取触发onblur的相关目标的方式和其他浏览器不同 let relatedTarget = event.relatedTarget; if(relatedTarget === null){ relatedTarget = document.activeElement; } ","date":"2019-07-17","objectID":"/2019/07/html/:4:1","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"参考 HTML 手册 HTML——学习笔记 HTML meta 标签总结与属性使用介绍 GET 和 POST 两种基本请求方法的区别 div添加onblur事件、focus状态样式变化 获取焦点元素的浏览器兼容问题 ","date":"2019-07-17","objectID":"/2019/07/html/:5:0","tags":["语言"],"title":"HTML 知识总结","uri":"/2019/07/html/"},{"categories":null,"content":"问题描述 POI 单元格数据过长报错。 ","date":"2019-07-17","objectID":"/2019/07/poi-e1/:1:0","tags":["问题"],"title":"POI 单元格数据过长问题","uri":"/2019/07/poi-e1/"},{"categories":null,"content":"报错信息 java.lang.IllegalArgumentException: The maximum column width for an individual cell is 255 characters. ","date":"2019-07-17","objectID":"/2019/07/poi-e1/:2:0","tags":["问题"],"title":"POI 单元格数据过长问题","uri":"/2019/07/poi-e1/"},{"categories":null,"content":"产生原因 导出excel时，excel表中的某个单元格数据过大，然而在创建时，使用了localHSSFSheet.setColumnWidth()控制住了单元格的列宽，所以会显示单元格最大列宽255错误。 ","date":"2019-07-17","objectID":"/2019/07/poi-e1/:3:0","tags":["问题"],"title":"POI 单元格数据过长问题","uri":"/2019/07/poi-e1/"},{"categories":null,"content":"解决方式 if(colWidth\u003c255*256){ sheet.setColumnWidth(i, colWidth \u003c 3000 ? 3000 : colWidth); }else{ sheet.setColumnWidth(i, 65000); } ","date":"2019-07-17","objectID":"/2019/07/poi-e1/:4:0","tags":["问题"],"title":"POI 单元格数据过长问题","uri":"/2019/07/poi-e1/"},{"categories":null,"content":"简介 Scoop 是 Windows 下的命令行软件包管理器，特点是不会污染环境变量，根据 Json 安装软件并生成软链接。 ","date":"2019-07-11","objectID":"/2019/07/scoop/:1:0","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"安装 ","date":"2019-07-11","objectID":"/2019/07/scoop/:2:0","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"前置条件 Windows 版本不低于 Windows 7 Windows 中的 PowerShell 版本不低于 PowerShell 3 能访问 GitHub 你的 Windows 用户名为英文 ","date":"2019-07-11","objectID":"/2019/07/scoop/:2:1","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"安装步骤 # 在 PowerShell 修改策略同意。 set-executionpolicy remotesigned -scope currentuser # 配置 scoop 安装路径 [environment]::setEnvironmentVariable('SCOOP','D:\\scoop','User') $env:SCOOP='D:\\scoop' # 安装 scoop iex (new-object net.webclient).downloadstring('https://get.scoop.sh') # 检查是否安装成功 scoop help ","date":"2019-07-11","objectID":"/2019/07/scoop/:2:2","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"使用 ","date":"2019-07-11","objectID":"/2019/07/scoop/:3:0","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"常用命令 # 列出所有 Scoop 命令 # 只写几个常用的，全部命令用help查看 scoop help # 查找软件 # 如果软件搜索不到不妨到社区的 Bucket 库里看下 scoop search \u003c软件名\u003e # 安装软件 #Scoop只会维护软件的最新版本，需要低版本的请去社区的Bucket里查找，比如安装低版本的JDK scoop install \u003c软件名\u003e # 卸载软件 # 安装失败的软件要卸载重装 scoop uninstall \u003c软件名\u003e # 列出所有已安装软件 scoop list # 更新 scoop scoop update # 更新软件 # 查看全部软件状态 scoop status # 更新相应软件 scoop update [软件包] ","date":"2019-07-11","objectID":"/2019/07/scoop/:3:1","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"Scoop Bucket 之前提到过, Scoop 是根据 Json 文件进行软件的下载安装的, Bucket 就是存放这些 Json 文件的地方。官方维护了一个名称叫 main 的 Bucket (收录条件十分苛刻, 举两个例子：必须是主流的开发者工具, 不可以有 GUI), 也不是说没被官方 Bucket 收录的软件就不可以用 Scoop 进行管理了。只是需要我们将别人维护的 Bucket 使用scoop bucket add \u003cBucket Name\u003e命令添加一下，就可以 install 其中的软件了。总之就是如果使用scoop search搜索不到就上Scoop Directory看下。当然你也可以维护你自己的 Bucket。 ","date":"2019-07-11","objectID":"/2019/07/scoop/:3:2","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"配置 # 设置代理 scoop config proxy 127.0.0.1:7890 ","date":"2019-07-11","objectID":"/2019/07/scoop/:4:0","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"Scoop Aria2 # 安装 aria2 自动开启多线程下载 scoop install aria2 # 关闭 aria2 下载 scoop config aria2-enabled false # aria2 配置 # aria2-enabled (默认值: true) # aria2-retry-wait (默认值: 2) # aria2-split (默认值: 5) # aria2-max-connection-per-server (默认值: 5) # aria2-min-split-size (默认值: 5M) # aria2 推荐设置 scoop config aria2-max-connection-per-server 16 scoop config aria2-split 16 scoop config aria2-min-split-size 1M ","date":"2019-07-11","objectID":"/2019/07/scoop/:4:1","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"参考 「一行代码」搞定软件安装卸载，用 Scoop 管理你的 Windows 软件 给 Scoop 加上这些软件仓库，让它变成强大的 Windows 软件管理器 ","date":"2019-07-11","objectID":"/2019/07/scoop/:5:0","tags":["工具"],"title":"Windows 下的软件包管理工具 Scoop","uri":"/2019/07/scoop/"},{"categories":null,"content":"简介 Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。 ","date":"2019-07-08","objectID":"/2019/07/hugo/:1:0","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"安装 # windows 下使用 scoop 安装 scoop install hugo # macOS 下使用 brew 安装 brew install hugo ","date":"2019-07-08","objectID":"/2019/07/hugo/:2:0","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"使用 ","date":"2019-07-08","objectID":"/2019/07/hugo/:3:0","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"本地搭建流程 # 创建site hugo new site \u003csiteName\u003e # 进入site目录 cd .\\siteName\\ # 创建helloWorld hugo new post/hello-world.md # 运行本地服务查看效果 hugo server ","date":"2019-07-08","objectID":"/2019/07/hugo/:3:1","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"配置 ","date":"2019-07-08","objectID":"/2019/07/hugo/:4:0","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"主题配置 # 挑选一个好看的主题这里使用的是 LoveIt # 将主题clone到themes目录, 并且把主题仓库作为你的网站目录的子模块 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt # 阅读你选择的主题的README, 并修改config.toml文件(主题有特殊配置的根据给出的Demo配置)。 theme = 'themeName' ","date":"2019-07-08","objectID":"/2019/07/hugo/:4:1","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"GitHub Page 配置 # hugo命令会将site内容生成静态文件放在public目录下, 注意所有 draft: true 的文章不会被build hugo # 切换目录 cd .\\public\\ # 初始化git项目 git init git add . git commit -m 'first commit' # 关联一个远程仓库，想要使用GitHub Page，项目的名称必须为 \"\u003c你的昵称\u003e.github.io\" git remote add origin \u003c你的项目地址\u003e git push -u origin master # 如果你有自己的域名的话，可以将GitHub Page映射到自己的域名 ","date":"2019-07-08","objectID":"/2019/07/hugo/:4:2","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"Wercker 配置 Wercker 简介 CI 使用的Wercker, 简单直接使用 GitHub 账号注册登录，不需要麻烦的过程。CI 的简单理解就是向一个仓库提交代码后会自动执行的脚本。 Hugo + Wercker 首先要在 github 上新建两个仓库，一个用来存放 site 项目，一个用来存放静态的 public 项目(如使用 GitHub Page 项目名称必须为 username.github.io)。 在Wercker下创建 Application, 请参考教程, 注意需要关联的仓库为 site, 会读取仓库下的 wercker.yml 文件执行脚本。 去 GitHub 上创建一个 token 给 Wercker 操作 GitHub 仓库用，请参考教程, 就是 wercker 脚本里的环境变量, 也要在后台添加下。 因为在 Site 项目里存在子项目，如果使用 submodule 了请参考Git submodule 子模块的管理和使用, 不使用要修改下 wercker.yml 文件，如果报已存在的错误，就先把文件加删除再根据 git 给出的错误提示git rm --cached \u003cmoduleName\u003e, 然后再操作。 在你的 site 仓库根目录下创建 wercker.yml 文件，参考下面。 最后进行 push, 去你的 Wercker 后台看看吧，Enjoy! wercker.yml # This references a standard debian container from the# Docker Hub https://registry.hub.docker.com/_/debian/# Read more about containers on our dev center# http://devcenter.wercker.com/docs/containers/index.htmlbox:debian# You can also use services such as databases. Read more on our dev center:# http://devcenter.wercker.com/docs/services/index.html# services:# - postgres# http://devcenter.wercker.com/docs/services/postgresql.html# - mongo# http://devcenter.wercker.com/docs/services/mongodb.html# This is the build pipeline. Pipelines are the core of wercker# Read more about pipelines on our dev center# http://devcenter.wercker.com/docs/pipelines/index.htmlbuild:# Steps make up the actions in your pipeline# Read more about steps on our dev center:# http://devcenter.wercker.com/docs/steps/index.htmlsteps:- script:name:installgitcode:| apt-get updateapt-getinstallgit-y- script:# 如果使用submodules, 记得添加配置文件.gitmodulesname:initializeandupdategitsubmodulescode:| git submodule initgitsubmoduleupdate--remote--recursive- arjen/hugo-build:theme:LoveItflags:--buildDrafts=true- npm-install- script:name:publishalgoliajsoncode:| npm run algoliadeploy:steps:- install-packages:packages:gitssh-client# 官方给的lukevivier/gh-pages@0.2.1会部署到gh-pages分支，17年我用的时候没这毛病，这里改用别的Step# 部署public目录下的静态文件至username.github.io的master分支- sf-zhou/gh-pages@0.2.6:token:$GIT_TOKENdomain:http://blog.orionpax.toprepo:OrionPax19970905/OrionPax19970905.github.iobranch:masterbasedir:public ","date":"2019-07-08","objectID":"/2019/07/hugo/:4:3","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"},{"categories":null,"content":"参考 Hugo Themes hugo-theme-even hugo-theme-zozo hugo-theme-LoveIt 如何使用 Github Page 自定义域名设置 ","date":"2019-07-08","objectID":"/2019/07/hugo/:5:0","tags":["工具"],"title":"如何使用 Hugo 进行个人博客搭建","uri":"/2019/07/hugo/"}]